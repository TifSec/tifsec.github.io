<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programme NSI Tle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Calibri, sans-serif;
            line-height: 1.6;
            background-color: #f4f4f4;
        }

        header {
            background-color: #4CAF50;
            color: white;
            text-align: center;
            padding: 1rem;
        }

        main {
            margin-left: 200px;
            padding: 20px;
            min-height: 80vh;
        }

        .content-section {
            display: none;
        }

        .content-section.active {
            display: block;
        }

        aside {
            position: fixed;
            left: 0;
            top: 0;
            height: 100%;
            width: 200px;
            background-color: #333;
            color: white;
            padding-top: 20px;
            transition: width 0.3s ease;
            overflow-y: auto;
            scrollbar-width: none; /* Masque la barre de défilement pour Firefox */
        }

        aside::-webkit-scrollbar {
            display: none; /* Masque la barre de défilement pour Chrome, Safari, et Opera */
        }

        aside ul {
            list-style: none;
            padding: 0;
        }

        aside ul li {
            padding: 10px;
        }

        aside ul li a {
            color: white;
            text-decoration: none;
            display: block;
            padding: 10px;
        }

        /* Style pour l'élément de menu actif (séance en cours) */
        aside ul li a.active {
            background-color: #4CAF50; /* Couleur pour l'élément actif */
            color: white;
            font-weight: bold;
        }

        aside ul li a:hover {
            background-color: #555;
        }

        .hamburger {
            background-color: #4CAF50;
            color: white;
            border: none;
            width: 100%;
            padding: 15px;
            text-align: left;
            cursor: pointer;
        }

        footer {
            background-color: #4CAF50;
            color: white;
            text-align: center;
            padding: 10px 0;
            position: fixed;
            bottom: 0;
            width: 100%;
        }

        h2, h3, h4, h5{
            text-align: center;
        }

        h2 {
            color: #333;
            margin-bottom: 15px;
        }

        h4, h5, p, ul{
            margin-top: 10px;
            margin-bottom: 10px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }

        table, th, td {
            border: 1px solid black;
        }

        th, td {
            padding: 10px;
            text-align: center;
        }

        img {
            max-width: 100%;
            height: auto;
        }

        /* Styles spécifiques pour le calendrier */
        table.calendar {
            margin: 20px auto;
            border-collapse: collapse;
            width: 80%;
        }

        th, td {
            padding: 10px;
            text-align: center;
            border: 1px solid #ccc;
        }

        .current-week {
            background-color: #add8e6; /* Couleur bleue clair pour la semaine en cours */
        }

        pre{
            background-color: black;
            color: white;
        }

        .today {
            background-color: #007BFF; /* Bleu vif pour le jour actuel */
            color: white; /* Texte blanc pour le contraste */
        }

        .vacation {
            background-color: #B2E4A6; /* Vert pastel pour les vacances */
            color: black; /* Texte noir ou foncé pour la lisibilité */
        }

        .holiday {
            background-color: #FF6B6B; /* Rouge clair pour les jours fériés */
            color: white; /* Texte blanc ou clair */
        }
    </style>
</head>
<body>

    <header>
        <h1>Programme NSI Tle</h1>
    </header>

    <!-- Menu hamburger sur la gauche -->
    <aside id="menu">
        <button class="hamburger" onclick="toggleMenu()">☰ Séances</button>
        <nav id="session-nav">
            <ul>
                <!-- PROGRAMME -->
                <li><a href="#" onclick="showSession('programme-nsi')">Programme de l'année</a></li>

                <!-- CALENDRIER -->
                <li><a href="#" onclick="showSession('calendar')">Calendrier de cours</a></li>

                <!-- COURS -->
                <li><a href="#" onclick="showSession('session1')">Séance 1 : Introduction à la récursivité (concepts de base)</a></li>
                <li><a href="#" onclick="showSession('session2')">Séance 2 : Pratique - Implémentation d’une fonction récursive pour calculer une suite mathématique</a></li>
                <li><a href="#" onclick="showSession('session3')">Séance 3 : Applications pratiques de la récursivité (problèmes simples)</a></li>
                <li><a href="#" onclick="showSession('session4')">Séance 4 : Introduction aux Algorithmes de Recherche Récursive – Recherche Binaire</a></li>
                <li><a href="#" onclick="showSession('session5')">Séance 5 : Pratique – Recherche d’un Personnage de Manga avec un Algorithme de Recherche Binaire</a></li>
                <li><a href="#" onclick="showSession('session6')">Séance 6 : Analyse de la Complexité d’un Algorithme de Recherche Récursive</a></li>
                <li><a href="#" onclick="showSession('session7')">Séance 7 : Introduction au Backtracking (Concepts de Base)</a></li>
                <li><a href="#" onclick="showSession('session8')">Séance 8 : Pratique - Résolution d'un Labyrinthe avec Backtracking (Jeu Vidéo)</a></li>
                <li><a href="#" onclick="showSession('session9')">Séance 9 : Étude des Cas Où le Backtracking Est Utile et de Ses Limitations</a></li>
                <li><a href="#" onclick="showSession('session10')">Séance 10 : Introduction à la Complexité Algorithmique – Notation Big-O</a></li>
                <li><a href="#" onclick="showSession('session11')">Séance 11 : Pratique - Comparaison des Algorithmes de Tri Simples (Insertion, Sélection)</a></li>
                <li><a href="#" onclick="showSession('session12')">Séance 12 : Exercices d’Analyse de la Complexité des Algorithmes dans des Jeux Vidéo et la Vie Réelle</a></li>
                <li><a href="#" onclick="showSession('session13')">Séance 13 : Introduction aux Graphes et à leurs Applications</a></li>
                <li><a href="#" onclick="showSession('session14')">Séance 14 : Pratique - Représentation d'un Réseau de Routes dans un Jeu Vidéo avec des Graphes</a></li>
                <li><a href="#" onclick="showSession('session15')">Séance 15 : Algorithmes de Parcours de Graphes – DFS et BFS</a></li>
                <li><a href="#" onclick="showSession('session16')">Séance 16 : Approfondissement sur l’algorithme DFS (Depth-First Search)</a></li>
                <li><a href="#" onclick="showSession('session17')">Séance 17 : Pratique - Exploration d’un Monde Ouvert (Jeu Vidéo) avec DFS</a></li>
                <li><a href="#" onclick="showSession('session18')">Séance 18 : Applications Réelles des Graphes (Réseaux Sociaux, Chemins dans les Transports)</a></li>
                <li><a href="#" onclick="showSession('session19')">Séance 19 : Introduction aux Arbres Binaires et leurs Applications</a></li>
                <li><a href="#" onclick="showSession('session20')">Séance 20 : Pratique - Utilisation d’arbres pour organiser une base de données de personnages de manga</a></li>
                <li><a href="#" onclick="showSession('session21')">Séance 21 : Algorithmes de Parcours d’Arbres (Pré-ordre, En-ordre, Post-ordre)</a></li>
                <!-- <li><a href="#" onclick="showSession('session22')">Séance 22 : </a></li>
                <li><a href="#" onclick="showSession('session23')">Séance 23 : </a></li>
                <li><a href="#" onclick="showSession('session24')">Séance 24 : </a></li>
                <li><a href="#" onclick="showSession('session25')">Séance 25 : </a></li>
                <li><a href="#" onclick="showSession('session26')">Séance 26 : </a></li>
                <li><a href="#" onclick="showSession('session27')">Séance 27 : </a></li>
                <li><a href="#" onclick="showSession('session28')">Séance 28 : </a></li>
                <li><a href="#" onclick="showSession('session29')">Séance 29 : </a></li>
                <li><a href="#" onclick="showSession('session30')">Séance 30 : </a></li> -->
            </ul>
        </nav>
    </aside>

    <main id="content">
        <!-- Programme -->
        <section id="programme-nsi" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Programme Terminale NSI</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 1 : Récursivité</h3>
            <ul>
                <li><strong>Séance 1 :</strong> Introduction à la récursivité (concepts de base).</li>
                <li><strong>Séance 2 :</strong> Pratique - Implémentation d’une fonction récursive pour calculer une suite mathématique.</li>
                <li><strong>Séance 3 :</strong> Applications pratiques de la récursivité (problèmes simples).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 2 : Recherche Récursive</h3>
            <ul>
                <li><strong>Séance 4 :</strong> Introduction aux algorithmes de recherche récursive (recherche binaire).</li>
                <li><strong>Séance 5 :</strong> Pratique - Recherche d’un élément dans une liste de personnages de manga avec un algorithme de recherche binaire.</li>
                <li><strong>Séance 6 :</strong> Analyse de la complexité d'un algorithme de recherche récursive.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 3 : Backtracking</h3>
            <ul>
                <li><strong>Séance 7 :</strong> Introduction au backtracking (concepts de base).</li>
                <li><strong>Séance 8 :</strong> Pratique - Résolution d’un labyrinthe avec backtracking (jeu vidéo).</li>
                <li><strong>Séance 9 :</strong> Étude des cas où le backtracking est utile et de ses limitations.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 4 : Complexité Algorithmique</h3>
            <ul>
                <li><strong>Séance 10 :</strong> Introduction à la complexité algorithmique (notation Big-O).</li>
                <li><strong>Séance 11 :</strong> Pratique - Comparaison des algorithmes de tri simples (insertion, sélection).</li>
                <li><strong>Séance 12 :</strong> Exercices d’analyse de la complexité d’algorithmes dans des jeux vidéos et la vie réelle.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 5 : Structures de Données - Graphes</h3>
            <ul>
                <li><strong>Séance 13 :</strong> Introduction aux graphes et à leurs applications (théorie des graphes).</li>
                <li><strong>Séance 14 :</strong> Pratique - Représentation d'un réseau de routes dans un jeu vidéo avec des graphes.</li>
                <li><strong>Séance 15 :</strong> Algorithmes de parcours de graphes (DFS et BFS).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 6 : Algorithmes de Parcours de Graphes</h3>
            <ul>
                <li><strong>Séance 16 :</strong> Approfondissement sur l’algorithme DFS (Depth-First Search).</li>
                <li><strong>Séance 17 :</strong> Pratique - Exploration d'un monde ouvert (jeu vidéo) avec DFS.</li>
                <li><strong>Séance 18 :</strong> Applications réelles des graphes (réseaux sociaux, chemins dans les transports).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 7 : Arbres Binaires</h3>
            <ul>
                <li><strong>Séance 19 :</strong> Introduction aux arbres binaires et leurs applications.</li>
                <li><strong>Séance 20 :</strong> Pratique - Utilisation d’arbres pour organiser une base de données de personnages de manga.</li>
                <li><strong>Séance 21 :</strong> Algorithmes de parcours d’arbres (pré-ordre, en-ordre, post-ordre).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 8 : Algorithmes sur les Arbres</h3>
            <ul>
                <li><strong>Séance 22 :</strong> Approfondissement sur les algorithmes de parcours d’arbres.</li>
                <li><strong>Séance 23 :</strong> Pratique - Création d’un arbre de décision pour un jeu de rôle (jeu vidéo).</li>
                <li><strong>Séance 24 :</strong> Analyse des performances et avantages des arbres dans la recherche et le tri.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 9 : Algorithmes de Tri Avancés</h3>
            <ul>
                <li><strong>Séance 25 :</strong> Introduction au tri rapide (Quicksort).</li>
                <li><strong>Séance 26 :</strong> Pratique - Implémentation du Quicksort pour trier des scores de jeu vidéo.</li>
                <li><strong>Séance 27 :</strong> Comparaison de la complexité des différents algorithmes de tri.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 10 : Heapsort</h3>
            <ul>
                <li><strong>Séance 28 :</strong> Introduction au tri par tas (Heapsort).</li>
                <li><strong>Séance 29 :</strong> Pratique - Utilisation du Heapsort pour organiser un inventaire dans un jeu vidéo.</li>
                <li><strong>Séance 30 :</strong> Analyse de la complexité du Heapsort et de ses applications.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 11 : Tri Fusion</h3>
            <ul>
                <li><strong>Séance 31 :</strong> Introduction au tri fusion (Merge Sort).</li>
                <li><strong>Séance 32 :</strong> Pratique - Implémentation du tri fusion pour classer des mangas par popularité.</li>
                <li><strong>Séance 33 :</strong> Étude comparative des algorithmes de tri avancés (Quicksort, Heapsort, Merge Sort).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 12 : Optimisation des Algorithmes de Tri</h3>
            <ul>
                <li><strong>Séance 34 :</strong> Optimisation des algorithmes de tri dans des contextes réels.</li>
                <li><strong>Séance 35 :</strong> Pratique - Choisir et implémenter l’algorithme de tri le plus efficace pour différentes situations (jeu vidéo, actualité).</li>
                <li><strong>Séance 36 :</strong> Révision et consolidation des concepts d'algorithmes de tri.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 13 : Programmation Orientée Objet (POO)</h3>
            <ul>
                <li><strong>Séance 37 :</strong> Introduction à la POO (classes, objets, méthodes).</li>
                <li><strong>Séance 38 :</strong> Pratique - Modélisation d’un personnage de jeu vidéo en POO.</li>
                <li><strong>Séance 39 :</strong> Héritage et polymorphisme (théorie).</li>
            </ul>
        
            <!-- Continuez d'ajouter les semaines suivantes en suivant cette structure -->
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 14 : Héritage et Polymorphisme</h3>
            <ul>
                <li><strong>Séance 40 :</strong> Pratique - Implémentation d’un système d’héritage dans une application de gestion de personnages (jeu vidéo).</li>
                <li><strong>Séance 41 :</strong> Design patterns (Singleton, Factory).</li>
                <li><strong>Séance 42 :</strong> Pratique - Utilisation de design patterns pour optimiser la gestion des niveaux d’un jeu vidéo.</li>
            </ul>
        
            <!-- Ajoutez plus de semaines ici -->
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 36 : Bilan et Clôture</h3>
            <ul>
                <li><strong>Séance 106 :</strong> Bilan de l’année et retour sur les projets.</li>
                <li><strong>Séance 107 :</strong> Clôture et perspectives pour le futur.</li>
                <li><strong>Séance 108 :</strong> Journée de détente (activité créative, jeux de programmation).</li>
            </ul>
        </section>

        <!-- Calendrier -->
        <section id="calendar" class="content-section">
            <h2>Calendrier de cours des Tle NSI - 2024/2025</h2>
            <table class="calendar">
                <thead>
                    <tr>
                        <th>Date Mercredi</th>
                        <th>Cours Mercredi</th>
                        <th>Date Jeudi</th>
                        <th>Cours Jeudi</th>
                        <th>Date Vendredi</th>
                        <th>Cours Vendredi</th>
                    </tr>
                </thead>
                <tbody id="calendar-body">
                    <!-- Les lignes du calendrier seront générées ici par JavaScript -->
                </tbody>
            </table>
        </section>

        <!-- Cours -->
        <section id="session1" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 1 : Introduction à la Récursivité (Concepts de Base)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectifs de la séance :</h3>
            <ul>
                <li>Comprendre le concept de récursivité (cas de base et cas récursif).</li>
                <li>Savoir identifier et écrire des fonctions récursives.</li>
                <li>Appliquer la récursivité dans un problème lié aux jeux vidéo.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte : Sauver le héros d’un labyrinthe</h3>
            <p>L’objectif est d'aider un héros à sortir d’un labyrinthe en utilisant la récursivité. Chaque étape dans le labyrinthe représente une décision à prendre pour avancer ou reculer. Le labyrinthe est un tableau 2D où chaque cellule peut être un mur, un chemin ou la sortie.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Introduction au concept de récursivité</h3>
            <p>Qu’est-ce que la récursivité ?</p>
            <p>Une fonction récursive est une fonction qui s'appelle elle-même pour résoudre une version plus simple d’un problème.</p>
        
            <p>Une fonction récursive suit deux règles :</p>
            <ul>
                <li><strong>Cas de base :</strong> Condition d’arrêt pour éviter que la fonction ne s'appelle indéfiniment.</li>
                <li><strong>Cas récursif :</strong> Un appel à la fonction elle-même avec une version réduite du problème.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple simple : La Factorielle</h4>
            <pre><code>
    def factorielle(n):
        if n == 0:  # Cas de base
            return 1
        else:
            return n * factorielle(n - 1)  # Cas récursif
            </code></pre>
        
            <p>Explication du fonctionnement :</p>
            <p>Si <code>n = 3</code>, la fonction va appeler <code>factorielle(2)</code>, puis <code>factorielle(1)</code>, puis <code>factorielle(0)</code> qui est le cas de base, et renverra le résultat en remontant.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Application : Sauver un Héros Coincé dans un Labyrinthe</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Problème</h4>
            <p>Le héros est piégé dans un labyrinthe modélisé par une grille 2D. Il peut se déplacer à gauche, à droite, en haut ou en bas. L'objectif est de trouver la sortie (marquée par un "E") en utilisant une approche récursive.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Modélisation du labyrinthe</h4>
            <p>Nous représentons le labyrinthe comme une liste de listes en Python :</p>
        
            <pre><code>
    labyrinthe = [
        ['S', 1, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0]
    ]
            </code></pre>
        
            <ul>
                <li><strong>'S' :</strong> Point de départ (start).</li>
                <li><strong>'E' :</strong> Sortie.</li>
                <li><strong>0 :</strong> Chemin libre.</li>
                <li><strong>1 :</strong> Mur.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exploration récursive du labyrinthe</h4>
            <p>Le héros doit explorer toutes les directions possibles. Pour cela, nous allons créer une fonction récursive qui essaie toutes les directions (haut, bas, gauche, droite).</p>
        
            <pre><code>
    def explorer_labyrinthe(labyrinthe, x, y, visitees):
        # Vérifier les limites du labyrinthe
        if x < 0 or x >= len(labyrinthe) or y < 0 or y >= len(labyrinthe[0]):
            return False
        
        # Vérifier si la case est un mur ou déjà visitée
        if labyrinthe[x][y] == 1 or (x, y) in visitees:
            return False
        
        # Si on a trouvé la sortie
        if labyrinthe[x][y] == 'E':
            print(f"Sortie trouvée à la position ({x}, {y})")
            return True
        
        # Marquer la case comme visitée
        visitees.add((x, y))
        
        # Appeler la fonction récursive dans les 4 directions
        if (explorer_labyrinthe(labyrinthe, x+1, y, visitees) or  # Bas
            explorer_labyrinthe(labyrinthe, x-1, y, visitees) or  # Haut
            explorer_labyrinthe(labyrinthe, x, y+1, visitees) or  # Droite
            explorer_labyrinthe(labyrinthe, x, y-1, visitees)):   # Gauche
            return True
        
        # Si aucune direction ne fonctionne, on retourne False
        return False
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Explication du Code</h4>
            <ul>
                <li><strong>Cas de base :</strong> Si le héros sort du labyrinthe ou rencontre un mur (<code>1</code>), la fonction retourne <code>False</code>. Si le héros atteint la sortie (<code>'E'</code>), la fonction retourne <code>True</code>.</li>
                <li><strong>Cas récursif :</strong> Le héros essaie chaque direction (bas, haut, gauche, droite) en appelant la fonction récursive pour continuer à explorer le labyrinthe.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Mise en Pratique</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Tester l’exploration du labyrinthe</h4>
            <p>Les élèves doivent modifier et exécuter la fonction pour que le héros puisse trouver la sortie.</p>
        
            <pre><code>
    # Position de départ (0, 0)
    position_depart = (0, 0)
    
    # Ensemble des cases visitées
    cases_visitees = set()
    
    # Lancer la recherche de la sortie
    explorer_labyrinthe(labyrinthe, position_depart[0], position_depart[1], cases_visitees)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Améliorations</h4>
            <ul>
                <li><strong>Marquer le chemin parcouru :</strong> Ajouter une fonctionnalité pour afficher le chemin que le héros a pris jusqu'à la sortie.</li>
                <li><strong>Compter les mouvements :</strong> Ajouter un compteur pour afficher combien de mouvements le héros a effectués avant de trouver la sortie.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Conclusion et Récapitulatif</h3>
        
            <p><strong>Ce qu’ils ont appris :</strong></p>
            <ul>
                <li>Comprendre les concepts de récursivité avec un cas de base et un cas récursif.</li>
                <li>Appliquer la récursivité pour résoudre des problèmes complexes, comme un labyrinthe.</li>
            </ul>
        
            <p><strong>Défis à venir :</strong></p>
            <ul>
                <li>D'autres applications de la récursivité dans les jeux vidéo et les structures de données (arbres, tri récursif).</li>
                <li>Combiner récursivité et optimisations (mémoïsation) pour rendre les algorithmes plus efficaces.</li>
            </ul>
        </section>

        <section id="session2" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 2 : Pratique - Implémentation d’une Fonction Récursive pour Calculer une Suite Mathématique</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif :</h3>
            <ul>
                <li>Comprendre et implémenter une fonction récursive.</li>
                <li>Appliquer la récursivité pour résoudre un problème pratique, inspiré des mécanismes de jeux vidéo.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte :</h3>
            <p>Dans un jeu vidéo, un personnage accumule des points d'attaque supplémentaires au fil du temps à chaque coup porté à l'ennemi, mais les points bonus diminuent à chaque itération jusqu'à atteindre un seuil minimum. Cela peut être représenté par une suite mathématique où le bonus d'attaque à chaque coup est calculé récursivement.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple Concret :</h4>
            <p>Le personnage gagne 10 points d'attaque lors du premier coup, puis le bonus diminue de 1 point à chaque coup suivant. Cela forme une série mathématique décrite par :</p>
            <pre><code>Attaque(n) = Attaque(n−1) + (bonus initial − n)</code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 1 : Introduction à la Récursivité</h3>
            <p><strong>Concept de la récursivité :</strong></p>
            <p>Une fonction récursive s'appelle elle-même pour résoudre un problème plus simple à chaque étape, jusqu'à atteindre une condition de fin (ou cas de base).</p>
            
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple théorique :</h4>
            <p>Calcul de la suite de Fibonacci ou de la factorielle pour illustrer la récursivité.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 2 : Implémentation d'une Fonction Récursive</h3>
            <p><strong>Problème :</strong> Dans le jeu, à chaque attaque, le personnage accumule des points bonus. Le premier coup ajoute 10 points, puis chaque coup suivant ajoute 1 point de moins que le précédent jusqu'à atteindre 0. L'objectif est de calculer combien de points d'attaque sont accumulés après un certain nombre de coups.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Fonction récursive pour calculer le bonus d'attaque :</h4>
            <pre><code>
    def attaque_bonus(n):
        # Cas de base : quand le bonus atteint 0
        if n == 0:
            return 0
        else:
            # Récursion : bonus initial (10) - n + bonus précédent
            return (10 - n) + attaque_bonus(n - 1)
    
    # Exemple d'utilisation :
    coups = 5  # Le personnage donne 5 coups
    total_bonus = attaque_bonus(coups)
    print(f"Le total des points d'attaque après {coups} coups est de : {total_bonus}")
            </code></pre>
        
            <p><strong>Explication :</strong></p>
            <ul>
                <li>La fonction se base sur un cas de base où aucun coup n'est porté (0 bonus).</li>
                <li>À chaque appel récursif, le nombre de coups diminue de 1, et le bonus est calculé en fonction du coup précédent.</li>
                <li>Le bonus d’attaque diminue jusqu'à ce que la fonction atteigne le cas de base (0).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 3 : Étendre la Fonctionnalité</h3>
            <p>Amélioration du jeu : Proposer aux élèves d’ajouter des conditions supplémentaires :</p>
            <ul>
                <li>Le bonus ne peut pas descendre en dessous de 0.</li>
                <li>Ajouter un effet multiplicateur pour chaque coup critique (par exemple, multiplier par 2 si c’est un coup critique).</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple d’amélioration :</h4>
            <pre><code>
    def attaque_bonus(n, critique=False):
        if n == 0:
            return 0
        else:
            bonus = (10 - n)  # Le bonus diminue avec chaque coup
            if critique and n % 3 == 0:
                bonus *= 2  # Coup critique tous les 3 coups
            return bonus + attaque_bonus(n - 1, critique)
    
    # Exemple d'utilisation :
    coups = 5
    total_bonus = attaque_bonus(coups, critique=True)
    print(f"Le total des points d'attaque avec coups critiques est de : {total_bonus}")
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 4 : Exercices Pratiques</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Calcul d'attaque simple :</h4>
            <p>Modifier le nombre de coups portés et afficher le total des points d'attaque.</p>
            <p><strong>Exercice :</strong> Demander aux élèves de tester avec 3, 5 et 10 coups pour voir comment la récursivité calcule le total.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">2. Scénario avancé : Combats de boss :</h4>
            <p>Simuler un combat contre un boss où chaque coup critique donne des points bonus supplémentaires.</p>
            <p><strong>Exercice :</strong> Les élèves doivent implémenter une version du programme où tous les 5 coups, le personnage inflige un coup critique (multiplication du bonus par 3).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion</h3>
            <p><strong>Retour sur la notion de récursivité :</strong></p>
            <ul>
                <li><strong>Avantage :</strong> La récursivité permet de simplifier des calculs répétitifs en divisant le problème en sous-problèmes.</li>
                <li><strong>Inconvénient :</strong> Elle peut entraîner des problèmes de performance si elle est mal utilisée (pile d'appels récursifs trop grande).</li>
            </ul>
        
            <p><strong>Lien avec le jeu vidéo :</strong> La récursivité est un outil puissant pour modéliser des mécanismes de jeu où des actions répétitives évoluent à chaque itération, comme la gestion des dégâts dans les combats.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice final :</h4>
            <p>Les élèves devront créer une version améliorée de la fonction récursive qui inclut plusieurs types de coups (coup normal, coup critique, coup spécial) avec des bonus différents et implémenter une stratégie pour battre un boss avec un nombre limité de coups.</p>
        </section>

        <section id="session3" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 3 : Applications Pratiques de la Récursivité - Problèmes Simples</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectifs de la séance :</h3>
            <ul>
                <li>Comprendre la récursivité à travers des exemples simples.</li>
                <li>Appliquer la récursivité pour résoudre des problèmes inspirés des jeux vidéo.</li>
                <li>Créer des programmes interactifs et ludiques en utilisant la récursivité.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Rappel des concepts de base de la récursivité</h3>
            <p><strong>Cas de base :</strong> Condition qui permet d'arrêter la récursivité.</p>
            <p><strong>Cas récursif :</strong> La fonction qui s'appelle elle-même avec une version simplifiée du problème.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple théorique :</h4>
            <p>Calcul de la factorielle d’un nombre.</p>
            <pre><code>
    def factorielle(n):
        if n == 0:
            return 1  # Cas de base
        else:
            return n * factorielle(n - 1)  # Cas récursif
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Application : Exploration d'un Donjon Récursif</h3>
            <p>Dans ce projet, nous allons simuler un héros explorant un donjon. Le donjon est représenté par un labyrinthe (sous forme de matrice 2D), où le héros doit trouver la sortie. La récursivité sera utilisée pour explorer toutes les directions possibles à chaque intersection du labyrinthe.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Modélisation du donjon</h4>
            <p>Le donjon est représenté par une matrice où :</p>
            <ul>
                <li>1 représente un mur,</li>
                <li>0 représente un chemin libre,</li>
                <li><strong>S</strong> la position de départ,</li>
                <li><strong>E</strong> la sortie à atteindre.</li>
            </ul>
            <pre><code>
    donjon = [
        ['S', 1, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0]
    ]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Création de la fonction récursive d’exploration</h4>
            <p>On écrit une fonction récursive pour explorer le donjon. À chaque étape, le héros explore les cases adjacentes (haut, bas, gauche, droite) jusqu'à trouver la sortie.</p>
            <pre><code>
    def explorer_donjon(donjon, x, y, visitees):
        # Vérifier les limites du donjon
        if x < 0 or x >= len(donjon) or y < 0 or y >= len(donjon[0]):
            return False
        
        # Vérifier si c'est un mur ou une case déjà visitée
        if donjon[x][y] == 1 or (x, y) in visitees:
            return False
        
        # Si on a trouvé la sortie
        if donjon[x][y] == 'E':
            print(f"Sortie trouvée à la position ({x}, {y})")
            return True
        
        # Marquer la case comme visitée
        visitees.add((x, y))
        
        # Exploration récursive des 4 directions
        if (explorer_donjon(donjon, x+1, y, visitees) or  # Bas
            explorer_donjon(donjon, x-1, y, visitees) or  # Haut
            explorer_donjon(donjon, x, y+1, visitees) or  # Droite
            explorer_donjon(donjon, x, y-1, visitees)):   # Gauche
            return True
        
        # Si aucune direction ne permet d’avancer, retour en arrière
        return False
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Lancement de l'exploration</h4>
            <p>L’appel de la fonction d'exploration depuis la position de départ :</p>
            <pre><code>
    visitees = set()
    explorer_donjon(donjon, 0, 0, visitees)
            </code></pre>
            <p>Les élèves peuvent visualiser comment la récursivité permet au héros de tester différentes directions jusqu'à trouver la sortie du donjon.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Application : Génération de Terrains Fractals avec la Récursivité</h3>
            <p>Un autre exemple ludique pour explorer la récursivité est la génération de terrains fractals. C’est un algorithme utilisé dans certains jeux vidéo pour générer des paysages ou des environnements de manière procédurale.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Introduction au concept des fractals</h4>
            <p>Explication de la notion de fractal : une figure qui se divise en parties similaires à l'ensemble.</p>
            <p>On montre un exemple simple, tel que le triangle de Sierpinski ou un arbre fractal, qui est un arbre où chaque branche se divise en deux sous-branches plus petites.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Génération d’un arbre fractal</h4>
            <p>Nous allons utiliser la récursivité pour dessiner un arbre où chaque branche se divise en deux sous-branches plus petites. Pour simplifier, on peut utiliser la bibliothèque turtle de Python, qui permet de dessiner facilement.</p>
            <pre><code>
    import turtle

    def dessiner_arbre(longueur, angle):
        if longueur > 5:
            turtle.forward(longueur)
            turtle.right(angle)
            dessiner_arbre(longueur - 15, angle)
            turtle.left(angle * 2)
            dessiner_arbre(longueur - 15, angle)
            turtle.right(angle)
            turtle.backward(longueur)
    
    # Initialisation de Turtle
    turtle.speed("fastest")
    turtle.left(90)  # Faire pointer la tortue vers le haut
    dessiner_arbre(100, 30)  # Commence avec une longueur de 100
    turtle.done()
            </code></pre>
            <p>Les élèves pourront voir comment la récursivité permet de générer une figure qui se répète de manière auto-similaire.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Conclusion et Améliorations</h3>
            <p><strong>Extension de l’exploration du donjon :</strong> Les élèves peuvent être encouragés à ajouter des obstacles, des trésors ou d'autres éléments interactifs dans le donjon pour rendre l'exploration plus intéressante.</p>
            <p><strong>Améliorations sur l’arbre fractal :</strong> Les élèves peuvent modifier l’angle de l’arbre fractal ou ajouter des couleurs pour rendre le dessin plus complexe et esthétique.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Discussion :</h4>
            <ul>
                <li>Quand utiliser la récursivité vs les boucles ?</li>
                <li>Les limites de la récursivité (profondeur maximale de récursion, efficacité).</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice :</h4>
            <p>Modifier le code de l’exploration du donjon pour ajouter des monstres ou des pièges à éviter pendant l'exploration.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion de la Séance</h3>
            <p>À la fin de cette séance, les élèves auront appris à utiliser la récursivité pour résoudre des problèmes d’exploration et de génération d’environnements, avec des exemples concrets tirés des jeux vidéo. Cela les prépare à appliquer la récursivité dans des projets plus complexes à l'avenir.</p>
        </section>

        <section id="session4" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 4 : Introduction aux Algorithmes de Recherche Récursive – Recherche Binaire</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre et implémenter un algorithme de recherche binaire en utilisant une approche récursive. Ils doivent également l'appliquer à un contexte ludique (jeu vidéo) pour renforcer la compréhension par la pratique.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction à la Recherche Binaire</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Le Contexte :</h4>
            <p>Dans un jeu vidéo de chasse au trésor, le joueur doit trouver un trésor caché sur une île divisée en 100 sections numérotées de 1 à 100. Le joueur ne sait pas où le trésor est caché et doit le retrouver en posant des questions.</p>
            <p><strong>Problème initial :</strong> Si le joueur cherche le trésor en vérifiant chaque section, cela peut prendre beaucoup de temps. On appelle cela une recherche linéaire. Si le trésor est dans la dernière section, il devra vérifier toutes les sections avant d'arriver à la bonne, ce qui est peu efficace.</p>
            <p><strong>Solution optimisée :</strong> Utiliser la recherche binaire pour diviser l’espace de recherche en deux à chaque étape. Cela permet de réduire le nombre de vérifications nécessaires.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">L'idée de la Recherche Binaire :</h4>
            <p>La recherche binaire est un algorithme qui repose sur le principe de diviser pour régner (divide and conquer). Voici les étapes :</p>
            <ul>
                <li>Le joueur divise la zone de recherche en deux parties égales.</li>
                <li>Le joueur demande si le trésor se trouve dans la partie supérieure ou inférieure.</li>
                <li>À chaque étape, l’algorithme divise à nouveau la zone en deux et répète le processus jusqu’à ce que la section contenant le trésor soit trouvée.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple Concret :</h4>
            <p>Imaginons que le trésor soit dans la section 75.</p>
            <ol>
                <li>Étape 1 : Le joueur commence par diviser la zone en deux et vérifie la section du milieu (50).</li>
                <li>Est-ce que le trésor est dans la section 50 ? Non.</li>
                <li>Le trésor est-il dans une section plus haute ou plus basse que 50 ? Le trésor est dans une section plus haute.</li>
                <li>Étape 2 : Le joueur cherche donc dans les sections 51 à 100. La nouvelle section du milieu est 75.</li>
                <li>Est-ce que le trésor est dans la section 75 ? Oui !</li>
                <li>Le trésor est trouvé.</li>
            </ol>
            <p><strong>Avantage :</strong> En seulement 2 étapes, le joueur a trouvé le trésor, alors qu'une recherche linéaire aurait pris 75 étapes.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Explication Théorique de la Recherche Binaire</h3>
            <p>Comment ça fonctionne en termes d’algorithme :</p>
            <ol>
                <li><strong>Début :</strong> L’algorithme commence avec une liste triée de sections (de 1 à 100).</li>
                <li><strong>Milieu :</strong> Il trouve la section au milieu de la liste.</li>
                <li><strong>Comparaison :</strong> Il compare la section du milieu avec la section où le trésor est caché :
                    <ul>
                        <li>Si le trésor est dans la section du milieu, il s’arrête là.</li>
                        <li>Si le trésor est dans une section plus petite, il continue à chercher dans la moitié inférieure.</li>
                        <li>Si le trésor est dans une section plus grande, il continue à chercher dans la moitié supérieure.</li>
                    </ul>
                </li>
                <li><strong>Récursion :</strong> L’algorithme répète ce processus jusqu’à ce qu’il trouve le trésor.</li>
            </ol>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple de Pseudo-code :</h4>
            <pre><code>
    recherche_binaire(liste, debut, fin, cible):
    Si debut > fin, retourner -1 (le trésor n'est pas dans la liste)
    
    milieu = (debut + fin) // 2
    
    Si liste[milieu] == cible, retourner milieu (le trésor est trouvé)
    
    Si liste[milieu] < cible:
        Rechercher dans la moitié supérieure (milieu + 1 à fin)
    Sinon:
        Rechercher dans la moitié inférieure (debut à milieu - 1)
            </code></pre>
        
            <p><strong>Cas de base :</strong> Si la liste est vide (début > fin), le trésor n’est pas dans la liste.</p>
            <p><strong>Cas récursif :</strong> À chaque étape, la liste est divisée en deux, et l’algorithme est rappelé sur la moitié pertinente (supérieure ou inférieure).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique dans le Contexte du Jeu Vidéo</h3>
            
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Créer la Liste des Sections</h4>
            <p>Tout d’abord, nous allons représenter l’île avec une liste de sections numérotées de 1 à 100 :</p>
            <pre><code>
    sections = list(range(1, 101))
            </code></pre>
            <p>Ensuite, nous allons choisir une section aléatoire pour cacher le trésor :</p>
            <pre><code>
    import random
    section_tresor = random.choice(sections)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Implémenter la Recherche Binaire</h4>
            <p>Nous allons maintenant implémenter l'algorithme de recherche binaire récursive pour chercher le trésor. À chaque étape, le programme indiquera si le trésor est dans la moitié supérieure ou inférieure :</p>
            <pre><code>
    def recherche_binaire(liste, debut, fin, cible):
        if debut > fin:
            print("Le trésor n'est pas sur cette île !")
            return -1
        
        milieu = (debut + fin) // 2
        print(f"Vous cherchez dans la section {milieu}...")
        
        if liste[milieu] == cible:
            print(f"Félicitations ! Vous avez trouvé le trésor dans la section {milieu} !")
            return milieu
        elif liste[milieu] < cible:
            print("Le trésor est dans une section plus haute.")
            return recherche_binaire(liste, milieu + 1, fin, cible)
        else:
            print("Le trésor est dans une section plus basse.")
            return recherche_binaire(liste, debut, milieu - 1, cible)
    
    # Appel de la fonction
    recherche_binaire(sections, 0, len(sections) - 1, section_tresor)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Extension et Challenge : Limite de Tentatives</h4>
            <p>Pour ajouter un défi supplémentaire, introduisez une limite de tentatives. Comme la recherche binaire divise la zone par deux à chaque étape, le nombre maximum de tentatives pour trouver le trésor dans une liste de 100 éléments est de 7 (car log2(100) ≈ 7).</p>
            <p>Modifiez l'algorithme pour limiter le nombre de tentatives à 7. Si le joueur dépasse ce nombre, il échoue à trouver le trésor.</p>
        
            <pre><code>
    def recherche_binaire(liste, debut, fin, cible, tentatives=7):
        if debut > fin or tentatives == 0:
            print("Le trésor n'a pas été trouvé, vous avez épuisé vos tentatives.")
            return -1
        
        milieu = (debut + fin) // 2
        print(f"Vous cherchez dans la section {milieu}... Tentatives restantes : {tentatives}")
        
        if liste[milieu] == cible:
            print(f"Félicitations ! Vous avez trouvé le trésor dans la section {milieu} !")
            return milieu
        elif liste[milieu] < cible:
            print("Le trésor est dans une section plus haute.")
            return recherche_binaire(liste, milieu + 1, fin, cible, tentatives - 1)
        else:
            print("Le trésor est dans une section plus basse.")
            return recherche_binaire(liste, debut, milieu - 1, cible, tentatives - 1)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Réflexion</h3>
            <p>À la fin de cette séance :</p>
            <ul>
                <li>Les élèves auront compris le concept de récursivité et comment elle peut être utilisée pour diviser un problème en sous-problèmes plus petits.</li>
                <li>Ils auront appris à implémenter un algorithme de recherche binaire pour améliorer l’efficacité de la recherche par rapport à une recherche linéaire.</li>
            </ul>
        
            <p><strong>Discussion sur la complexité temporelle :</strong> La recherche linéaire prend O(n) opérations, tandis que la recherche binaire prend O(log n) opérations, ce qui est bien plus rapide pour de grandes listes.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice complémentaire :</h4>
            <p>Comparer la recherche linéaire et la recherche binaire : Demander aux élèves d’implémenter une recherche linéaire et de compter combien de tentatives elle nécessite en moyenne pour trouver le trésor.</p>
        </section>

        <section id="session5" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 5 : Pratique – Recherche d’un Personnage de Manga avec un Algorithme de Recherche Binaire</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent utiliser l’algorithme de recherche binaire pour retrouver un personnage de manga dans une liste triée. Cela permettra de consolider les notions de recherche efficace et d’appliquer la récursivité dans un contexte concret.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte Manga :</h3>
            <p>Dans cette séance, vous allez simuler une recherche dans une base de données de personnages de manga. Imaginez une application où les utilisateurs peuvent rechercher un personnage de manga par son nom. Comme la base de données contient de nombreux personnages, une recherche linéaire serait inefficace. La solution ? Utiliser un algorithme de recherche binaire pour accélérer la recherche.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Introduction au Problème</h3>
            <p><strong>Problème :</strong> Vous avez une liste triée de personnages de manga et vous devez trouver un personnage spécifique rapidement. Plutôt que de chercher chaque nom un par un (recherche linéaire), vous allez utiliser un algorithme de recherche binaire pour optimiser le processus.</p>
            <ul>
                <li><strong>Recherche linéaire :</strong> Il faut potentiellement parcourir tous les éléments de la liste pour trouver le bon personnage. Si la liste contient 100 personnages, il pourrait falloir jusqu'à 100 comparaisons dans le pire des cas.</li>
                <li><strong>Recherche binaire :</strong> La liste est triée, donc à chaque étape, vous pouvez diviser la liste en deux, ce qui accélère la recherche de manière exponentielle.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Explication du Contexte et de la Recherche Binaire</h3>
            <p><strong>Contexte Manga :</strong> Imaginez une application de fans de manga où les utilisateurs peuvent rechercher des personnages. Chaque personnage a un nom, et la liste de personnages est déjà triée alphabétiquement.</p>
            <p><strong>Exemple :</strong> Voici une liste simplifiée de personnages de mangas (cette liste est triée) :</p>
        
            <pre><code>["Asta", "Edward", "Goku", "Luffy", "Naruto", "Sasuke", "Tanjiro", "Vegeta", "Zoro"]</code></pre>
        
            <p>Si vous cherchez "Luffy", au lieu de commencer à chercher depuis le début de la liste et d’aller un par un (recherche linéaire), vous pouvez commencer au milieu et diviser la recherche en deux.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Recherche Binaire : Principe et Explication</h3>
            <p>La recherche binaire consiste à diviser la liste en deux parties égales, à comparer l’élément du milieu avec le nom que vous cherchez, puis à continuer à diviser la moitié pertinente jusqu'à ce que vous trouviez l'élément, ou que vous déterminiez qu'il n'est pas dans la liste.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple Concret :</h4>
            <p>Si vous cherchez "Luffy", voici les étapes :</p>
            <ol>
                <li>La liste contient 9 personnages, l’élément du milieu est à la position 4 (index 4, c’est "Naruto").</li>
                <li>"Luffy" est plus petit que "Naruto" dans l’ordre alphabétique, donc on cherche dans la première moitié de la liste (éléments [0, 3]).</li>
                <li>Dans cette nouvelle sous-liste, l’élément du milieu est à la position 1 (index 1, c’est "Edward").</li>
                <li>"Luffy" est plus grand que "Edward", donc on cherche dans la moitié supérieure de cette sous-liste.</li>
                <li>On trouve "Luffy" à l’index 3.</li>
            </ol>
        
            <p>Conclusion : La recherche binaire a permis de trouver "Luffy" en seulement 3 comparaisons, au lieu de 5 comparaisons en recherche linéaire.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Explication Théorique de l'Algorithme</h4>
            <pre><code>
    recherche_binaire(liste, debut, fin, cible):
    Si debut > fin, retourner -1 (le personnage n'est pas dans la liste)
    
    milieu = (debut + fin) // 2
    
    Si liste[milieu] == cible, retourner milieu (personnage trouvé)
    
    Si liste[milieu] < cible:
        Rechercher dans la moitié supérieure (milieu + 1 à fin)
    Sinon:
        Rechercher dans la moitié inférieure (debut à milieu - 1)
            </code></pre>
        
            <p><strong>Cas de base :</strong> Si la sous-liste est vide (debut > fin), le personnage n'est pas dans la liste.</p>
            <p><strong>Cas récursif :</strong> La fonction appelle récursivement la recherche binaire sur la moitié supérieure ou inférieure selon la comparaison du personnage du milieu avec celui recherché.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique : Recherche Binaire sur une Liste de Personnages de Manga</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Créer la Liste des Personnages de Manga</h4>
            <p>On va d’abord créer une liste de personnages triée alphabétiquement.</p>
        
            <pre><code>
    personnages_manga = ["Asta", "Edward", "Goku", "Luffy", "Naruto", "Sasuke", "Tanjiro", "Vegeta", "Zoro"]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Implémenter la Recherche Binaire</h4>
            <p>On implémente l’algorithme de recherche binaire pour chercher un personnage dans cette liste. L’algorithme prend la liste de personnages, les indices de début et de fin, et le nom du personnage à chercher.</p>
        
            <pre><code>
    def recherche_binaire(liste, debut, fin, cible):
        if debut > fin:
            print(f"{cible} n'est pas dans la liste.")
            return -1
        
        milieu = (debut + fin) // 2
        print(f"Vérification du personnage au milieu : {liste[milieu]}")
    
        if liste[milieu] == cible:
            print(f"Félicitations ! {cible} a été trouvé à la position {milieu}.")
            return milieu
        elif liste[milieu] < cible:
            print(f"{cible} est après {liste[milieu]}. Recherche dans la moitié supérieure.")
            return recherche_binaire(liste, milieu + 1, fin, cible)
        else:
            print(f"{cible} est avant {liste[milieu]}. Recherche dans la moitié inférieure.")
            return recherche_binaire(liste, debut, milieu - 1, cible)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Recherche d’un Personnage</h4>
            <p>Invitez les élèves à tester cette fonction en recherchant des personnages comme Luffy, Naruto, ou d'autres dans la liste.</p>
        
            <pre><code>
    # Appel de la fonction de recherche
    recherche_binaire(personnages_manga, 0, len(personnages_manga) - 1, "Luffy")
            </code></pre>
        
            <p><strong>Exemple de sortie :</strong></p>
            <pre><code>
    Vérification du personnage au milieu : Naruto
    Luffy est avant Naruto. Recherche dans la moitié inférieure.
    Vérification du personnage au milieu : Edward
    Luffy est après Edward. Recherche dans la moitié supérieure.
    Vérification du personnage au milieu : Luffy
    Félicitations ! Luffy a été trouvé à la position 3.
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Extension : Limite de Tentatives</h3>
            <p>Ajoutez une fonctionnalité pour limiter le nombre de tentatives à un certain nombre, comme 4 tentatives, pour rendre l'exercice plus difficile et montrer comment l’algorithme optimise les recherches.</p>
        
            <pre><code>
    def recherche_binaire(liste, debut, fin, cible, tentatives):
        if debut > fin or tentatives == 0:
            print(f"{cible} n'a pas été trouvé ou les tentatives sont épuisées.")
            return -1
        
        milieu = (debut + fin) // 2
        print(f"Vérification du personnage au milieu : {liste[milieu]} - Tentatives restantes : {tentatives}")
    
        if liste[milieu] == cible:
            print(f"Félicitations ! {cible} a été trouvé à la position {milieu}.")
            return milieu
        elif liste[milieu] < cible:
            print(f"{cible} est après {liste[milieu]}. Recherche dans la moitié supérieure.")
            return recherche_binaire(liste, milieu + 1, fin, cible, tentatives - 1)
        else:
            print(f"{cible} est avant {liste[milieu]}. Recherche dans la moitié inférieure.")
            return recherche_binaire(liste, debut, milieu - 1, cible, tentatives - 1)
    
    # Lancer la recherche avec une limite de tentatives
    recherche_binaire(personnages_manga, 0, len(personnages_manga) - 1, "Luffy", tentatives=4)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Réflexion</h3>
            <ul>
                <li><strong>Discussion sur l’efficacité :</strong> Demandez aux élèves de comparer le nombre de tentatives nécessaires pour une recherche binaire par rapport à une recherche linéaire. Pour une liste de 9 éléments, la recherche binaire prend généralement 3 comparaisons, contre 9 dans le pire des cas pour une recherche linéaire.</li>
                <li><strong>Introduction à la complexité algorithmique :</strong> La recherche binaire a une complexité de O(log n), ce qui la rend beaucoup plus rapide que la recherche linéaire O(n) pour de grandes listes.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif de la Séance :</h3>
            <ul>
                <li>Utiliser l'algorithme de recherche binaire dans un contexte de liste de personnages de manga.</li>
                <li>Appliquer des concepts de récursivité pour diviser un problème complexe en sous-problèmes plus simples.</li>
                <li>Comparer les performances entre une recherche linéaire et une recherche binaire, notamment en termes de nombre de comparaisons.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exercice Complémentaire :</h3>
            <ul>
                <li>Implémenter une recherche linéaire et la comparer à la recherche binaire.</li>
                <li>Ajouter d’autres fonctionnalités à l’application, comme la possibilité de rechercher par d'autres attributs (ex : force, univers d’origine des personnages).</li>
            </ul>
        </section>

        <section id="session6" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 6 : Analyse de la Complexité d’un Algorithme de Recherche Récursive</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre comment analyser la complexité d’un algorithme récursif en termes de temps d’exécution. Ils découvriront la différence entre la complexité linéaire et la complexité logarithmique, et appliqueront ces concepts à un contexte de jeu vidéo.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte :</h3>
            <p>Dans un jeu vidéo, le joueur doit rechercher des objets cachés dans une carte divisée en sections. Vous avez déjà appris à implémenter des algorithmes de recherche récursive comme la recherche binaire. Maintenant, nous allons voir comment mesurer et analyser la complexité de cet algorithme, c’est-à-dire, combien de temps il prend en fonction du nombre de sections à explorer.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Introduction à la Notion de Complexité d’un Algorithme</h3>
            <p><strong>Qu’est-ce que la complexité d’un algorithme ?</strong></p>
            <p>La complexité d’un algorithme est une manière de mesurer combien de temps ou combien de ressources (comme la mémoire) un algorithme va utiliser en fonction de la taille du problème à résoudre. En général, la complexité est exprimée en termes de nombre d’opérations que l’algorithme doit effectuer, et elle est souvent notée à l’aide de la notation Big-O.</p>
            
            <p><strong>Big-O :</strong> Il s'agit d'une notation utilisée pour décrire comment le temps d’exécution ou l’utilisation de la mémoire d’un algorithme augmente lorsque la taille de l’entrée (comme le nombre de sections sur la carte) augmente.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemples de complexités communes :</h4>
            <ul>
                <li><strong>Complexité linéaire (O(n)) :</strong> Si l’algorithme doit effectuer une opération pour chaque élément de la liste, le temps d'exécution augmente en ligne droite avec la taille du problème. Exemple : Recherche linéaire.</li>
                <li><strong>Complexité logarithmique (O(log n)) :</strong> Si l’algorithme divise le problème en deux à chaque étape, le temps d'exécution augmente beaucoup plus lentement que la taille du problème. Exemple : Recherche binaire.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Pourquoi c'est important ?</h4>
            <ul>
                <li>Dans un jeu vidéo, si un algorithme est trop lent (complexité élevée), il pourrait ralentir le jeu.</li>
                <li>Un algorithme plus rapide permet de rechercher des objets ou des ennemis sur de grandes cartes sans affecter les performances du jeu.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Revue des Algorithmes de Recherche</h3>
            <p>Nous avons déjà implémenté deux algorithmes de recherche :</p>
            <ul>
                <li><strong>Recherche linéaire :</strong> Le joueur vérifie chaque section de la carte une à une jusqu’à trouver l’objet. Cet algorithme prend du temps, surtout si l’objet est dans la dernière section.</li>
                <li><strong>Recherche binaire :</strong> Le joueur divise la carte en deux à chaque étape, réduisant le nombre de sections à chercher. Cet algorithme est beaucoup plus rapide.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple Visuel :</h4>
            <p>Prenons l’exemple d’une carte divisée en 32 sections. Le joueur doit chercher un objet caché quelque part.</p>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">1. Recherche linéaire :</h5>
            <p>Si l'objet est dans la 32e section, il faudra vérifier 32 sections avant de trouver l'objet.</p>
            <p><strong>Nombre d’opérations =</strong> 32 (pour une carte de 32 sections).</p>
            <p><strong>Complexité :</strong> O(n) (linéaire).</p>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">2. Recherche binaire :</h5>
            <p>Avec cet algorithme, on divise par deux à chaque étape. Pour 32 sections, il ne faudra que 5 vérifications pour trouver l’objet.</p>
            <p><strong>Nombre d’opérations ≈</strong> log2(32) = 5 (car 2^5 = 32).</p>
            <p><strong>Complexité :</strong> O(log n) (logarithmique).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Analyse de la Recherche Linéaire</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Algorithme de recherche linéaire :</h4>
        
            <pre><code>
    def recherche_lineaire(liste, cible):
        for i in range(len(liste)):
            print(f"Vérification de la section {liste[i]}")
            if liste[i] == cible:
                print(f"Objet trouvé dans la section {liste[i]}")
                return i
        print("Objet non trouvé")
        return -1
    
    # Création d'une liste de sections
    sections = list(range(1, 33))  # Carte avec 32 sections
    
    # Appel de la fonction de recherche
    recherche_lineaire(sections, 32)
            </code></pre>
        
            <p><strong>Analyse :</strong></p>
            <p>Dans le pire des cas (l’objet est dans la dernière section), l’algorithme doit parcourir 32 sections.</p>
            <p>Le nombre d’opérations nécessaires est donc directement proportionnel au nombre de sections : O(n).</p>
            <p><strong>Question pour les élèves :</strong> Que se passe-t-il si on augmente le nombre de sections à 100 ? Combien d’opérations faudra-t-il faire ?</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Analyse de la Recherche Binaire</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Rappel de l'algorithme de recherche binaire :</h4>
        
            <pre><code>
    def recherche_binaire(liste, debut, fin, cible):
        if debut > fin:
            print("Objet non trouvé")
            return -1
        
        milieu = (debut + fin) // 2
        print(f"Vérification de la section {liste[milieu]}...")
        
        if liste[milieu] == cible:
            print(f"Objet trouvé dans la section {liste[milieu]}")
            return milieu
        elif liste[milieu] < cible:
            return recherche_binaire(liste, milieu + 1, fin, cible)
        else:
            return recherche_binaire(liste, debut, milieu - 1, cible)
    
    # Appel de la fonction de recherche binaire
    sections = list(range(1, 33))  # Carte avec 32 sections
    recherche_binaire(sections, 0, len(sections) - 1, 32)
            </code></pre>
        
            <p><strong>Analyse :</strong></p>
            <p>À chaque étape, l'algorithme divise la liste en deux. Cela signifie que le nombre d’opérations est proportionnel à log2(n).</p>
            <p>Pour 32 sections, il faut au maximum 5 vérifications (car 2^5 = 32).</p>
            <p><strong>Complexité :</strong> O(log n).</p>
            <p><strong>Question pour les élèves :</strong> Que se passe-t-il si la carte contient 100 sections ?</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">5. Conclusion et Discussion</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Discussion finale :</h4>
            <p>Les élèves doivent comprendre que la recherche binaire est bien plus rapide que la recherche linéaire, surtout lorsque le nombre de sections devient très grand.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Résumé des points clés :</h4>
            <ul>
                <li><strong>Recherche linéaire :</strong> Complexité O(n), ce qui signifie que le nombre d’opérations augmente linéairement avec la taille du problème.</li>
                <li><strong>Recherche binaire :</strong> Complexité O(log n), ce qui signifie que le nombre d’opérations augmente beaucoup plus lentement, même pour de grandes tailles de problèmes.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice de réflexion :</h4>
            <p>Demander aux élèves d’expliquer pourquoi un jeu vidéo qui utilise des cartes énormes aurait intérêt à utiliser des algorithmes comme la recherche binaire plutôt que la recherche linéaire.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Extension : Exercice complémentaire :</h4>
            <p><strong>Challenge :</strong> Demandez aux élèves d’ajouter un chronomètre dans le programme pour mesurer le temps réel que prend chaque algorithme pour trouver l’objet dans une liste de 1 000 sections. Ils devront comparer le temps d'exécution entre la recherche linéaire et la recherche binaire en utilisant la bibliothèque Python <code>time</code>.</p>
        
            <pre><code>
    import time

    # Chronométrer la recherche linéaire
    start_time = time.time()
    recherche_lineaire(sections, 32)
    print("Temps d'exécution de la recherche linéaire :", time.time() - start_time)
    
    # Chronométrer la recherche binaire
    start_time = time.time()
    recherche_binaire(sections, 0, len(sections) - 1, 32)
    print("Temps d'exécution de la recherche binaire :", time.time() - start_time)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif de la Séance :</h3>
            <p>À la fin de cette séance, les élèves auront appris à :</p>
            <ul>
                <li>Analyser la complexité d’un algorithme.</li>
                <li>Comprendre pourquoi certains algorithmes (comme la recherche binaire) sont beaucoup plus rapides que d'autres (recherche linéaire).</li>
                <li>Appliquer ces notions de complexité à des cas concrets, comme la recherche d’objets dans un jeu vidéo.</li>
            </ul>
        </section>

        <section id="session7" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 7 : Introduction au Backtracking (Concepts de Base)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre les concepts de base du backtracking et les implémenter dans un contexte pratique en lien avec un jeu vidéo. Le backtracking est un algorithme qui permet de résoudre des problèmes en explorant toutes les solutions possibles et en revenant en arrière si une solution ne fonctionne pas.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte du Jeu Vidéo :</h3>
            <p>Dans un jeu d'exploration, le joueur est perdu dans un labyrinthe complexe. Il doit trouver le chemin vers la sortie. Cependant, certains chemins sont bloqués ou mènent à des culs-de-sac. L’objectif est d’utiliser un algorithme de backtracking pour trouver la sortie en explorant le labyrinthe, tout en revenant en arrière lorsqu’un chemin ne fonctionne pas.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Introduction au Problème</h3>
            <p>Le joueur doit naviguer dans un labyrinthe (représenté par une grille 2D) et trouver la sortie. À chaque case, il peut se déplacer vers le haut, bas, gauche, ou droite, mais certains chemins sont bloqués (murs), et certains conduisent à des impasses.</p>
            <p><strong>Problème initial :</strong> Comment trouver le chemin optimal pour sortir du labyrinthe sans devoir essayer toutes les combinaisons possibles manuellement ?</p>
            <p><strong>Solution optimisée :</strong> Utiliser un algorithme de backtracking pour explorer tous les chemins possibles, tout en revenant en arrière (backtrack) lorsqu'on atteint un cul-de-sac ou un chemin bloqué.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Explication Théorique du Backtracking</h3>
            <p>Le backtracking est un algorithme récursif qui explore toutes les solutions possibles à un problème en essayant différentes options. Lorsqu’une option échoue, l'algorithme revient en arrière (backtrack) et essaie une autre option.</p>
            <p><strong>Étapes générales de l'algorithme de backtracking :</strong></p>
            <ul>
                <li>Commencer à partir d’un point de départ (ici, l’entrée du labyrinthe).</li>
                <li>Essayer une direction (haut, bas, gauche, droite).</li>
                <li>Vérifier si la direction est valide (pas de mur, pas de chemin déjà emprunté).</li>
                <li>Si la direction mène à la sortie, on a trouvé une solution.</li>
                <li>Si la direction ne mène nulle part (cul-de-sac), revenir en arrière et essayer une autre direction.</li>
                <li>Répéter jusqu’à trouver la sortie ou épuiser toutes les options.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple de Pseudo-code :</h4>
            <pre><code>
    trouver_sortie(labyrinthe, position_x, position_y):
    Si la position actuelle est la sortie :
        Afficher "Sortie trouvée"
        Finir l'algorithme
    
    Marquer la position actuelle comme visitée
    
    Pour chaque direction possible (haut, bas, gauche, droite) :
        Si la direction est valide et non visitée :
            Appeler récursivement trouver_sortie avec la nouvelle position
            Si cela conduit à la sortie, Finir
    
    Si aucune direction ne fonctionne, revenir en arrière (backtrack)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Implémentation du Backtracking dans un Labyrinthe</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Modélisation du Labyrinthe</h4>
            <p>Nous allons représenter le labyrinthe comme une grille 2D où chaque case peut être soit un mur (1), soit un chemin libre (0), soit l’entrée (S), soit la sortie (E).</p>
            <p><strong>Voici un exemple de labyrinthe :</strong></p>
            <pre><code>
    labyrinthe = [
        ['S', 1, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0]
    ]
            </code></pre>
            <ul>
                <li><strong>S :</strong> point de départ (entrée).</li>
                <li><strong>E :</strong> point d'arrivée (sortie).</li>
                <li><strong>1 :</strong> mur (chemin bloqué).</li>
                <li><strong>0 :</strong> chemin possible.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Implémenter l'Algorithme de Backtracking</h4>
            <pre><code>
    # Labyrinthe 2D
    labyrinthe = [
        ['S', 1, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0]
    ]
    
    # Fonction de backtracking pour explorer le labyrinthe
    def explorer_labyrinthe(labyrinthe, x, y, visitees):
        # Vérifier si la position est hors du labyrinthe
        if x < 0 or x >= len(labyrinthe) or y < 0 or y >= len(labyrinthe[0]):
            return False
        
        # Si la position est un mur ou déjà visitée
        if labyrinthe[x][y] == 1 or (x, y) in visitees:
            return False
        
        # Si on a trouvé la sortie
        if labyrinthe[x][y] == 'E':
            print(f"Sortie trouvée à la position ({x}, {y})")
            return True
        
        # Marquer la position comme visitée
        visitees.add((x, y))
        
        # Explorer les directions : bas, haut, droite, gauche
        if (explorer_labyrinthe(labyrinthe, x+1, y, visitees) or  # Bas
            explorer_labyrinthe(labyrinthe, x-1, y, visitees) or  # Haut
            explorer_labyrinthe(labyrinthe, x, y+1, visitees) or  # Droite
            explorer_labyrinthe(labyrinthe, x, y-1, visitees)):   # Gauche
            return True
        
        # Si aucune direction ne fonctionne, revenir en arrière
        visitees.remove((x, y))
        return False
    
    # Position de départ
    position_depart = (0, 0)
    
    # Ensemble des cases visitées
    cases_visitees = set()
    
    # Lancer la recherche de la sortie
    explorer_labyrinthe(labyrinthe, position_depart[0], position_depart[1], cases_visitees)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Explication de l'Algorithme</h3>
            <ol>
                <li><strong>Exploration des Chemins :</strong> L’algorithme commence à la position de départ (S). Il essaie de se déplacer dans les quatre directions possibles (bas, haut, gauche, droite) et appelle récursivement la fonction pour chaque nouvelle position.</li>
                <li><strong>Conditions de Validité :</strong> Si la position est en dehors des limites du labyrinthe, ou si la case est un mur (1), ou si elle a déjà été visitée, le programme ne continue pas dans cette direction.</li>
                <li><strong>Si la sortie est atteinte :</strong> Si l’algorithme arrive sur la case de la sortie (E), il arrête l’exploration et affiche un message.</li>
                <li><strong>Backtracking (Retour en arrière) :</strong> Si l’algorithme ne trouve pas de solution dans une direction, il revient en arrière (backtrack), annule son choix (retire la case visitée de la liste des cases visitées), et essaie une autre direction.</li>
            </ol>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Prolongements et Extensions</h3>
            <ul>
                <li><strong>Ajouter des éléments dans le labyrinthe :</strong> Les élèves peuvent ajouter des pièges ou des portes fermées qui nécessitent de trouver une clé pour progresser. Modification du labyrinthe pour le rendre plus grand ou plus complexe.</li>
                <li><strong>Limiter le nombre de déplacements :</strong> Proposer une version du jeu où le joueur a un nombre limité de mouvements pour sortir du labyrinthe, ou il échoue.</li>
                <li><strong>Ajouter un deuxième joueur :</strong> Introduire un mode compétition où deux joueurs doivent trouver la sortie, le premier qui trouve la sortie gagne. On peut utiliser le backtracking pour gérer l'IA du second joueur.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion</h3>
            <p>À la fin de cette séance :</p>
            <ul>
                <li>Les élèves auront appris ce qu’est le backtracking, comment il permet d’explorer toutes les solutions possibles à un problème, et pourquoi il est efficace pour les labyrinthes.</li>
                <li>Ils auront implémenté une solution complète pour trouver la sortie d’un labyrinthe en utilisant ce concept.</li>
            </ul>
            <p><strong>Discussion :</strong> Applications pratiques du backtracking dans d’autres problèmes informatiques (ex. : sudoku, puzzles, algorithmes de parcours de graphes, optimisation combinatoire).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exercices Complémentaires :</h3>
            <ul>
                <li><strong>Explorer un plus grand labyrinthe :</strong> Créer un labyrinthe aléatoire de taille 10x10 ou plus grand, et tester l’efficacité du backtracking.</li>
                <li><strong>Ajouter des contraintes :</strong> Imposer des chemins où certaines cases ne peuvent être empruntées qu'une seule fois.</li>
            </ul>
        </section>

        <section id="session8" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 8 : Pratique - Résolution d'un Labyrinthe avec Backtracking (Jeu Vidéo)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves vont apprendre à utiliser l’algorithme de backtracking pour résoudre un labyrinthe. Cet algorithme permet de trouver une sortie dans un environnement en revenant en arrière lorsque le chemin pris est bloqué.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte du Jeu Vidéo :</h3>
            <p>Dans ce jeu, un personnage est perdu dans un labyrinthe représenté sous la forme d'une grille. Le joueur doit trouver un chemin entre le point de départ S (Start) et le point d’arrivée E (End). Certains chemins sont bloqués par des murs, représentés par des 1, et seuls les chemins libres (0) peuvent être empruntés.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Introduction au Problème</h4>
            <p><strong>Expliquer le problème du labyrinthe :</strong></p>
            <p>Le personnage doit trouver la sortie d’un labyrinthe représenté par une grille où certains chemins sont bloqués par des murs.</p>
        
            <p><strong>Représentation du labyrinthe :</strong></p>
            <ul>
                <li>S représente le point de départ.</li>
                <li>E représente le point de sortie.</li>
                <li>1 représente un mur (infranchissable).</li>
                <li>0 représente un chemin libre.</li>
            </ul>
        
            <p><strong>Exemple de labyrinthe simple :</strong></p>
            <pre><code>
    labyrinthe = [    
        ['S', 1, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0]
    ]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">2. Qu'est-ce que le Backtracking ?</h4>
            <p>L’algorithme de backtracking est une méthode récursive qui essaie de trouver une solution à un problème en avançant étape par étape. Si un chemin s’avère incorrect, l’algorithme revient en arrière (backtrack) et essaie un autre chemin.</p>
        
            <p><strong>Explication du principe :</strong></p>
            <ul>
                <li>Le personnage commence au point de départ.</li>
                <li>Il explore les chemins dans toutes les directions (haut, bas, gauche, droite).</li>
                <li>Si le chemin mène à un mur ou à une impasse, il revient à la position précédente et essaie une autre direction.</li>
                <li>Ce processus continue jusqu’à ce qu’il trouve la sortie ou qu’il n’y ait plus de chemin possible.</li>
            </ul>
        
            <p><strong>Application au labyrinthe :</strong></p>
            <p>L'algorithme va explorer tous les chemins possibles et revenir en arrière si un chemin ne mène pas à la sortie. Cela permet de tester toutes les solutions possibles pour trouver celle qui fonctionne.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">3. Algorithme de Backtracking pour Résoudre le Labyrinthe</h4>
            <p>L'algorithme de backtracking est généralement implémenté de manière récursive. Voici un exemple d'algorithme en pseudo-code :</p>
        
            <pre><code>
    explorer_labyrinthe(labyrinthe, x, y, visitees):
    Si (x, y) est hors du labyrinthe ou un mur ou déjà visité :
        Retourner False
                
    Si (x, y) est la sortie :
        Retourner True (la sortie est trouvée)
    
    Marquer (x, y) comme visité
                
    Explorer les 4 directions (haut, bas, gauche, droite) :
        Si l’une des directions mène à la sortie :
            Retourner True
    
    Si aucune direction ne fonctionne :
        Retourner False (chemin bloqué)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">4. Implémentation en Python</h4>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Représenter le Labyrinthe</h5>
            <p>Le labyrinthe sera représenté par une matrice (liste de listes en Python). 0 représente un chemin ouvert, 1 représente un mur, S représente la position de départ, et E la sortie.</p>
        
            <pre><code>
    labyrinthe = [
        ['S', 1, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0]
    ]
            </code></pre>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Fonction de Backtracking</h5>
            <pre><code>
    def explorer_labyrinthe(labyrinthe, x, y, visitees):
        # Vérifier les limites du labyrinthe
        if x < 0 or x >= len(labyrinthe) or y < 0 or y >= len(labyrinthe[0]):
            return False
    
        # Vérifier si la case est un mur ou déjà visitée
        if labyrinthe[x][y] == 1 or (x, y) in visitees:
            return False
    
        # Si on a trouvé la sortie
        if labyrinthe[x][y] == 'E':
            print(f"Sortie trouvée à la position ({x}, {y})")
            return True
    
        # Marquer la case comme visitée
        visitees.add((x, y))
    
        # Appeler la fonction récursive dans les 4 directions
        if (explorer_labyrinthe(labyrinthe, x + 1, y, visitees) or  # Bas
            explorer_labyrinthe(labyrinthe, x - 1, y, visitees) or  # Haut
            explorer_labyrinthe(labyrinthe, x, y + 1, visitees) or  # Droite
            explorer_labyrinthe(labyrinthe, x, y - 1, visitees)):   # Gauche
            return True
    
        # Si aucune direction ne fonctionne, on retourne False (backtrack)
        return False
            </code></pre>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Tester l'Algorithme avec un Labyrinthe</h5>
            <pre><code>
    # Position de départ
    position_depart = (0, 0)
    
    # Ensemble des cases visitées
    cases_visitees = set()
    
    # Lancer la recherche de la sortie
    if not explorer_labyrinthe(labyrinthe, position_depart[0], position_depart[1], cases_visitees):
        print("Aucun chemin trouvé pour sortir du labyrinthe.")
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">5. Ajout d'une Interface Graphique Simple</h4>
            <p>Pour rendre l'algorithme plus interactif, nous allons ajouter une interface graphique simple avec Pygame pour visualiser le personnage se déplaçant dans le labyrinthe.</p>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Installer Pygame</h5>
            <p>Installer Pygame avec la commande :</p>
            <pre><code>
    pip install pygame
            </code></pre>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Visualisation du Labyrinthe</h5>
            <pre><code>
    import pygame

    # Dimensions de la fenêtre
    TAILLE_BLOC = 40
    LARGEUR = len(labyrinthe[0]) * TAILLE_BLOC
    HAUTEUR = len(labyrinthe) * TAILLE_BLOC
    
    # Couleurs
    COULEUR_MUR = (0, 0, 0)
    COULEUR_CHEMIN = (255, 255, 255)
    COULEUR_JOUEUR = (0, 255, 0)
    COULEUR_SORTIE = (255, 0, 0)
    
    # Initialiser Pygame
    pygame.init()
    fenetre = pygame.display.set_mode((LARGEUR, HAUTEUR))
    pygame.display.set_caption("Labyrinthe")
    
    def dessiner_labyrinthe(labyrinthe, position_joueur):
        fenetre.fill(COULEUR_CHEMIN)
        for i in range(len(labyrinthe)):
            for j in range(len(labyrinthe[0])):
                x = j * TAILLE_BLOC
                y = i * TAILLE_BLOC
                if labyrinthe[i][j] == 1:
                    pygame.draw.rect(fenetre, COULEUR_MUR, (x, y, TAILLE_BLOC, TAILLE_BLOC))
                elif labyrinthe[i][j] == 'E':
                    pygame.draw.rect(fenetre, COULEUR_SORTIE, (x, y, TAILLE_BLOC, TAILLE_BLOC))
        # Dessiner le joueur
        joueur_x, joueur_y = position_joueur
        pygame.draw.rect(fenetre, COULEUR_JOUEUR, (joueur_y * TAILLE_BLOC, joueur_x * TAILLE_BLOC, TAILLE_BLOC, TAILLE_BLOC))
    
    # Position initiale du joueur
    position_joueur = (0, 0)
    
    # Boucle du jeu
    continuer = True
    while continuer:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                continuer = False
    
        dessiner_labyrinthe(labyrinthe, position_joueur)
        pygame.display.flip()
    
    pygame.quit()
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">6. Challenge et Extension</h4>
            <ul>
                <li><strong>Challenge 1 :</strong> Limiter le nombre de déplacements - Limiter le nombre de mouvements que le joueur peut faire avant de trouver la sortie.</li>
                <li><strong>Challenge 2 :</strong> Génération aléatoire de labyrinthes - Modifier l’algorithme pour générer des labyrinthes aléatoires et les résoudre en utilisant le backtracking.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Réflexion</h3>
            <ul>
                <li>Les élèves auront appris à implémenter un algorithme de backtracking pour résoudre un labyrinthe de manière efficace.</li>
                <li>Ils auront vu comment appliquer cet algorithme à un jeu vidéo pour rendre la solution plus interactive.</li>
                <li>Discussion sur la récursivité et le backtracking : revenir en arrière dans l'exploration d'un problème permet de résoudre des situations complexes où plusieurs chemins sont possibles.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice Complémentaire :</h4>
            <p>Créer une intelligence artificielle pour explorer le labyrinthe automatiquement, ou modifier l’algorithme pour trouver tous les chemins possibles vers la sortie.</p>
        </section>

        <section id="session9" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 9 : Étude des Cas Où le Backtracking Est Utile et de Ses Limitations</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre le fonctionnement de l'algorithme de backtracking (retour en arrière), les cas où il est utile et ses limites en termes de complexité. Ils l'implémenteront dans le cadre d’un jeu vidéo où le joueur doit trouver un chemin dans un labyrinthe.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte :</h3>
            <p>Dans un jeu de labyrinthe, le joueur doit trouver une sortie à travers un labyrinthe complexe. L’algorithme de backtracking est utilisé pour explorer tous les chemins possibles jusqu’à ce que la sortie soit trouvée. Si un chemin mène à une impasse, l’algorithme revient en arrière (backtrack) et essaie un autre chemin.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Introduction au Problème du Labyrinthe</h4>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Scénario du Jeu Vidéo :</h4>
            <p>Le joueur se trouve à l'entrée d'un labyrinthe et doit trouver la sortie. Le labyrinthe est représenté sous forme de grille, où certaines cases sont des chemins possibles (0), et d'autres sont des murs (1). Le joueur peut se déplacer vers le haut, le bas, la gauche, ou la droite. Le but est de trouver un chemin de l'entrée à la sortie.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Structure du Labyrinthe :</h4>
            <pre><code>
    labyrinthe = [
        ['S', 0, 0, 1, 0],
        [1, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 1, 1, 1],
        [0, 0, 0, 0, 0]
    ]
            </code></pre>
            <ul>
                <li><strong>S</strong> représente le point de départ (Start).</li>
                <li><strong>E</strong> représente la sortie (End).</li>
                <li><strong>1</strong> représente un mur (impossible à traverser).</li>
                <li><strong>0</strong> représente un chemin possible.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Explication Théorique du Backtracking</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Concept du Backtracking :</h4>
            <p>Le backtracking est une technique algorithmique qui consiste à essayer toutes les solutions possibles jusqu’à ce que la bonne solution soit trouvée. Le principe est le suivant :</p>
            <ul>
                <li><strong>1. Choisir une option :</strong> On avance dans une direction (ou on prend une décision).</li>
                <li><strong>2. Tester la solution :</strong> Si cette direction (ou décision) mène à une impasse, on "revient en arrière" et on essaie une autre option.</li>
                <li><strong>3. Répéter :</strong> On continue ainsi jusqu’à ce que la solution soit trouvée ou qu'il n'y ait plus de possibilités à explorer.</li>
            </ul>
        
            <p>Dans le cas du labyrinthe :</p>
            <ul>
                <li>On commence à l’entrée du labyrinthe (<strong>S</strong>) et on essaie de se déplacer dans une direction (haut, bas, gauche, droite).</li>
                <li>Si le joueur rencontre un mur ou un chemin déjà exploré, il revient en arrière et essaie une autre direction.</li>
                <li>Le processus se répète jusqu'à ce que le joueur trouve la sortie (<strong>E</strong>).</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Pseudo-code du Backtracking :</h4>
            <pre><code>
    fonction résoudre_labyrinthe(labyrinthe, x, y):
    Si (x, y) est la sortie :
        Retourner vrai (le chemin est trouvé)
            
    Si (x, y) est un mur ou déjà visité :
        Retourner faux (impasse)
            
    Marquer (x, y) comme visité
            
    Tenter de se déplacer dans les 4 directions :
        Si résoudre_labyrinthe(labyrinthe, x + 1, y) retourne vrai :
            Retourner vrai (la direction est correcte)
        Si résoudre_labyrinthe(labyrinthe, x - 1, y) retourne vrai :
            Retourner vrai
        Si résoudre_labyrinthe(labyrinthe, x, y + 1) retourne vrai :
            Retourner vrai
        Si résoudre_labyrinthe(labyrinthe, x, y - 1) retourne vrai :
            Retourner vrai
            
    Si aucune direction ne mène à la sortie :
        Retourner en arrière (backtrack) et Retourner faux
            </code></pre>
        
            <p><strong>Idée Clé :</strong> Le backtracking consiste à tester chaque chemin possible et à revenir en arrière lorsqu'on atteint une impasse. Cela permet d'explorer tous les chemins possibles.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Mise en Pratique du Backtracking pour Résoudre un Labyrinthe</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Représenter le Labyrinthe en Python</h4>
            <p>Nous allons d’abord représenter notre labyrinthe sous forme de liste de listes (2D array), comme précédemment décrit. Chaque case contient soit un chemin possible (0), soit un mur (1), soit l’entrée (S) et la sortie (E).</p>
        
            <pre><code>
    labyrinthe = [
        ['S', 0, 0, 1, 0],
        [1, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 1, 1, 1],
        [0, 0, 0, 0, 0]
    ]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Implémenter l'Algorithme de Backtracking</h4>
            <p>L'algorithme va chercher le chemin à partir du point de départ (x, y) et essayer toutes les directions possibles (haut, bas, gauche, droite) jusqu’à ce qu’il atteigne la sortie (E).</p>
        
            <pre><code>
    # Fonction pour résoudre le labyrinthe
    def résoudre_labyrinthe(labyrinthe, x, y, visitees):
        # Vérifier si on est à la sortie
        if labyrinthe[x][y] == 'E':
            print(f"Sortie trouvée à la position ({x}, {y})")
            return True
                    
        # Vérifier les limites du labyrinthe
        if x < 0 or x >= len(labyrinthe) or y < 0 or y >= len(labyrinthe[0]):
            return False
                
        # Vérifier si la case est un mur ou déjà visitée
        if labyrinthe[x][y] == 1 or (x, y) in visitees:
            return False
                    
        # Marquer la case comme visitée
        visitees.add((x, y))
                
        # Appeler récursivement la fonction dans les 4 directions
        if (résoudre_labyrinthe(labyrinthe, x + 1, y, visitees) or  # Bas
            résoudre_labyrinthe(labyrinthe, x - 1, y, visitees) or  # Haut
            résoudre_labyrinthe(labyrinthe, x, y + 1, visitees) or  # Droite
            résoudre_labyrinthe(labyrinthe, x, y - 1, visitees)):   # Gauche
            return True
                    
        # Si aucune direction ne fonctionne, revenir en arrière
        return False
                
    # Initialisation
    visitees = set()  # Ensemble des cases déjà visitées
    résoudre_labyrinthe(labyrinthe, 0, 0, visitees)  # Commence à (0, 0)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Cas d'Utilisation du Backtracking</h3>
        
            <p><strong>Quand le Backtracking est-il utile ?</strong></p>
            <ul>
                <li><strong>1. Résolution de labyrinthes :</strong> comme dans notre exemple de jeu vidéo, où il y a plusieurs chemins possibles à explorer.</li>
                <li><strong>2. Jeux de puzzle :</strong> comme le Sudoku, où chaque choix possible doit être exploré avant de revenir en arrière si nécessaire.</li>
                <li><strong>3. Problèmes de recherche de combinaisons :</strong> trouver toutes les combinaisons possibles d’un ensemble (par exemple, dans un problème de sac à dos où plusieurs combinaisons doivent être explorées).</li>
                <li><strong>4. Coloration de graphes :</strong> assigner des couleurs à des nœuds d’un graphe tout en respectant certaines contraintes.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Limites du Backtracking :</h4>
            <ul>
                <li><strong>1. Complexité exponentielle :</strong> Le backtracking est souvent inefficace pour de très grands problèmes, car il peut nécessiter d'explorer un nombre exponentiel de solutions.</li>
                <li><strong>2. Exploration complète :</strong> Il n'y a pas de raccourci pour éviter d'explorer tous les chemins possibles, sauf si l’on combine le backtracking avec d'autres techniques comme la programmation dynamique ou l’élagage (pruning).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">5. Limites du Backtracking</h3>
        
            <p>Le backtracking peut devenir inefficace dans certaines situations, en particulier lorsque :</p>
            <ul>
                <li><strong>Trop de solutions possibles :</strong> Par exemple, dans un labyrinthe trop complexe avec de nombreuses impasses, le backtracking explorera chaque chemin, même s’il est inutile.</li>
                <li><strong>Complexité exponentielle :</strong> La recherche d'une solution peut prendre un temps très long lorsque le problème devient très grand, car le nombre de combinaisons possibles à tester augmente de façon exponentielle.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion</h3>
            <p>Les élèves auront appris :</p>
            <ul>
                <li>Comment utiliser le backtracking pour résoudre des problèmes tels que des labyrinthes dans des jeux vidéo.</li>
                <li>Pourquoi le backtracking est une méthode efficace pour explorer plusieurs solutions mais pourquoi il peut être limité pour les problèmes de grande envergure.</li>
                <li>Comprendre l'idée de retour en arrière : explorer, tester, revenir en arrière en cas d'impasse, et continuer à chercher jusqu’à la solution.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercices Complémentaires :</h4>
            <ul>
                <li><strong>Amélioration du labyrinthe :</strong> Ajouter plus d’éléments au labyrinthe (ennemis, objets à collecter, etc.).</li>
                <li><strong>Élagage (pruning) :</strong> Modifier l'algorithme pour éviter certains chemins déjà identifiés comme inutiles.</li>
            </ul>
        </section>

        <section id="session10" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 10 : Introduction à la Complexité Algorithmique – Notation Big-O</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <ul>
                <li>Comprendre le concept de complexité algorithmique.</li>
                <li>Apprendre à utiliser la notation Big-O.</li>
                <li>Appliquer la notation Big-O dans des situations concrètes à travers des exemples de jeux vidéo.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Contexte et Introduction</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Le Problème :</h4>
            <p>Dans le contexte d'un jeu vidéo, imaginons que le joueur doit interagir avec un certain nombre d’éléments à l’écran (monstres, objets, personnages). Ces éléments sont stockés dans une liste ou un tableau, et le joueur doit effectuer des actions comme :</p>
            <ul>
                <li>Trouver un monstre spécifique pour l’attaquer.</li>
                <li>Ramasser un objet spécifique.</li>
                <li>Parcourir tous les éléments pour effectuer une action (comme infliger des dégâts à tous les monstres).</li>
            </ul>
            <p>Pour rendre ces actions efficaces, il est crucial de comprendre combien de temps ou combien d'opérations l'algorithme prend pour effectuer la tâche, en fonction du nombre d’éléments. C'est là que la complexité algorithmique intervient.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Qu’est-ce que la Complexité Algorithmique ?</h4>
            <p>La complexité algorithmique mesure l'efficacité d'un algorithme en fonction de la taille de l'entrée (nombre d'éléments à traiter).</p>
            <p>Plutôt que de mesurer le temps en secondes, on mesure le nombre d’opérations que l’algorithme doit effectuer pour résoudre le problème.</p>
            <p><strong>Exemple simple :</strong> Si vous devez chercher un objet spécifique dans une liste, combien de comparaisons l'algorithme devra-t-il faire en fonction de la longueur de la liste ?</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Notation Big-O : Mesurer l’Efficacité des Algorithmes</h3>
            <p>La notation Big-O permet de classer les algorithmes selon le nombre d’opérations qu’ils effectuent en fonction de la taille de l’entrée (souvent notée n).</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Définitions des Complexités :</h4>
            <ul>
                <li><strong>O(1) : Complexité constante</strong> - L’algorithme prend le même temps, quel que soit le nombre d’éléments.
                    <br>Exemple : Accéder directement à un élément dans un tableau (par index), comme dans une liste de potions dans un inventaire.
                </li>
                <li><strong>O(n) : Complexité linéaire</strong> - Le nombre d’opérations augmente proportionnellement au nombre d’éléments.
                    <br>Exemple : Parcourir une liste d'objets pour trouver un objet spécifique dans un inventaire (recherche linéaire).
                </li>
                <li><strong>O(log n) : Complexité logarithmique</strong> - Le nombre d’opérations croît logarithmiquement avec le nombre d'éléments.
                    <br>Exemple : Recherche binaire dans une liste triée d’objets.
                </li>
                <li><strong>O(n²) : Complexité quadratique</strong> - Le nombre d'opérations est proportionnel au carré du nombre d'éléments.
                    <br>Exemple : Comparer chaque monstre à chaque autre monstre dans un jeu de combat (algorithme de tri par sélection).
                </li>
                <li><strong>O(n log n) : Complexité linéaro-logarithmique</strong> - Utilisée pour des algorithmes de tri efficaces comme le tri rapide (Quicksort).
                </li>
                <li><strong>O(2ⁿ) : Complexité exponentielle</strong> - Le nombre d'opérations double à chaque ajout d'élément. Très inefficace.
                    <br>Exemple : Problèmes avec des combinaisons ou la génération d'arbres de décisions très profonds.
                </li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Exemples Concrets avec des Jeux Vidéo</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple 1 : Recherche dans un Inventaire de Jeu Vidéo</h4>
            <p>Imaginons que le joueur possède un inventaire avec n objets (potions, épées, boucliers). Il doit trouver une potion spécifique.</p>
            <ul>
                <li><strong>O(n)</strong> (recherche linéaire) : Le joueur doit parcourir tous les objets de l’inventaire un par un, en comparant chaque objet avec la potion recherchée.</li>
                <li>Si l’inventaire contient 100 objets, il faudra au pire 100 opérations pour trouver la potion (ou ne pas la trouver).</li>
            </ul>
            <p><strong>Exercice pratique :</strong> Implémenter une recherche linéaire sur une liste d’objets de jeu.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple 2 : Attaque de Tous les Monstres</h4>
            <p>Dans un jeu de type RPG, le joueur a la capacité d'attaquer tous les monstres présents sur le terrain en une seule action. Si chaque attaque prend une unité de temps, le nombre d'opérations sera proportionnel au nombre de monstres.</p>
            <ul>
                <li><strong>O(n)</strong> : S’il y a 50 monstres sur le terrain, il faudra 50 attaques, soit 50 opérations.</li>
            </ul>
            <p><strong>Exercice pratique :</strong> Implémenter une boucle qui applique une attaque à chaque monstre dans une liste de 50 monstres.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple 3 : Recherche Binaire pour Trouver un Objet dans un Inventaire Trié</h4>
            <p>Dans un inventaire trié d’un jeu, le joueur peut utiliser la recherche binaire pour trouver un objet plus rapidement.</p>
            <ul>
                <li><strong>O(log n)</strong> : Si l’inventaire contient 100 objets, la recherche binaire permet de trouver un objet en 7 étapes au lieu de 100.</li>
                <li>Chaque étape divise la liste en deux, ce qui fait que l’algorithme est logarithmique.</li>
            </ul>
            <p><strong>Exercice pratique :</strong> Implémenter une recherche binaire dans une liste triée d'objets (similaire à la recherche du trésor vue en séance précédente).</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple 4 : Comparer Chaque Monstre avec Chaque Autre Monstre (Algorithme Quadratique)</h4>
            <p>Dans certains jeux, vous pourriez avoir un système où chaque monstre doit interagir avec tous les autres (par exemple, vérifier les collisions entre eux).</p>
            <ul>
                <li><strong>O(n²)</strong> : Si vous avez 10 monstres, vous devez comparer chaque monstre avec les 9 autres, soit 100 comparaisons.</li>
                <li>Si vous avez 100 monstres, cela fera 10 000 comparaisons (un algorithme quadratique).</li>
            </ul>
            <p><strong>Exercice pratique :</strong> Implémenter un algorithme de comparaison entre chaque paire de monstres dans un jeu.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Expérimentation et Simulation avec des Listes de Données</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Implémenter des Algorithmes Différents</h4>
            <p>Les élèves vont créer une liste d'objets de jeu (par exemple, 100 objets avec des noms aléatoires).</p>
            <ul>
                <li><strong>Exercice 1 :</strong> Recherche linéaire : Implémenter une recherche d’un objet spécifique dans cette liste.</li>
                <li><strong>Exercice 2 :</strong> Recherche binaire : Si la liste est triée, utiliser la recherche binaire pour trouver l’objet plus rapidement.</li>
                <li><strong>Exercice 3 :</strong> Comparaison de tous les éléments : Simuler un combat où chaque monstre est comparé avec tous les autres.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Mesurer et Comparer la Performance</h4>
            <p>Pour chaque exercice, les élèves devront :</p>
            <ul>
                <li>Mesurer le nombre d’opérations nécessaires.</li>
                <li>Comparer la performance des algorithmes en fonction de la taille de la liste (par exemple, en augmentant la taille de la liste de 100 à 1000).</li>
            </ul>
            <p><strong>Exercice pratique :</strong> Afficher le temps pris par chaque algorithme pour trouver un objet dans une liste d’objets. Demander aux élèves d’expliquer pourquoi certains algorithmes sont plus rapides que d'autres pour de grandes listes.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">5. Discussion sur la Notion de Limite et d’Optimisation</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">La Limite des Algorithmes Inefficaces :</h4>
            <p>Discuter avec les élèves sur le fait qu’un algorithme linéaire (<strong>O(n)</strong>) peut être acceptable pour un petit nombre d’éléments, mais qu'il devient trop lent pour un grand nombre.</p>
            <p>Par exemple, rechercher un objet dans une liste de 100 éléments avec <strong>O(n)</strong> peut être acceptable, mais dans une liste de 1 000 000 d’éléments, il faut optimiser avec un algorithme plus rapide (comme <strong>O(log n)</strong> ou <strong>O(1)</strong>).</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Optimiser dans les Jeux Vidéo :</h4>
            <p>Dans les jeux vidéo, optimiser les algorithmes est crucial pour maintenir la performance, surtout si le jeu implique des centaines d'ennemis, des interactions complexes, et des actions en temps réel.</p>
            <p>Par exemple, pour un jeu où des dizaines de monstres doivent être gérés, il est important d’utiliser des algorithmes efficaces pour éviter les ralentissements.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">6. Conclusion et Résumé</h3>
            <p><strong>Ce que les élèves ont appris :</strong></p>
            <ul>
                <li><strong>Complexité algorithmique :</strong> Comprendre comment mesurer l’efficacité d’un algorithme en fonction du nombre d’opérations qu’il effectue.</li>
                <li><strong>Notation Big-O :</strong> Apprendre à classer les algorithmes en fonction de leur performance.</li>
                <li><strong>Exemples concrets :</strong> Les élèves ont appliqué la notion de complexité algorithmique à des cas pratiques dans des jeux vidéo.</li>
                <li><strong>Comparaison des algorithmes :</strong> Voir comment différents algorithmes (<strong>O(n)</strong>, <strong>O(log n)</strong>, <strong>O(n²)</strong>) fonctionnent dans des situations réelles et pourquoi certains sont plus efficaces.</li>
            </ul>
        
            <p><strong>Exercices Complémentaires :</strong></p>
            <ul>
                <li>Étendre l’exercice sur <strong>O(n log n)</strong> : Implémenter un algorithme de tri rapide (Quicksort) et comparer ses performances avec un tri basique (tri par sélection <strong>O(n²)</strong>).</li>
                <li>Tester des algorithmes sur de très grandes listes : Demander aux élèves de simuler des listes contenant des millions d’éléments et de comparer la rapidité des algorithmes.</li>
            </ul>
        </section>

        <section id="session11" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 11 : Pratique - Comparaison des Algorithmes de Tri Simples (Insertion, Sélection)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront à implémenter et comparer les algorithmes de tri par insertion et par sélection, en utilisant une approche pratique. Ces concepts seront appliqués dans le contexte d'un jeu vidéo où il faut organiser les objets de l'inventaire d'un personnage pour optimiser le gameplay.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte du Jeu Vidéo :</h3>
            <p>Dans un jeu d’aventure, le joueur collecte de nombreux objets (armes, potions, armures) pendant son exploration. Ces objets sont initialement mélangés dans son inventaire. Le joueur doit organiser son inventaire, par exemple en triant les objets selon leur valeur ou leur poids.</p>
            <p>Problème initial : Le joueur a besoin d’un inventaire trié pour accéder rapidement à ses objets les plus précieux ou les plus utiles. Si l’inventaire est désorganisé, cela peut nuire à l’efficacité du jeu.</p>
            <p>Solution : Utiliser des algorithmes de tri pour organiser l'inventaire.</p>
            <p>Les élèves vont comparer deux algorithmes de tri simples :</p>
            <ol>
                <li>Tri par insertion (Insertion Sort).</li>
                <li>Tri par sélection (Selection Sort).</li>
            </ol>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Introduction aux Algorithmes de Tri</h3>
            <p>Avant de plonger dans la pratique, il est important de comprendre les deux algorithmes de tri et leurs mécanismes.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Tri par Insertion :</h4>
            <p>Le tri par insertion fonctionne comme si vous triiez une main de cartes :</p>
            <ul>
                <li>Vous prenez les cartes (ici des objets de l’inventaire) une par une et les insérez au bon endroit dans une liste déjà triée.</li>
                <li>À chaque itération, la portion triée de la liste s’agrandit.</li>
            </ul>
            <p><strong>Principe :</strong> On compare l’élément actuel avec les éléments précédents et on l’insère à la bonne position pour que la partie gauche de la liste soit triée.</p>
        
            <pre><code>
    def tri_insertion(liste):
        for i in range(1, len(liste)):
            element = liste[i]
            j = i - 1
            while j >= 0 and liste[j] > element:
                liste[j + 1] = liste[j]
                j -= 1
            liste[j + 1] = element
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Tri par Sélection :</h4>
            <p>Le tri par sélection fonctionne en trouvant l'élément le plus petit et en le plaçant au début de la liste. Ensuite, on cherche le deuxième plus petit, et ainsi de suite.</p>
            <p><strong>Principe :</strong> On sélectionne l'élément le plus petit dans la partie non triée de la liste, puis on le place au début. On répète le processus jusqu'à ce que la liste soit entièrement triée.</p>
        
            <pre><code>
    def tri_selection(liste):
        for i in range(len(liste)):
            min_index = i
            for j in range(i + 1, len(liste)):
                if liste[j] < liste[min_index]:
                    min_index = j
            liste[i], liste[min_index] = liste[min_index], liste[i]
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Application dans le Contexte du Jeu Vidéo</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Préparation de l’Inventaire</h4>
            <p>L’inventaire du personnage est représenté par une liste d’objets, chaque objet ayant une valeur et un poids. Pour simplifier, les élèves peuvent utiliser une liste de nombres représentant les valeurs des objets.</p>
            <pre><code>
    inventaire = [50, 10, 40, 30, 20, 60]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Implémentation du Tri par Insertion</h4>
            <p>Les élèves commenceront par implémenter le tri par insertion pour organiser les objets de l’inventaire en fonction de leur valeur.</p>
            <ul>
                <li>Rappeler le principe : Le joueur veut trier ses objets du moins précieux au plus précieux pour les retrouver facilement.</li>
                <li>Exercice pratique : Écrire la fonction <code>tri_insertion</code> pour trier l’inventaire.</li>
            </ul>
        
            <pre><code>
    def tri_insertion(liste):
        for i in range(1, len(liste)):
            element = liste[i]
            j = i - 1
            while j >= 0 and liste[j] > element:
                liste[j + 1] = liste[j]
                j -= 1
            liste[j + 1] = element
                
    # Exemple d'utilisation
    inventaire = [50, 10, 40, 30, 20, 60]
    print("Inventaire avant tri :", inventaire)
    tri_insertion(inventaire)
    print("Inventaire après tri par insertion :", inventaire)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Implémentation du Tri par Sélection</h4>
            <p>Les élèves passent ensuite à l'implémentation du tri par sélection pour organiser l’inventaire de manière alternative.</p>
            <ul>
                <li>Rappeler le principe : On cherche l'objet le moins précieux et on le place au début de l’inventaire, puis on répète le processus.</li>
                <li>Exercice pratique : Écrire la fonction <code>tri_selection</code>.</li>
            </ul>
        
            <pre><code>
    def tri_selection(liste):
        for i in range(len(liste)):
            min_index = i
            for j in range(i + 1, len(liste)):
                if liste[j] < liste[min_index]:
                    min_index = j
            liste[i], liste[min_index] = liste[min_index], liste[i]
                
    # Exemple d'utilisation
    inventaire = [50, 10, 40, 30, 20, 60]
    print("Inventaire avant tri :", inventaire)
    tri_selection(inventaire)
    print("Inventaire après tri par sélection :", inventaire)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Comparaison des Algorithmes</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 4 : Comparaison sur la Base des Performances</h4>
            <p>Demander aux élèves de comparer les deux algorithmes de tri en termes de :</p>
            <ul>
                <li>Vitesse (nombre de comparaisons) : Combien de comparaisons sont faites dans chaque algorithme ?</li>
                <li>Tri par insertion : Bon pour des listes presque triées.</li>
                <li>Tri par sélection : Meilleur pour des listes complètement désordonnées.</li>
                <li>Simplicité d’implémentation : Lequel est plus simple à comprendre et à écrire ?</li>
                <li>Complexité temporelle :
                    <ul>
                        <li><strong>Insertion sort :</strong> O(n^2) dans le pire des cas.</li>
                        <li><strong>Selection sort :</strong> O(n^2) dans tous les cas.</li>
                    </ul>
                </li>
            </ul>
            <p>Demander aux élèves d’essayer ces algorithmes sur différentes tailles de listes (par exemple, 10, 100, 1000 éléments) et de mesurer le temps que chaque algorithme prend pour terminer le tri. Voici un code simple pour chronométrer :</p>
        
            <pre><code>
    import time
        
    # Exemple pour le tri par insertion
    start_time = time.time()
    tri_insertion(inventaire)
    end_time = time.time()
    print("Temps pris par le tri par insertion :", end_time - start_time)
                
    # Faire de même pour le tri par sélection
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Extension et Discussion</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 5 : Extension - Trier par Poids</h4>
            <p>Ajouter une nouvelle caractéristique aux objets de l’inventaire : le poids. Demander aux élèves de modifier leur code pour trier les objets non plus par valeur, mais par poids.</p>
        
            <pre><code>
    inventaire_avec_poids = [
        {"nom": "épée", "valeur": 50, "poids": 5},
        {"nom": "potion", "valeur": 10, "poids": 1},
        {"nom": "armure", "valeur": 40, "poids": 15},
        {"nom": "bouclier", "valeur": 30, "poids": 8},
        {"nom": "arc", "valeur": 20, "poids": 3},
        {"nom": "flèches", "valeur": 60, "poids": 0.5}
    ]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 6 : Discussion Finale</h4>
            <ul>
                <li><strong>Avantages et inconvénients de chaque algorithme :</strong></li>
                <li>Le tri par insertion est plus rapide pour les petites listes ou les listes presque triées.</li>
                <li>Le tri par sélection est simple à comprendre, mais peu efficace pour les grandes listes.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Objectif Atteint</h3>
            <ul>
                <li>Implémenter les algorithmes de tri par insertion et tri par sélection.</li>
                <li>Comparer leurs performances sur des listes de différentes tailles.</li>
                <li>Appliquer ces concepts à un contexte ludique avec l’organisation d’un inventaire dans un jeu vidéo.</li>
                <li>Comprendre les forces et faiblesses de chaque méthode de tri.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice Complémentaire :</h4>
            <p>Tri d'une liste de dictionnaires : Demander aux élèves de trier une liste de dictionnaires (objets du jeu) non seulement par valeur ou poids, mais aussi par d’autres critères comme la rareté.</p>
        </section>

        <section id="session12" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 12 : Exercices d’Analyse de la Complexité des Algorithmes dans des Jeux Vidéo et la Vie Réelle</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre et analyser la complexité temporelle des algorithmes à travers des exemples concrets tirés de jeux vidéo et de la vie réelle. Ils apprendront à évaluer l’efficacité d’un algorithme en fonction de la taille des données sur lesquelles il opère et à utiliser la notation Big-O.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction à la Complexité Algorithmique</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Qu’est-ce que la Complexité Algorithmique ?</h4>
            <p>Lorsqu’on écrit un programme ou un algorithme, il est important de se demander "combien de temps prend l’algorithme pour s'exécuter" en fonction de la taille des données à traiter.</p>
            <p>La complexité algorithmique est une manière de mesurer et comparer l’efficacité de différents algorithmes en fonction du nombre d’opérations qu’ils effectuent.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">2. La Notation Big-O</h4>
            <p>La notation Big-O est une manière de représenter la croissance du temps d’exécution d’un algorithme en fonction de la taille des données (n).</p>
            <p><strong>Quelques exemples courants :</strong></p>
            <ul>
                <li><strong>O(1)</strong> : Temps constant. L'algorithme prend toujours le même temps, quelle que soit la taille des données.</li>
                <li><strong>O(n)</strong> : Temps linéaire. Le temps de l'algorithme augmente proportionnellement à la taille des données.</li>
                <li><strong>O(log n)</strong> : Temps logarithmique. Le temps de l'algorithme augmente lentement à mesure que les données augmentent.</li>
                <li><strong>O(n²)</strong> : Temps quadratique. Le temps augmente rapidement à mesure que la taille des données augmente (ex. : tri par sélection).</li>
                <li><strong>O(2ⁿ)</strong> : Temps exponentiel. Très inefficace pour de grandes quantités de données.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">3. Exemple de la Recherche dans un Jeu Vidéo</h4>
            <p>Dans un jeu vidéo de type open-world (monde ouvert), imaginons que le joueur cherche un objet caché. L’algorithme peut utiliser différents types de recherche pour aider le joueur à trouver cet objet.</p>
            <ul>
                <li><strong>Recherche linéaire (O(n)) :</strong> Si le joueur explore toutes les sections de la carte une par une, cela prendra du temps proportionnel à la taille de la carte. Si la carte contient 100 sections, il devra en moyenne en parcourir 50 avant de trouver l'objet.</li>
                <li><strong>Recherche binaire (O(log n)) :</strong> Si l'algorithme divise la carte en deux parties à chaque étape (comme vu lors de la recherche binaire), la recherche sera bien plus rapide. Pour 100 sections, il suffit de 7 étapes pour trouver l’objet.</li>
                <li><strong>Recherche dans un graphe (DFS/BFS) (O(n)) :</strong> Si le jeu est un labyrinthe ou un réseau complexe de chemins, les algorithmes de parcours de graphes peuvent être utilisés pour trouver l'objet.</li>
            </ul>
        
            <pre><code>
    # Pseudo-code pour la recherche linéaire :
    def recherche_lineaire(liste, cible):
        for i in range(len(liste)):
            if liste[i] == cible:
                return i
        return -1
                
    # Recherche binaire (comme vu dans une séance précédente) :
    def recherche_binaire(liste, debut, fin, cible):
        if debut > fin:
            return -1
        milieu = (debut + fin) // 2
        if liste[milieu] == cible:
            return milieu
        elif liste[milieu] < cible:
            return recherche_binaire(liste, milieu + 1, fin, cible)
        else:
            return recherche_binaire(liste, debut, milieu - 1, cible)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exercice Pratique 1 : Comparaison des Algorithmes de Recherche</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Scénario dans le Jeu Vidéo :</h4>
            <p>Dans un monde ouvert, un monstre doit suivre le joueur. Le monstre doit déterminer où se trouve le joueur sur une carte divisée en sections numérotées de 1 à 1000.</p>
            <ul>
                <li>Recherche linéaire : Le monstre vérifie chaque section une par une.</li>
                <li>Recherche binaire : Le monstre divise la carte en deux à chaque étape.</li>
            </ul>
            <p><strong>Objectif :</strong> Implémenter les deux algorithmes et comparer le nombre d’étapes nécessaires pour que le monstre trouve le joueur.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étapes :</h4>
            <ol>
                <li>Implémenter la recherche linéaire et la recherche binaire.</li>
                <li>Effectuer des tests avec différentes tailles de carte (ex. : 100, 500, 1000 sections).</li>
                <li>Comparer le nombre d'étapes nécessaires pour trouver le joueur à chaque fois.</li>
            </ol>
        
            <pre><code>
    # Code pour la Recherche Linéaire et Binaire :
    import random
                
    # Simulation d'une carte avec 1000 sections
    sections = list(range(1, 1001))
    # Le joueur se trouve dans une section aléatoire
    joueur = random.choice(sections)
                
    # Recherche linéaire
    def recherche_lineaire(liste, cible):
        etapes = 0
        for i in range(len(liste)):
            etapes += 1
            if liste[i] == cible:
                return i, etapes
        return -1, etapes
                
    # Recherche binaire
    def recherche_binaire(liste, debut, fin, cible, etapes=0):
        if debut > fin:
            return -1, etapes
        milieu = (debut + fin) // 2
        etapes += 1
        if liste[milieu] == cible:
            return milieu, etapes
        elif liste[milieu] < cible:
            return recherche_binaire(liste, milieu + 1, fin, cible, etapes)
        else:
            return recherche_binaire(liste, debut, milieu - 1, cible, etapes)
                
    # Comparaison des algorithmes
    lin_result, lin_etapes = recherche_lineaire(sections, joueur)
    bin_result, bin_etapes = recherche_binaire(sections, 0, len(sections) - 1, joueur)
                
    print(f"Recherche linéaire : trouvé en {lin_etapes} étapes")
    print(f"Recherche binaire : trouvé en {bin_etapes} étapes")
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Analyse des Résultats :</h3>
            <ul>
                <li><strong>Recherche linéaire :</strong> Plus la carte est grande, plus le monstre doit effectuer d'étapes pour trouver le joueur. La recherche linéaire est donc proportionnelle à la taille de la carte.</li>
                <li><strong>Recherche binaire :</strong> Le nombre d'étapes est beaucoup plus faible, car l'algorithme divise la carte en deux à chaque étape.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exercice Pratique 2 : Algorithmes de Tri dans les Jeux Vidéo</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Scénario dans le Jeu Vidéo :</h4>
            <p>Dans un inventaire de jeu vidéo, les objets doivent être triés par valeur ou par poids. L'algorithme de tri utilisé impacte la vitesse avec laquelle le joueur peut afficher son inventaire trié.</p>
            <ul>
                <li><strong>Tri par sélection (O(n²)) :</strong> Un tri basique mais lent.</li>
                <li><strong>Tri rapide (Quicksort, O(n log n)) :</strong> Un tri plus rapide utilisé dans les systèmes de gestion d'inventaire modernes.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Implémenter le Tri par Sélection</h4>
            <pre><code>
    def tri_selection(liste):
        n = len(liste)
        for i in range(n):
            min_idx = i
            for j in range(i+1, n):
                if liste[j] < liste[min_idx]:
                    min_idx = j
            liste[i], liste[min_idx] = liste[min_idx], liste[i]
        return liste
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Implémenter le Tri Rapide (Quicksort)</h4>
            <pre><code>
    def tri_rapide(liste):
        if len(liste) <= 1:
            return liste
        pivot = liste[0]
        inferieur = [x for x in liste[1:] if x <= pivot]
        superieur = [x for x in liste[1:] if x > pivot]
        return tri_rapide(inferieur) + [pivot] + tri_rapide(superieur)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Comparer les Deux Algorithmes de Tri</h4>
            <p>Les élèves doivent comparer les performances des deux algorithmes sur des listes d’inventaires de tailles différentes (10, 100, 1000 objets). Ils analyseront combien de temps chaque tri prend pour s'exécuter.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Discussion et Conclusion</h3>
            <p><strong>Complexité des Algorithmes :</strong> Pourquoi certains algorithmes sont-ils plus lents que d'autres ?</p>
            <p><strong>Big-O et l’importance de la taille des données :</strong> Discuter de la manière dont la taille des données influe sur les performances d'un algorithme.</p>
            <p><strong>Jeux Vidéo et Algorithmes :</strong> Comment des concepts théoriques comme la complexité algorithmique impactent directement des expériences de jeu.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Extensions possibles :</h4>
            <ul>
                <li>Analyser la complexité spatiale (mémoire utilisée) en plus de la complexité temporelle.</li>
                <li>Étudier d'autres algorithmes utilisés dans les jeux vidéo, comme les algorithmes d'IA pour le comportement des ennemis ou la génération procédurale de niveaux.</li>
            </ul>
        </section>

        <section id="session13" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 13 : Introduction aux Graphes et à leurs Applications</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre la notion de graphe en informatique, comment il est représenté et ses différentes applications pratiques, y compris dans le domaine des jeux vidéo. Ils apprendront les concepts de sommets, arêtes, parcours, et utiliseront des graphes pour résoudre des problèmes concrets, comme la navigation dans un jeu vidéo.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Graphes</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Qu’est-ce qu’un graphe ?</h4>
            <p>Un graphe est une structure de données composée :</p>
            <ul>
                <li><strong>De sommets (ou nœuds) :</strong> ce sont les points d’un graphe, souvent utilisés pour représenter des objets, des lieux, ou des états.</li>
                <li><strong>D’arêtes (ou arcs) :</strong> ce sont les lignes qui relient les sommets entre eux, représentant des relations ou des chemins entre ces objets.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Applications des graphes :</h4>
            <ul>
                <li><strong>Jeux vidéo :</strong> Représentation de mondes ou cartes de jeu (les sommets représentent les lieux, les arêtes représentent les chemins entre eux).</li>
                <li><strong>Réseaux sociaux :</strong> Chaque utilisateur est un sommet, et les relations entre eux (amis) sont des arêtes.</li>
                <li><strong>Navigation GPS :</strong> Les intersections (sommets) sont reliées par des routes (arêtes) pour trouver le chemin optimal.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Représentation d’un Graphe :</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Représentation par une matrice d’adjacence :</h4>
            <p>Une matrice carrée où les lignes et colonnes représentent les sommets. Si deux sommets sont connectés, la case correspondante contient une valeur (1 pour les non pondérés, un poids pour les pondérés).</p>
        
            <pre><code>
      |  A  |  B  |  C  |
       ------------------
    A |  0  |  1  |  0  |
    B |  1  |  0  |  1  |
    C |  0  |  1  |  0  |
            </code></pre>
            <p>Ici, A et B sont connectés, et B et C sont connectés.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">2. Représentation par liste d’adjacence :</h4>
            <p>Chaque sommet a une liste de sommets voisins. Cette représentation est plus économe en mémoire pour les graphes peu denses.</p>
        
            <pre><code>
    graphe = {
        'A': ['B'],
        'B': ['A', 'C'],
        'C': ['B']
    }
            </code></pre>
            <p>A est connecté à B, et B est connecté à C.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exemple Ludique : Utilisation des Graphes dans un Jeu Vidéo</h3>
            <p>Dans un jeu vidéo, vous êtes un personnage qui doit se déplacer d'un point A à un point B à travers un réseau de chemins connectant différents lieux. Le monde du jeu peut être représenté sous forme de graphe où :</p>
            <ul>
                <li><strong>Les sommets</strong> représentent des lieux (villes, salles dans un donjon, etc.).</li>
                <li><strong>Les arêtes</strong> représentent des chemins (routes, portes entre les salles, etc.).</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple de Graphe dans le Jeu :</h4>
            <pre><code>
    A ----- B ----- C
    |       |       |
    D ----- E ----- F
            </code></pre>
            <p>Chaque lettre représente une pièce (un sommet). Chaque trait représente un chemin entre deux pièces (une arête).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Types de Graphes</h3>
            <ul>
                <li><strong>Graphe non orienté :</strong> Les arêtes n'ont pas de direction. On peut aller dans les deux sens entre deux sommets.</li>
                <li><strong>Graphe orienté :</strong> Les arêtes ont une direction. On ne peut aller que dans un sens d’un sommet à un autre.</li>
                <li><strong>Graphe pondéré :</strong> Chaque arête a un poids (un coût), qui peut représenter la distance, le temps ou le coût énergétique pour se déplacer d’un sommet à un autre.</li>
                <li><strong>Graphe connexe :</strong> Il est possible d’atteindre n’importe quel sommet à partir de n’importe quel autre sommet.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique : Représentation d'un Monde de Jeu Vidéo avec un Graphe</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Créer un Graphe Représentant un Monde de Jeu</h4>
            <pre><code>
    graphe_donjon = {
        'A': ['B', 'D'],
        'B': ['A', 'C', 'E'],
        'C': ['B', 'F'],
        'D': ['A', 'E'],
        'E': ['B', 'D', 'F'],
        'F': ['C', 'E']
    }
            </code></pre>
            <p>Ici, chaque clé représente une pièce, et les valeurs sont les pièces connectées par une porte.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Représenter le Monde et les Connexions</h4>
            <p>Visualisez ce graphe dans le contexte d’un jeu :</p>
            <ul>
                <li><strong>Les sommets :</strong> Chaque lettre (A, B, C, etc.) représente une salle du donjon.</li>
                <li><strong>Les arêtes :</strong> Les portes qui relient les salles entre elles.</li>
            </ul>
            <p>Demandez aux élèves de dessiner ce graphe sur papier ou sur un tableau pour mieux le visualiser.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Définir des Chemins dans le Graphe</h4>
            <p>Le joueur commence dans la salle A et veut se rendre dans la salle F. L’objectif est de parcourir le graphe et de trouver un chemin du point A au point F en suivant les arêtes du graphe.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Parcours de Graphe : Introduction à la Recherche de Chemin</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Parcours en largeur (BFS - Breadth First Search) :</h4>
            <p>Utilisé pour trouver le plus court chemin dans un graphe non pondéré. Il explore tous les voisins d’un sommet avant de passer à la couche suivante.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">2. Parcours en profondeur (DFS - Depth First Search) :</h4>
            <p>Utile pour explorer toutes les branches d’un graphe. Il explore aussi loin que possible dans une branche avant de revenir en arrière.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique : Parcours en Largeur (BFS)</h3>
            <pre><code>
    from collections import deque
        
    def bfs(graphe, depart, objectif):
        file_attente = deque([depart])
        visites = set()
        
        while file_attente:
            sommet = file_attente.popleft()
            if sommet == objectif:
                print(f"Vous avez trouvé le chemin vers {objectif} depuis {depart} !")
                return
            if sommet not in visites:
                print(f"Vous explorez la pièce {sommet}")
                visites.add(sommet)
                file_attente.extend(graphe[sommet])
        print(f"Pas de chemin trouvé de {depart} à {objectif}.")
    
    # Appel de la fonction
    bfs(graphe_donjon, 'A', 'F')
            </code></pre>
            <p>Ce programme parcourt le donjon en utilisant une approche BFS (parcours en largeur) pour explorer les pièces adjacentes et trouver le chemin de la pièce A à la pièce F.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Application et Conclusion</h3>
            <p>Réflexion sur les Applications des Graphes :</p>
            <ul>
                <li><strong>Jeux vidéo :</strong> Les graphes sont utiles pour gérer les déplacements des personnages, que ce soit pour les joueurs ou pour les ennemis.</li>
                <li><strong>Navigation :</strong> Les GPS utilisent des graphes pondérés pour calculer les meilleurs itinéraires entre deux lieux.</li>
                <li><strong>Réseaux sociaux :</strong> Les graphes sont utilisés pour représenter les connexions entre utilisateurs (sommets) et leurs relations (arêtes).</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Challenge Supplémentaire (pour les élèves avancés) :</h4>
            <p>Ajoutez des poids aux arêtes pour représenter le coût (distance, énergie) du déplacement entre les salles, puis utilisez l’algorithme de Dijkstra pour trouver le chemin le plus court entre deux salles.</p>
            <p>Amélioration du jeu : Implémentez une fonction qui permet au joueur de trouver automatiquement le chemin le plus court pour s’échapper du donjon en évitant certains pièges.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectifs de la Séance :</h3>
            <ul>
                <li>Comprendre les concepts de base des graphes (sommets, arêtes, connexions).</li>
                <li>Savoir représenter un monde de jeu vidéo sous forme de graphe.</li>
                <li>Utiliser un algorithme de parcours de graphe pour résoudre un problème de navigation dans un jeu.</li>
                <li>Bonus : Introduction à l’application des graphes dans des domaines plus vastes (réseaux sociaux, GPS).</li>
            </ul>
        </section>

        <section id="session14" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 14 : Pratique - Représentation d'un Réseau de Routes dans un Jeu Vidéo avec des Graphes</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif de la Séance :</h3>
            <p>Les élèves vont apprendre à modéliser un réseau de routes dans un jeu vidéo en utilisant des graphes. Ils vont comprendre comment utiliser un graphe pour représenter des routes entre différentes villes et comment ces structures peuvent être utilisées pour trouver les chemins les plus courts dans un jeu vidéo de type simulation de transport.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte du Jeu Vidéo</h3>
            <p>Imaginez un jeu de simulation où le joueur doit gérer le réseau de transport d’un royaume. Le royaume est constitué de plusieurs villes reliées entre elles par des routes. Chaque ville est un nœud (ou sommet) du réseau, et chaque route entre deux villes est une arête (ou arc) dans le graphe.</p>
            <p><strong>Objectif du joueur :</strong> Le joueur doit transporter des marchandises d'une ville à l'autre en optimisant le trajet pour gagner du temps et des ressources. Il devra donc utiliser un algorithme de parcours de graphe pour trouver le chemin le plus court entre deux villes.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Graphes</h3>
            <p><strong>Qu’est-ce qu’un Graphe ?</strong></p>
            <p>Un graphe est une structure mathématique utilisée pour modéliser des relations entre des objets. Il est composé de :</p>
            <ul>
                <li><strong>Nœuds (ou sommets)</strong> : Ici, chaque nœud représente une ville.</li>
                <li><strong>Arêtes (ou arcs)</strong> : Ce sont les routes qui relient les villes entre elles.</li>
            </ul>
            <p><strong>Types de graphes :</strong></p>
            <ul>
                <li><strong>Graphes non orientés :</strong> Les arêtes n'ont pas de direction, comme une route bidirectionnelle entre deux villes.</li>
                <li><strong>Graphes orientés :</strong> Les arêtes ont une direction, comme une autoroute à sens unique entre deux villes.</li>
            </ul>
            <p>Dans notre exemple de jeu vidéo, nous utiliserons un graphe non orienté pour modéliser les routes, où chaque route est bidirectionnelle.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Représentation d’un Graphe en Python</h3>
            <p>Il existe plusieurs manières de représenter un graphe dans un programme :</p>
            <ul>
                <li><strong>Matrice d’adjacence :</strong> Une matrice où chaque élément (i, j) est 1 si une route existe entre les villes i et j, sinon 0.</li>
                <li><strong>Liste d’adjacence :</strong> Un dictionnaire où chaque ville est associée à une liste de villes adjacentes reliées par une route.</li>
            </ul>
            <p>Pour cette séance, nous allons utiliser une liste d’adjacence car elle est plus intuitive et plus efficace pour représenter des graphes avec peu de connexions.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 1 : Créer le Réseau de Routes avec une Liste d’Adjacence</h3>
            <p><strong>Exemple :</strong></p>
            <p>Supposons que nous avons cinq villes dans le royaume : A, B, C, D, et E. Les routes sont les suivantes :</p>
            <ul>
                <li>Route entre A et B.</li>
                <li>Route entre A et C.</li>
                <li>Route entre B et D.</li>
                <li>Route entre C et D.</li>
                <li>Route entre D et E.</li>
            </ul>
            <pre><code>
    # Représentation du réseau de routes avec une liste d'adjacence
    routes = {
        'A': ['B', 'C'],
        'B': ['A', 'D'],
        'C': ['A', 'D'],
        'D': ['B', 'C', 'E'],
        'E': ['D']
    }
            </code></pre>
            <p><strong>Explication :</strong></p>
            <ul>
                <li>La ville A est reliée aux villes B et C.</li>
                <li>La ville B est reliée aux villes A et D, etc.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 2 : Parcourir le Graphe – Algorithme DFS et BFS</h3>
            <p><strong>Pourquoi parcourir un graphe ?</strong></p>
            <p>Dans un jeu vidéo, le joueur peut vouloir savoir le chemin le plus court entre deux villes ou simplement vérifier si une ville est atteignable depuis une autre. Pour cela, on utilise des algorithmes de parcours de graphe, comme DFS (Depth First Search) ou BFS (Breadth First Search).</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Implémentation de DFS :</h4>
            <pre><code>
    # Fonction DFS pour parcourir le graphe
    def dfs(graphe, ville, visitees):
        print(f"Visite de {ville}")
        visitees.add(ville)  # Marquer la ville comme visitée
        
        # Explorer les voisins
        for voisin in graphe[ville]:
            if voisin not in visitees:
                dfs(graphe, voisin, visitees)
    
    # Appel de DFS à partir de la ville A
    visitees = set()
    dfs(routes, 'A', visitees)
            </code></pre>
            <p><strong>Explication de DFS :</strong></p>
            <ul>
                <li><strong>Départ :</strong> On commence par la ville A, puis on visite tous les voisins de A qui n’ont pas encore été visités (ici B et C).</li>
                <li><strong>Récursivité :</strong> L’algorithme appelle récursivement DFS sur chaque voisin jusqu’à ce que toutes les villes connectées soient visitées.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Implémentation de BFS :</h4>
            <pre><code>
    from collections import deque

    # Fonction BFS pour parcourir le graphe
    def bfs(graphe, ville_depart):
        file = deque([ville_depart])
        visitees = set([ville_depart])
        
        while file:
            ville = file.popleft()
            print(f"Visite de {ville}")
            
            # Parcourir les voisins
            for voisin in graphe[ville]:
                if voisin not in visitees:
                    file.append(voisin)
                    visitees.add(voisin)
    
    # Appel de BFS à partir de la ville A
    bfs(routes, 'A')
            </code></pre>
            <p><strong>Explication de BFS :</strong></p>
            <ul>
                <li>On commence par visiter la ville A, puis on ajoute ses voisins dans une file (ou file d’attente) pour les visiter à leur tour.</li>
                <li>Le parcours se fait par niveaux : on visite d’abord les voisins immédiats (ici B et C), puis les voisins des voisins.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 3 : Application au Jeu Vidéo – Trouver le Chemin le Plus Court</h3>
            <p><strong>Objectif :</strong></p>
            <p>Dans le jeu, le joueur doit transporter des marchandises entre deux villes et doit trouver le chemin le plus court. Pour cela, nous allons utiliser BFS car il est bien adapté pour trouver les chemins les plus courts dans les graphes non pondérés.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Ajout de la Fonction de Recherche du Chemin le Plus Court :</h4>
            <pre><code>
    def bfs_chemin_court(graphe, ville_depart, ville_arrivee):
        file = deque([[ville_depart]])  # File qui contient les chemins explorés
        visitees = set([ville_depart])
                    
        while file:
            chemin = file.popleft()
            ville = chemin[-1]
            
            # Si on arrive à la ville cible, on renvoie le chemin emprunté
            if ville == ville_arrivee:
                return chemin
            
            # Parcourir les voisins
            for voisin in graphe[ville]:
                if voisin not in visitees:
                    nouveau_chemin = list(chemin)  # Copier le chemin actuel
                    nouveau_chemin.append(voisin)  # Ajouter le voisin au chemin
                    file.append(nouveau_chemin)
                    visitees.add(voisin)
        
        return None  # Retourner None si aucun chemin n'est trouvé
    
    # Trouver le chemin le plus court entre A et E
    chemin = bfs_chemin_court(routes, 'A', 'E')
    print(f"Le chemin le plus court est : {chemin}")
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 4 : Extensions et Améliorations</h3>
            <ul>
                <li><strong>Pondération des routes :</strong> Ajouter des poids aux routes (distance ou temps de trajet) pour utiliser des algorithmes plus avancés comme Dijkstra pour trouver le chemin le plus court dans un graphe pondéré.</li>
                <li><strong>Modéliser plus de villes :</strong> Ajouter davantage de villes et routes dans le réseau de transport.</li>
                <li><strong>Gestion des trajets multiples :</strong> Permettre au joueur de planifier plusieurs trajets entre différentes villes.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion</h3>
            <ul>
                <li>Modéliser un réseau de routes avec un graphe en utilisant une liste d’adjacence.</li>
                <li>Implémenter des algorithmes de parcours (DFS et BFS) pour explorer un réseau de villes.</li>
                <li>Utiliser BFS pour trouver le chemin le plus court dans un graphe non pondéré, et comprendre comment cela s'applique aux jeux vidéo.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice Complémentaire :</h4>
            <p>Si certains élèves avancent plus rapidement, ils peuvent travailler sur un réseau de routes plus complexe et implémenter un algorithme plus avancé comme Dijkstra pour trouver le chemin le plus rapide en fonction du temps de trajet sur chaque route.</p>
        </section>

        <section id="session15" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 15 : Algorithmes de Parcours de Graphes – DFS et BFS</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre et implémenter deux algorithmes fondamentaux de parcours de graphes : DFS (Depth-First Search) et BFS (Breadth-First Search). Ils apprendront à les utiliser dans le cadre d’un jeu vidéo où un personnage doit explorer un réseau de niveaux ou un labyrinthe.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Graphes et Parcours</h3>
            <h4>Le Contexte du Jeu Vidéo :</h4>
            <p>Dans un jeu vidéo d’aventure, un personnage doit naviguer à travers un labyrinthe ou un réseau de niveaux pour atteindre la sortie ou accomplir une mission. Chaque niveau est représenté comme un graphe, où :</p>
            <ul>
                <li>Chaque nœud du graphe représente une salle ou un point d’intérêt dans le labyrinthe.</li>
                <li>Chaque arête entre deux nœuds représente un chemin que le personnage peut emprunter.</li>
            </ul>
            <p>Le joueur doit explorer le labyrinthe pour trouver la sortie ou un trésor. Pour rendre cette exploration efficace, nous allons utiliser deux algorithmes de parcours de graphes : DFS (parcours en profondeur) et BFS (parcours en largeur).</p>
        
            <h4>Définition de Base d’un Graphe :</h4>
            <ul>
                <li><strong>Nœuds (ou sommets) :</strong> chaque nœud représente un point, comme une salle dans un labyrinthe ou un niveau dans un jeu.</li>
                <li><strong>Arêtes :</strong> les connexions entre les nœuds, qui représentent des chemins.</li>
            </ul>
            <p>Dans notre jeu, nous pouvons modéliser un labyrinthe ou un réseau de niveaux sous forme de graphe.</p>
        
            <h4>Exemple Visuel :</h4>
            <pre><code>
    1 --- 2 --- 3
    |     |     |
    4 --- 5 --- 6
            </code></pre>
            <p>Chaque numéro (1, 2, 3, etc.) représente une salle du labyrinthe.</p>
            <p>Chaque trait (--- ou |) représente un chemin que le personnage peut emprunter pour aller d'une salle à l'autre.</p>
            <p>Nous allons voir comment le personnage peut explorer ce labyrinthe en utilisant les algorithmes DFS et BFS pour parcourir le graphe.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Algorithme DFS (Depth-First Search) – Parcours en Profondeur</h3>
            <h4>1. Principe de DFS :</h4>
            <p>Le parcours en profondeur consiste à explorer le plus loin possible dans une direction avant de revenir en arrière. Cela signifie que l’algorithme suit un chemin jusqu’à ce qu’il n’y ait plus d’arêtes à suivre, puis il revient en arrière pour explorer d’autres chemins.</p>
        
            <p>DFS fonctionne de manière récursive, en suivant un chemin jusqu’à atteindre un nœud sans issue (feuille), puis en revenant pour explorer les autres chemins.</p>
        
            <h4>Exemple Visuel avec DFS :</h4>
            <p>Dans notre labyrinthe ci-dessus, un parcours DFS à partir du nœud 1 pourrait suivre cette séquence : 1 → 2 → 3 → 6 → 5 → 4 (exploration la plus profonde possible avant de revenir).</p>
        
            <h4>Pseudo-code de DFS :</h4>
            <pre><code>
    def dfs(graphe, noeud, visites):
        if noeud not in visites:
            print(f"Visite du nœud {noeud}")
            visites.add(noeud)  # Marquer le nœud comme visité
            for voisin dans graphe[noeud]:  # Explorer tous les voisins non visités
                dfs(graphe, voisin, visites)
            </code></pre>
        
            <h4>Explication Étape par Étape :</h4>
            <ul>
                <li><strong>Initialisation :</strong> On commence au premier nœud (par exemple, la salle de départ).</li>
                <li><strong>Exploration :</strong> On explore un des voisins non visités, puis on continue à explorer les voisins des voisins.</li>
                <li><strong>Retour en arrière :</strong> Si un nœud n’a plus de voisins non visités, on revient en arrière pour explorer les autres chemins.</li>
            </ul>
        
            <h4>Implémentation DFS dans le Contexte du Jeu (Exemple en Python) :</h4>
            <pre><code>
    graphe = {
        1: [2, 4],
        2: [1, 3, 5],
        3: [2, 6],
        4: [1, 5],
        5: [2, 4, 6],
        6: [3, 5]
    }
    
    def dfs(graphe, noeud, visites):
        if noeud not in visites:
            print(f"Visite de la salle {noeud}")
            visites.add(noeud)
            for voisin dans graphe[noeud]:
                dfs(graphe, voisin, visites)
    
    # Initialiser un ensemble de nœuds visités
    visites = set()
    
    # Lancer le parcours DFS à partir de la salle 1
    dfs(graphe, 1, visites)
            </code></pre>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez le graphe pour que certaines salles contiennent des trésors.</li>
                <li><strong>Étape 2 :</strong> Implémentez un DFS pour que le joueur explore toutes les salles et affiche si un trésor est trouvé dans une salle.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Algorithme BFS (Breadth-First Search) – Parcours en Largeur</h3>
            <h4>1. Principe de BFS :</h4>
            <p>Le parcours en largeur consiste à explorer tous les voisins d’un nœud avant de passer aux voisins des voisins.</p>
            <p>BFS fonctionne en utilisant une file d’attente (queue) pour gérer les nœuds à explorer. À chaque étape, on explore tous les nœuds voisins du nœud actuel avant de passer aux nœuds de niveau supérieur.</p>
        
            <h4>Exemple Visuel avec BFS :</h4>
            <p>Dans le labyrinthe, un parcours BFS à partir du nœud 1 pourrait suivre cette séquence : 1 → 2 → 4 → 3 → 5 → 6 (exploration niveau par niveau).</p>
        
            <h4>Pseudo-code de BFS :</h4>
            <pre><code>
    from collections import deque

    def bfs(graphe, noeud):
        visites = set()  # Ensemble des nœuds visités
        queue = deque([noeud])  # File d'attente pour gérer les nœuds à explorer
        
        while queue:
            courant = queue.popleft()  # Récupérer le nœud à explorer
            if courant not in visites:
                print(f"Visite du nœud {courant}")
                visites.add(courant)  # Marquer comme visité
                for voisin dans graphe[courant]:
                    if voisin not in visites:
                        queue.append(voisin)  # Ajouter les voisins à la file d'attente
            </code></pre>
        
            <h4>Explication Étape par Étape :</h4>
            <ul>
                <li><strong>Initialisation :</strong> On commence au premier nœud (la salle de départ).</li>
                <li><strong>Exploration des voisins :</strong> On explore tous les voisins directs du nœud actuel.</li>
                <li><strong>Nœuds de niveau supérieur :</strong> Une fois les voisins directs explorés, on passe aux voisins des voisins, et ainsi de suite, jusqu’à ce que tous les nœuds soient visités.</li>
            </ul>
        
            <h4>Implémentation BFS dans le Contexte du Jeu (Exemple en Python) :</h4>
            <pre><code>
    from collections import deque
        
    graphe = {
        1: [2, 4],
        2: [1, 3, 5],
        3: [2, 6],
        4: [1, 5],
        5: [2, 4, 6],
        6: [3, 5]
    }
                
    def bfs(graphe, noeud):
        visites = set()  # Ensemble des nœuds visités
        queue = deque([noeud])  # File d'attente
        
        while queue:
            courant = queue.popleft()
            if courant not in visites:
                print(f"Visite de la salle {courant}")
                visites.add(courant)
                for voisin dans graphe[courant]:
                    if voisin not in visites:
                        queue.append(voisin)
    
    # Lancer le parcours BFS à partir de la salle 1
    bfs(graphe, 1)
            </code></pre>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Implémentez un système où le personnage doit explorer toutes les salles du labyrinthe à l'aide du parcours en largeur.</li>
                <li><strong>Étape 2 :</strong> Ajoutez un obstacle dans certaines salles et modifiez le BFS pour que le personnage ignore les salles avec des obstacles.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Comparaison des Algorithmes</h3>
        
            <h4>Comparaison DFS vs BFS :</h4>
            <ul>
                <li><strong>DFS (Depth-First Search) :</strong> L'algorithme explore profondément dans un chemin avant de revenir en arrière. Il est utile pour explorer des labyrinthes où l’on veut atteindre des chemins très éloignés. DFS utilise souvent la récursivité.</li>
                <li><strong>BFS (Breadth-First Search) :</strong> L'algorithme explore tous les voisins directs avant de passer aux nœuds suivants. Il est très efficace pour trouver le chemin le plus court dans un graphe. BFS utilise une file d’attente.</li>
            </ul>
        
            <h4>Complexité Temporelle :</h4>
            <p>Les deux algorithmes ont une complexité en temps de <code>O(V + E)</code>, où <code>V</code> est le nombre de nœuds (salles) et <code>E</code> est le nombre d’arêtes (chemins).</p>
        
            <h4>Discussion :</h4>
            <ul>
                <li>DFS est particulièrement utile pour les problèmes de parcours de labyrinthe où il est important d’explorer un chemin complet avant de revenir en arrière.</li>
                <li>BFS est idéal pour trouver des chemins plus courts ou explorer des environnements "niveau par niveau", comme dans un jeu où l’on veut explorer toutes les salles d'un étage avant de monter à l'étage supérieur.</li>
            </ul>
        </section>

        <section id="session16" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 16 : Approfondissement sur l’algorithme DFS (Depth-First Search)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves approfondiront leur compréhension de l’algorithme DFS (Depth-First Search) en explorant ses différentes applications, en particulier dans les graphes, dans un contexte de jeu vidéo où le joueur doit explorer un réseau complexe de salles interconnectées. L'objectif est de renforcer leur capacité à appliquer la récursivité dans la recherche en profondeur.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction à DFS dans un Contexte de Jeu Vidéo</h3>
        
            <h4>Contexte du Jeu Vidéo :</h4>
            <p>Imaginons un jeu d’aventure où le joueur incarne un explorateur qui doit naviguer à travers un réseau complexe de grottes interconnectées. Chaque grotte est une salle, et chaque connexion entre deux salles représente un chemin possible. L’objectif est de visiter toutes les grottes pour trouver un artefact caché. L’algorithme DFS est un moyen efficace pour parcourir toutes les salles en suivant un chemin en profondeur avant de revenir en arrière.</p>
        
            <h4>Concept de DFS :</h4>
            <p>DFS (Depth-First Search) est un algorithme qui explore un graphe en allant aussi loin que possible dans une direction avant de revenir en arrière pour explorer les autres chemins. C’est un algorithme récursif qui suit une stratégie de <strong>diviser pour régner</strong>, en explorant un chemin complet jusqu’à ce qu’il ne puisse plus avancer.</p>
        
            <h4>Représentation en Graphe :</h4>
            <p>Dans ce jeu vidéo, chaque salle est un nœud du graphe, et chaque connexion entre deux salles est une arête. Voici un exemple de graphe représentant un réseau de grottes :</p>
        
            <pre><code>
    1 --- 2 --- 3
    |     |     |
    4 --- 5 --- 6
            </code></pre>
        
            <p>Dans cet exemple, le joueur commence à la salle 1 et doit visiter toutes les autres salles en utilisant l’algorithme DFS pour explorer les salles dans un ordre efficace.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Explication de l’Algorithme DFS (30 min)</h3>
            <h4>1. Fonctionnement de DFS :</h4>
            <p>DFS utilise une approche récursive pour explorer les nœuds d’un graphe :</p>
            <ul>
                <li>On commence par un nœud initial (par exemple, la salle de départ).</li>
                <li>On explore un des voisins de ce nœud.</li>
                <li>À chaque fois qu’un nœud est visité, on le marque comme visité pour éviter de le revisiter.</li>
                <li>Si tous les voisins d’un nœud sont visités, l’algorithme revient en arrière et explore les autres chemins restants.</li>
            </ul>
        
            <h4>2. Récursivité dans DFS :</h4>
            <p>DFS est naturellement récursif. Chaque appel de fonction DFS explore un chemin jusqu’à ce qu’il n’y ait plus de voisins à visiter. L'algorithme revient ensuite à la fonction appelante pour explorer d’autres chemins.</p>
        
            <p>Le pseudo-code de DFS est le suivant :</p>
            <pre><code>
    def dfs(graphe, noeud, visites):
        if noeud not in visites:
            print(f"Visite de la salle {noeud}")
            visites.add(noeud)  # Marquer la salle comme visitée
            for voisin dans graphe[noeud]:  # Explorer les voisins non visités
                dfs(graphe, voisin, visites)
            </code></pre>
        
            <h4>3. Exemple Visuel :</h4>
            <p>Partant du nœud 1, DFS visitera les salles dans l’ordre suivant (dans ce cas particulier) :</p>
            <pre><code>
    1 → 2 → 3 → 6 → 5 → 4
            </code></pre>
            <p>DFS explore en profondeur jusqu’à la salle 6 avant de revenir en arrière pour explorer les autres chemins.</p>
        
            <h4>4. Cas d’Utilisation :</h4>
            <p>DFS est particulièrement utile lorsque l’on veut explorer un graphe complet ou lorsqu’on veut trouver un chemin à travers un labyrinthe, où les chemins peuvent être très profonds avant d’atteindre une solution.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation DFS dans un Contexte de Jeu Vidéo (40 min)</h3>
            
            <h4>1. Représentation du Graphe en Python :</h4>
            <p>Le graphe est représenté en Python sous la forme d’un dictionnaire, où chaque clé représente une salle, et la valeur associée est une liste de salles adjacentes (les voisins).</p>
        
            <pre><code>
    graphe = {
        1: [2, 4],
        2: [1, 3, 5],
        3: [2, 6],
        4: [1, 5],
        5: [2, 4, 6],
        6: [3, 5]
    }
            </code></pre>
        
            <h4>2. Implémentation de DFS en Python :</h4>
            <p>Voici une implémentation simple de l'algorithme DFS pour explorer les salles d’un réseau de grottes :</p>
        
            <pre><code>
    def dfs(graphe, noeud, visites):
        if noeud not in visites:
            print(f"Visite de la salle {noeud}")
            visites.add(noeud)  # Marquer la salle comme visitée
            for voisin dans graphe[noeud]:  # Explorer les voisins non visités
                dfs(graphe, voisin, visites)
    
    # Ensemble des nœuds visités
    visites = set()
    
    # Démarrer le parcours DFS à partir de la salle 1
    dfs(graphe, 1, visites)
            </code></pre>
        
            <h4>3. Explication du Code :</h4>
            <ul>
                <li>La fonction <code>dfs()</code> est appelée avec trois arguments : le graphe, le nœud actuel (la salle où le joueur se trouve), et l’ensemble des salles déjà visitées.</li>
                <li>Si la salle n’a pas encore été visitée, elle est marquée comme visitée et l'algorithme explore tous ses voisins de manière récursive.</li>
                <li>Une fois que tous les voisins ont été explorés, l’algorithme revient en arrière et continue avec les autres chemins possibles.</li>
            </ul>
        
            <h4>Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez le graphe pour ajouter des objets ou des trésors dans certaines salles.</li>
                <li><strong>Étape 2 :</strong> Implémentez une version de DFS qui affiche un message lorsque le joueur trouve un trésor dans une salle.</li>
                <li><strong>Étape 3 :</strong> Ajoutez une fonctionnalité qui limite le nombre de visites dans une salle, comme un nombre maximum de tentatives avant que le joueur échoue.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Comparaison (10 min)</h3>
            <p>À la fin de cette séance, les élèves auront approfondi leur compréhension de l’algorithme DFS et auront appris à l’appliquer dans un contexte de jeu vidéo, en modélisant un labyrinthe ou un réseau de salles. Ils auront également renforcé leurs compétences en <strong>récursivité</strong>, en suivant un chemin en profondeur et en revenant en arrière pour explorer d’autres chemins.</p>
        
            <p>Enfin, nous comparerons DFS avec d’autres algorithmes de parcours comme BFS, en soulignant que DFS est particulièrement efficace dans des contextes où les chemins sont profonds, tandis que BFS est souvent préféré pour trouver les chemins les plus courts.</p>
        </section>

        <section id="session17" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 17 : Pratique - Exploration d’un Monde Ouvert (Jeu Vidéo) avec DFS</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Dans cette séance pratique, les élèves appliqueront l’algorithme DFS (Depth-First Search) pour permettre à un personnage d’explorer un monde ouvert dans un jeu vidéo. L’objectif est de simuler une exploration où le personnage doit visiter différents lieux en profondeur, en suivant des chemins prédéfinis avant de revenir en arrière et explorer d’autres zones.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte de l'Exploration d’un Monde Ouvert dans un Jeu Vidéo</h3>
            
            <h4>1. Le Monde Ouvert :</h4>
            <p>Un <strong>monde ouvert</strong> dans un jeu vidéo est un environnement vaste et interconnecté où le joueur peut se déplacer librement entre différentes zones (comme des villes, des forêts, des montagnes, etc.). Chaque zone est modélisée comme un nœud d’un graphe, et les connexions entre ces zones sont représentées par des chemins.</p>
        
            <p>Dans cette simulation, nous allons modéliser le monde ouvert comme un graphe et utiliser DFS pour simuler l’exploration de ce monde.</p>
        
            <h4>2. Objectif de l’Exploration :</h4>
            <p>Le joueur contrôle un personnage qui doit explorer toutes les zones du monde ouvert. L’objectif est de visiter chaque zone au moins une fois, tout en cherchant des trésors cachés ou des objets dans certaines zones.</p>
        
            <p>Par exemple :</p>
            <ul>
                <li>Le joueur peut commencer dans la <strong>ville principale</strong> (nœud 1).</li>
                <li>Le joueur doit explorer des lieux comme des <strong>forêts</strong>, des <strong>cavernes</strong> ou des <strong>montagnes</strong> interconnectées.</li>
            </ul>
        
            <p>DFS est idéal dans ce contexte, car il explore profondément dans une direction avant de revenir pour visiter d’autres zones.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 1 : Représentation du Monde Ouvert avec un Graphe (30 min)</h3>
            
            <h4>1. Définition du Monde Ouvert sous forme de Graphe :</h4>
            <p>Chaque zone du jeu est représentée comme un nœud du graphe, et les chemins entre les zones sont les arêtes du graphe. Voici un exemple de structure de graphe pour un monde ouvert :</p>
        
            <pre><code>
    Ville Principale --- Forêt --- Caverne
    |                    |        |
    Montagne --- Plage    Lac     Temple
            </code></pre>
        
            <p>Dans ce graphe, le joueur peut explorer des lieux différents en passant par des chemins qui relient les zones. L’algorithme DFS permet de déterminer l’ordre dans lequel ces zones seront explorées.</p>
        
            <h4>2. Représentation en Python :</h4>
            <p>Nous pouvons modéliser ce monde ouvert comme un dictionnaire en Python, où chaque zone est un nœud, et la liste de ses voisins contient les zones adjacentes :</p>
        
            <pre><code>
    monde_ouvert = {
        'Ville Principale': ['Forêt', 'Montagne'],
        'Forêt': ['Ville Principale', 'Caverne', 'Lac'],
        'Caverne': ['Forêt', 'Temple'],
        'Montagne': ['Ville Principale', 'Plage'],
        'Plage': ['Montagne'],
        'Lac': ['Forêt'],
        'Temple': ['Caverne']
    }
            </code></pre>
        
            <h4>3. Objectifs du joueur :</h4>
            <ul>
                <li>Explorer toutes les zones du monde ouvert.</li>
                <li>Trouver des objets ou trésors cachés dans certaines zones.</li>
                <li>Explorer le monde de manière exhaustive en suivant un parcours en profondeur (DFS).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 2 : Implémentation de DFS pour l’Exploration (40 min)</h3>
        
            <h4>1. Implémentation de DFS en Python pour Explorer le Monde Ouvert :</h4>
            <p>Nous allons implémenter DFS pour que le personnage explore chaque zone une par une, en suivant un parcours en profondeur. Voici comment cela peut être fait en Python :</p>
        
            <pre><code>
    def explorer_monde(monde, zone, visites):
        if zone not in visites:
            print(f"Vous explorez {zone}")
            visites.add(zone)  # Marquer la zone comme visitée
            for voisin in monde[zone]:  # Explorer les zones voisines non visitées
                explorer_monde(monde, voisin, visites)
        
    # Ensemble des zones visitées
    zones_visitees = set()
    
    # Lancer l'exploration à partir de la Ville Principale
    explorer_monde(monde_ouvert, 'Ville Principale', zones_visitees)
            </code></pre>
        
            <h4>2. Explication du Code :</h4>
            <ul>
                <li>La fonction <code>explorer_monde()</code> est appelée avec trois arguments : le monde ouvert (le graphe), la zone actuelle, et l’ensemble des zones déjà visitées.</li>
                <li>Si la zone n’a pas encore été visitée, elle est marquée comme visitée, et l’algorithme explore récursivement tous ses voisins (autres zones connectées).</li>
                <li>DFS explore d’abord les zones en profondeur avant de revenir en arrière pour explorer d’autres chemins.</li>
            </ul>
        
            <h4>3. Simulation de l’Exploration :</h4>
            <p>Lorsque vous exécutez le code ci-dessus, le personnage explorera toutes les zones du monde ouvert dans un ordre déterminé par DFS. Par exemple :</p>
            <pre><code>
    Vous explorez Ville Principale
    Vous explorez Forêt
    Vous explorez Caverne
    Vous explorez Temple
    Vous explorez Lac
    Vous explorez Montagne
    Vous explorez Plage
            </code></pre>
            <p>DFS commence à la "Ville Principale", puis explore en profondeur la "Forêt", la "Caverne", et le "Temple" avant de revenir pour explorer d’autres zones.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 3 : Défis Pratiques pour les Élèves (30 min)</h3>
            
            <h4>1. Ajout d’Objets Cachés :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez le monde ouvert pour que certaines zones contiennent des objets ou des trésors cachés.</li>
                <li><strong>Étape 2 :</strong> Modifiez le code pour que l'algorithme affiche un message lorsqu'un objet ou trésor est trouvé dans une zone spécifique.</li>
            </ul>
        
            <h4>2. Limitation du Temps d’Exploration :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Ajoutez une contrainte de temps ou un nombre maximum d'explorations que le joueur peut effectuer avant que le temps ne s’écoule.</li>
                <li><strong>Étape 2 :</strong> Implémentez cette limite dans le code. Si le joueur dépasse la limite, un message s’affiche pour indiquer que l’exploration est terminée.</li>
            </ul>
        
            <h4>3. Exploration Sélective :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Créez un système où certaines zones du monde ouvert sont bloquées jusqu'à ce que le joueur trouve une clé ou un objet spécial dans une autre zone.</li>
                <li><strong>Étape 2 :</strong> Modifiez l'algorithme pour permettre au joueur d'explorer uniquement après avoir trouvé cet objet.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Réflexion sur DFS dans les Jeux Vidéo (10 min)</h3>
        
            <h4>Analyse de DFS dans un Monde Ouvert :</h4>
            <p>DFS est une méthode efficace pour explorer des mondes ouverts en profondeur, permettant au joueur de suivre des chemins jusqu’à ce qu’il atteigne une impasse ou un objectif. Une fois qu’un chemin est épuisé, l’algorithme revient en arrière pour explorer d’autres options.</p>
        
            <h4>Avantages et Inconvénients :</h4>
            <ul>
                <li><strong>Avantage :</strong> DFS est excellent pour explorer les mondes où l’objectif est situé à une grande profondeur (par exemple, dans une grotte éloignée ou dans un temple caché).</li>
                <li><strong>Inconvénient :</strong> DFS peut parfois suivre un chemin non optimal avant de revenir en arrière pour explorer d’autres options.</li>
            </ul>
        
            <h4>Discussion :</h4>
            <ul>
                <li>Comparez DFS avec d’autres algorithmes d’exploration, comme BFS (Breadth-First Search), pour discuter des avantages et inconvénients dans des mondes ouverts.</li>
                <li>Comment pourriez-vous modifier cet algorithme pour permettre une exploration plus "intelligente" dans un monde ouvert ? Par exemple, ajouter une stratégie d’évitement des zones dangereuses ou moins intéressantes.</li>
            </ul>
        </section>

        <section id="session18" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 18 : Applications Réelles des Graphes (Réseaux Sociaux, Chemins dans les Transports)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Dans cette séance, les élèves vont découvrir des applications concrètes de l’utilisation des graphes dans des domaines comme les réseaux sociaux et les systèmes de transport. Ils apprendront à modéliser des situations réelles sous forme de graphes, puis à appliquer des algorithmes de parcours pour résoudre des problèmes spécifiques. Le but est de renforcer la compréhension des graphes à travers des cas pratiques.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Graphes dans le Monde Réel</h3>
            <h4>1. Qu’est-ce qu’un Graphe ?</h4>
            <p>Un graphe est une structure composée de :</p>
            <ul>
                <li><strong>Nœuds (ou sommets) :</strong> représentant des entités (personnes, lieux, stations de transport).</li>
                <li><strong>Arêtes :</strong> les connexions entre les nœuds, représentant des relations (amitié dans les réseaux sociaux, lignes de métro dans un réseau de transport).</li>
            </ul>
            <p>Dans les applications réelles, les graphes peuvent modéliser une grande variété de systèmes complexes.</p>
        
            <h4>2. Applications Réelles des Graphes :</h4>
            <ul>
                <li><strong>Réseaux sociaux :</strong> Les utilisateurs sont les nœuds, et les connexions (amitié, abonnements) sont les arêtes. DFS et BFS peuvent être utilisés pour explorer des groupes d’amis ou des recommandations.</li>
                <li><strong>Réseaux de transport :</strong> Les stations ou arrêts sont des nœuds, et les lignes de transport (bus, métro) sont des arêtes. Les algorithmes de recherche permettent de trouver le chemin le plus court entre deux stations.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étude de Cas 1 : Réseaux Sociaux (40 min)</h3>
            
            <h4>1. Modélisation des Réseaux Sociaux :</h4>
            <p>Dans un réseau social, chaque utilisateur est un **nœud** et chaque relation (amitié, abonnement) est une **arête**. Les graphes permettent de modéliser ces connexions pour résoudre des problèmes comme :</p>
            <ul>
                <li><strong>Explorer des groupes d’amis :</strong> Utilisation de DFS ou BFS pour parcourir un réseau d'amis et suggérer de nouvelles connexions.</li>
                <li><strong>Recommandations :</strong> Utilisation d'algorithmes pour trouver les amis d'amis et recommander de nouveaux contacts.</li>
            </ul>
        
            <h4>2. Exemple Visuel d'un Réseau Social :</h4>
            <pre><code>
    Personne 1 --- Personne 2 --- Personne 3
       |               |               |
    Personne 4 --- Personne 5 --- Personne 6
            </code></pre>
            <p>Chaque personne est représentée comme un nœud, et les liens d’amitié comme des arêtes. L’algorithme peut explorer les connexions d’une personne pour proposer des recommandations.</p>
        
            <h4>3. Algorithme DFS pour Explorer les Amis :</h4>
            <p>On peut utiliser l’algorithme DFS pour explorer les groupes d’amis de manière récursive, à partir d’une personne donnée :</p>
        
            <pre><code>
    def explorer_reseau(graphe, personne, visites):
        if personne not in visites:
            print(f"Exploration de l’ami {personne}")
            visites.add(personne)
            for ami dans graphe[personne]:
                explorer_reseau(graphe, ami, visites)
            </code></pre>
        
            <p>Ce code permet d'explorer tous les amis directs et indirects d'une personne dans le réseau social.</p>
        
            <h4>4. Exemple d'Implémentation en Python :</h4>
            <pre><code>
    reseau_social = {
        "Personne 1": ["Personne 2", "Personne 4"],
        "Personne 2": ["Personne 1", "Personne 3", "Personne 5"],
        "Personne 3": ["Personne 2", "Personne 6"],
        "Personne 4": ["Personne 1", "Personne 5"],
        "Personne 5": ["Personne 2", "Personne 4", "Personne 6"],
        "Personne 6": ["Personne 3", "Personne 5"]
    }
    
    # Ensemble des personnes déjà visitées
    visites = set()
    
    # Lancer l'exploration à partir de "Personne 1"
    explorer_reseau(reseau_social, "Personne 1", visites)
            </code></pre>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez le réseau social pour ajouter des liens d’amitié supplémentaires.</li>
                <li><strong>Étape 2 :</strong> Utilisez DFS pour explorer les amis de "Personne 3" et proposer des amis potentiels (amis d’amis).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étude de Cas 2 : Réseau de Transport (40 min)</h3>
        
            <h4>1. Modélisation d’un Réseau de Transport :</h4>
            <p>Un réseau de transport, comme un réseau de métro ou de bus, peut être modélisé sous forme de graphe :</p>
            <ul>
                <li><strong>Nœuds :</strong> Les stations ou arrêts de bus.</li>
                <li><strong>Arêtes :</strong> Les lignes de transport entre les stations.</li>
            </ul>
        
            <h4>2. Rechercher le Chemin le Plus Court :</h4>
            <p>Dans un réseau de transport, un problème fréquent est de trouver le chemin le plus court entre deux stations. Pour cela, nous utilisons l’algorithme **BFS (Breadth-First Search)**, qui explore tous les voisins d'une station avant de passer aux voisins de niveau supérieur.</p>
        
            <h4>3. Exemple Visuel d’un Réseau de Transport :</h4>
            <pre><code>
    Station A --- Station B --- Station C
        |           |               |
    Station D --- Station E --- Station F
            </code></pre>
            <p>Chaque station est représentée par un nœud, et chaque ligne de transport entre deux stations est une arête.</p>
        
            <h4>Algorithme BFS pour Trouver le Chemin le Plus Court :</h4>
            <p>Nous allons utiliser l’algorithme BFS pour trouver le chemin le plus court entre deux stations :</p>
        
            <pre><code>
    from collections import deque
        
    def bfs_chemin_court(graphe, debut, fin):
        visites = set()  # Ensemble des stations visitées
        queue = deque([(debut, [debut])])  # File d'attente avec le chemin actuel
        
        while queue:
            (station, chemin) = queue.popleft()
            if station == fin:
                return chemin  # Retourner le chemin trouvé
            
            for voisin dans graphe[station]:
                if voisin not in visites:
                    visites.add(voisin)
                    queue.append((voisin, chemin + [voisin]))  # Ajouter le voisin et le chemin parcouru
        return None  # Aucun chemin trouvé
            </code></pre>
        
            <h4>4. Implémentation en Python :</h4>
            <pre><code>
    reseau_transport = {
        "Station A": ["Station B", "Station D"],
        "Station B": ["Station A", "Station C", "Station E"],
        "Station C": ["Station B", "Station F"],
        "Station D": ["Station A", "Station E"],
        "Station E": ["Station B", "Station D", "Station F"],
        "Station F": ["Station C", "Station E"]
    }
    
    chemin = bfs_chemin_court(reseau_transport, "Station A", "Station F")
    print(f"Le chemin le plus court est : {chemin}")
            </code></pre>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Ajoutez de nouvelles lignes de transport dans le réseau.</li>
                <li><strong>Étape 2 :</strong> Utilisez BFS pour trouver le chemin le plus court entre deux stations définies par l’utilisateur.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Comparaison des Applications (10 min)</h3>
            
            <h4>Discussion :</h4>
            <ul>
                <li>Les graphes sont une structure extrêmement polyvalente utilisée dans des domaines très variés, des réseaux sociaux aux transports en passant par la biologie.</li>
                <li>Les algorithmes de parcours comme DFS et BFS permettent de résoudre efficacement des problèmes complexes tels que l’exploration de réseaux ou la recherche de chemins.</li>
                <li>Dans les réseaux sociaux, DFS peut être utilisé pour explorer des relations profondes, tandis que BFS est souvent utilisé pour explorer des connexions plus directes, comme dans les réseaux de transport.</li>
            </ul>
        
            <h4>Problèmes Avancés :</h4>
            <ul>
                <li>Comment optimiser le parcours dans un graphe de grande taille, où chaque nœud peut avoir de nombreux voisins ?</li>
                <li>Comment adapter ces algorithmes pour des applications plus spécifiques, comme la recommandation de contenu ou la gestion du trafic dans un réseau urbain ?</li>
            </ul>
        </section>
        
        <section id="session19" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 19 : Introduction aux Arbres Binaires et leurs Applications</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves découvriront les arbres binaires, leurs propriétés, et leurs applications dans un contexte de jeu vidéo. Ils apprendront à modéliser et à manipuler des arbres binaires, en mettant l'accent sur des applications concrètes comme la gestion d'inventaires dans un jeu ou la recherche rapide d'objets.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Arbres Binaires</h3>
        
            <h4>1. Qu’est-ce qu’un Arbre Binaire ?</h4>
            <p>Un arbre binaire est une structure de données hiérarchique dans laquelle chaque nœud a au maximum deux enfants, appelés <strong>enfant gauche</strong> et <strong>enfant droit</strong>.</p>
            
            <h4>Exemple Visuel :</h4>
            <pre><code>
          8
         / \
        3   10
       / \    \
      1   6   14
         / \   /
        4   7 13
            </code></pre>
            <p>Dans cet exemple, chaque nœud contient une valeur, et chaque nœud peut avoir deux enfants. Le nœud racine est 8, les enfants de 8 sont 3 (à gauche) et 10 (à droite).</p>
        
            <h4>Propriétés des Arbres Binaires :</h4>
            <ul>
                <li>Chaque nœud a au plus deux enfants.</li>
                <li>Les sous-arbres peuvent eux-mêmes être des arbres binaires.</li>
                <li>Un arbre binaire peut être utilisé pour stocker des données ordonnées de manière à permettre des recherches, des insertions et des suppressions rapides.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Applications des Arbres Binaires dans un Jeu Vidéo</h3>
        
            <h4>Contexte du Jeu Vidéo :</h4>
            <p>Dans un jeu vidéo de gestion d'inventaire, chaque objet ramassé par le joueur peut être stocké dans un arbre binaire de recherche (binary search tree, ou BST). Cet arbre permet de rechercher un objet spécifique rapidement, ou de trier les objets par ordre de puissance ou de rareté.</p>
        
            <h4>Exemple d'Application : Gestion d'Inventaire</h4>
            <p>Dans un RPG (jeu de rôle), les objets ramassés par le joueur peuvent être organisés dans un arbre binaire selon leur valeur (par exemple, un objet plus puissant sera placé à droite d'un objet moins puissant). Cela permet de rechercher un objet de manière efficace, ou de lister tous les objets dans l'ordre de leur valeur.</p>
        
            <h4>Modélisation d’un Inventaire avec un Arbre Binaire :</h4>
            <p>Chaque objet dans l’inventaire est un nœud de l’arbre, où :</p>
            <ul>
                <li>La racine de l'arbre est le premier objet ramassé.</li>
                <li>Les objets plus puissants sont placés à droite de l’arbre.</li>
                <li>Les objets moins puissants sont placés à gauche.</li>
            </ul>
        
            <h4>Exemple Visuel avec des Objets :</h4>
            <pre><code>
        Épée de fer (puissance 8)
         /         \
    Bouclier (3)  Arc (10)
                \
             Flèche (14)
            </code></pre>
        
            <p>Dans cet exemple, l'épée de fer est la racine, car elle a été ramassée en premier. Le bouclier, moins puissant, est placé à gauche. L’arc, plus puissant, est placé à droite.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation d’un Arbre Binaire en Python (40 min)</h3>
        
            <h4>1. Représentation d’un Nœud d’Arbre Binaire :</h4>
            <p>Nous allons d’abord définir une classe <code>ArbreBinaire</code> pour représenter chaque nœud de l’arbre binaire.</p>
        
            <pre><code>
    class ArbreBinaire:
        def __init__(self, valeur):
            self.valeur = valeur
            self.gauche = None
            self.droite = None
            </code></pre>
        
            <p>Chaque nœud a une <code>valeur</code> et peut avoir deux enfants : <code>gauche</code> et <code>droite</code>.</p>
        
            <h4>2. Insertion dans un Arbre Binaire :</h4>
            <p>Pour insérer un nouvel objet dans l’arbre binaire, nous allons comparer la valeur de l’objet avec la valeur du nœud courant. Si l’objet est moins puissant (ou de valeur inférieure), il sera inséré à gauche. Sinon, il sera inséré à droite.</p>
        
            <pre><code>
    def inserer(noeud, valeur):
        if noeud is None:
            return ArbreBinaire(valeur)
        
        if valeur < noeud.valeur:
            noeud.gauche = inserer(noeud.gauche, valeur)
        else:
            noeud.droite = inserer(noeud.droite, valeur)
        
        return noeud
            </code></pre>
        
            <h4>3. Exemple d’Insertion dans l’Arbre :</h4>
            <p>Supposons que le joueur ramasse un bouclier avec une puissance de 5 et qu’il l’insère dans l’inventaire :</p>
        
            <pre><code>
    # Créer la racine de l'arbre
    racine = ArbreBinaire(8)
    
    # Insérer d'autres objets dans l'inventaire
    inserer(racine, 3)  # Bouclier
    inserer(racine, 10) # Arc
    inserer(racine, 1)  # Casque
            </code></pre>
        
            <h4>4. Parcours Infixe (In-order Traversal) :</h4>
            <p>Pour lister les objets dans l’ordre de leur puissance, nous utilisons un parcours infixe. Ce parcours visite d’abord le sous-arbre gauche, puis le nœud courant, et enfin le sous-arbre droit.</p>
        
            <pre><code>
    def parcours_infixe(noeud):
        if noeud:
            parcours_infixe(noeud.gauche)
            print(noeud.valeur, end=" ")
            parcours_infixe(noeud.droite)
    
    # Lancer le parcours infixe
    parcours_infixe(racine)
            </code></pre>
        
            <h4>Résultat attendu :</h4>
            <p>Si le joueur a ramassé des objets avec des puissances de 1, 3, 8, et 10, le parcours infixe affichera : <code>1 3 8 10</code>.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Défi Pratique pour les Élèves (30 min)</h3>
        
            <h4>Étape 1 :</h4>
            <p>Modifiez le programme pour que chaque objet ait un nom (par exemple, “Épée de fer”) en plus de sa valeur de puissance. Vous pouvez créer une classe <code>Objet</code> pour représenter chaque objet, et la valeur de puissance sera utilisée pour ordonner les objets dans l’arbre binaire.</p>
        
            <h4>Étape 2 :</h4>
            <p>Ajoutez une fonctionnalité permettant de chercher un objet dans l’arbre par son nom ou sa puissance. Si l’objet est trouvé, affichez ses caractéristiques. Si l’objet n’est pas trouvé, affichez un message indiquant qu’il n’est pas dans l’inventaire.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion (10 min)</h3>
            <p>À la fin de cette séance, les élèves auront appris les concepts fondamentaux des arbres binaires et auront appliqué ces connaissances à un exemple concret de gestion d’inventaire dans un jeu vidéo. Ils auront également renforcé leur compréhension des parcours d’arbres (parcours infixe) et de l’insertion dans un arbre binaire.</p>
            <p>Les élèves pourront utiliser cette structure de données pour d’autres applications dans leurs futurs projets, comme la gestion de données hiérarchiques ou la recherche efficace d’informations.</p>
        </section>

        <section id="session20" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 20 : Pratique - Utilisation d’arbres pour organiser une base de données de personnages de manga</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront à utiliser une structure de données en <strong>arbre binaire de recherche (BST)</strong> pour organiser une base de données de personnages de manga. Ils exploreront comment stocker et rechercher efficacement des informations sur les personnages en fonction de caractéristiques spécifiques (nom, puissance, affiliation).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Arbres Binaires et à leur Utilisation (30 min)</h3>
        
            <h4>Contexte de la Séance :</h4>
            <p>Dans l’univers des mangas, chaque personnage a des caractéristiques uniques (nom, puissance, affiliation, etc.). Nous allons organiser une base de données de personnages en utilisant un <strong>arbre binaire de recherche</strong> pour permettre des opérations de recherche rapide, d’ajout et de suppression de personnages.</p>
        
            <h4>Qu'est-ce qu'un Arbre Binaire de Recherche (BST) ?</h4>
            <p>Un <strong>arbre binaire de recherche (BST)</strong> est une structure de données récursive qui permet de stocker des données de manière ordonnée, facilitant ainsi les opérations de recherche, d'insertion et de suppression.</p>
            <ul>
                <li><strong>Nœud :</strong> Chaque nœud de l'arbre contient un élément (par exemple, un personnage de manga).</li>
                <li><strong>Clé :</strong> Chaque nœud a une clé (par exemple, le nom du personnage ou un autre attribut) qui est utilisée pour organiser l’arbre.</li>
                <li><strong>Arbre binaire :</strong> Chaque nœud a au plus deux enfants : un enfant à gauche (plus petit) et un enfant à droite (plus grand).</li>
            </ul>
        
            <h4>Principe du BST :</h4>
            <p>Dans un BST :</p>
            <ul>
                <li>Pour chaque nœud, tous les éléments dans le sous-arbre gauche sont plus petits que l’élément du nœud.</li>
                <li>Tous les éléments dans le sous-arbre droit sont plus grands que l’élément du nœud.</li>
            </ul>
        
            <h4>Exemple Visuel d’un Arbre Binaire de Recherche :</h4>
            <pre><code>
            Luffy
            /    \
         Goku    Naruto
         /  \       /   \
    Zoro Vegeta   Sasuke  Saitama
            </code></pre>
            <p>Dans cet arbre :</p>
            <ul>
                <li>Le personnage Luffy est la racine.</li>
                <li>Les personnages situés à gauche de Luffy (Goku, Zoro) ont des noms plus petits (ordre alphabétique), tandis que ceux situés à droite (Naruto, Saitama) ont des noms plus grands.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation Pratique d’un Arbre Binaire de Recherche (BST) (45 min)</h3>
        
            <h4>1. Créer une Classe pour Représenter un Personnage de Manga :</h4>
            <p>Chaque personnage sera représenté par un objet contenant des informations telles que son nom, sa puissance et son affiliation.</p>
        
            <pre><code>
    class PersonnageManga:
        def __init__(self, nom, puissance, affiliation):
            self.nom = nom
            self.puissance = puissance
            self.affiliation = affiliation
            self.gauche = None  # Sous-arbre gauche
            self.droite = None  # Sous-arbre droit
    
        def __str__(self):
            return f"{self.nom} - Puissance : {self.puissance}, Affiliation : {self.affiliation}"
            </code></pre>
        
            <p>Chaque instance de <code>PersonnageManga</code> représente un personnage avec un nom, une puissance et une affiliation.</p>
        
            <h4>2. Créer un Arbre Binaire de Recherche :</h4>
            <p>L’arbre binaire de recherche sera utilisé pour organiser les personnages en fonction de leur nom. Chaque nœud de l’arbre contiendra un personnage de manga.</p>
        
            <pre><code>
    class ArbreBinaireRecherche:
        def __init__(self):
            self.racine = None  # La racine de l'arbre est initialement vide
    
        # Fonction pour insérer un nouveau personnage dans l'arbre
        def inserer(self, personnage):
            if self.racine is None:
                self.racine = personnage  # Si l'arbre est vide, le personnage devient la racine
            else:
                self._inserer_recur(self.racine, personnage)
    
        # Fonction récursive pour insérer dans le bon sous-arbre
        def _inserer_recur(self, courant, personnage):
            if personnage.nom < courant.nom:
                if courant.gauche is None:
                    courant.gauche = personnage  # Insertion à gauche
                else:
                    self._inserer_recur(courant.gauche, personnage)  # Récursion vers la gauche
            else:
                if courant.droite is None:
                    courant.droite = personnage  # Insertion à droite
                else:
                    self._inserer_recur(courant.droite, personnage)  # Récursion vers la droite
    
        # Fonction pour afficher l'arbre en parcours infixe (ordre alphabétique)
        def afficher_infixe(self):
            self._afficher_infixe_recur(self.racine)
    
        def _afficher_infixe_recur(self, courant):
            if courant is not None:
                self._afficher_infixe_recur(courant.gauche)
                print(courant)
                self._afficher_infixe_recur(courant.droite)
            </code></pre>
        
            <p>Cette classe permet d’ajouter des personnages dans l’arbre et de les afficher dans l’ordre alphabétique grâce à un parcours en infixe.</p>
        
            <h4>3. Insérer des Personnages dans l’Arbre :</h4>
            <p>Ajoutons des personnages célèbres de mangas dans notre arbre :</p>
        
            <pre><code>
    # Création de l'arbre
    arbre = ArbreBinaireRecherche()
    
    # Création des personnages
    luffy = PersonnageManga("Luffy", 9000, "Pirate")
    goku = PersonnageManga("Goku", 9500, "Guerrier Saiyan")
    naruto = PersonnageManga("Naruto", 8800, "Ninja")
    saitama = PersonnageManga("Saitama", 10000, "Héros")
    zoro = PersonnageManga("Zoro", 8500, "Pirate")
    vegeta = PersonnageManga("Vegeta", 9400, "Guerrier Saiyan")
    
    # Insertion dans l'arbre
    arbre.inserer(luffy)
    arbre.inserer(goku)
    arbre.inserer(naruto)
    arbre.inserer(saitama)
    arbre.inserer(zoro)
    arbre.inserer(vegeta)
    
    # Affichage des personnages dans l'ordre alphabétique
    arbre.afficher_infixe()
            </code></pre>
        
            <p>La sortie du programme affichera les personnages par ordre alphabétique de nom :</p>
        
            <pre><code>
    Goku - Puissance : 9500, Affiliation : Guerrier Saiyan
    Luffy - Puissance : 9000, Affiliation : Pirate
    Naruto - Puissance : 8800, Affiliation : Ninja
    Saitama - Puissance : 10000, Affiliation : Héros
    Vegeta - Puissance : 9400, Affiliation : Guerrier Saiyan
    Zoro - Puissance : 8500, Affiliation : Pirate
            </code></pre>
        
            <h4>4. Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez le programme pour que l’arbre soit organisé en fonction de la puissance des personnages au lieu de leur nom.</li>
                <li><strong>Étape 2 :</strong> Ajoutez une fonction pour rechercher un personnage par nom dans l’arbre et renvoyer ses caractéristiques.</li>
                <li><strong>Étape 3 :</strong> Ajoutez une fonctionnalité pour supprimer un personnage de l’arbre (utilisation d’un algorithme de suppression dans un arbre binaire).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Applications (10 min)</h3>
        
            <p>À la fin de cette séance, les élèves auront appris à :</p>
            <ul>
                <li>Utiliser un <strong>arbre binaire de recherche</strong> pour organiser et gérer des données de manière structurée et efficace.</li>
                <li>Implémenter les opérations de base d’un arbre (insertion, parcours, recherche) dans un contexte de gestion de base de données de personnages de manga.</li>
            </ul>
        
            <p>Cette approche leur permettra de comprendre comment les structures de données avancées sont utilisées pour organiser de grandes quantités de données dans des applications réelles, telles que les bases de données et les systèmes de recherche d’information.</p>
        </section>
        
        <section id="session21" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 21 : Algorithmes de Parcours d’Arbres (Pré-ordre, En-ordre, Post-ordre)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront et mettront en pratique les trois principales méthodes de parcours d’arbres binaires : pré-ordre, en-ordre, et post-ordre. Ils exploreront ces algorithmes dans le contexte d'un jeu vidéo où un personnage doit explorer des niveaux structurés sous forme d'arbres (arborescence de décisions, exploration d’environnements hiérarchiques).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Arbres Binaires et Parcours</h3>
            <h4>Le Contexte du Jeu Vidéo :</h4>
            <p>Dans un jeu vidéo d'exploration, un personnage évolue dans une série de niveaux ou d’environnements reliés entre eux de manière hiérarchique. Chaque environnement peut être modélisé sous forme d’arbre binaire :</p>
            <ul>
                <li><strong>Nœuds :</strong> représentent des zones ou des objectifs dans le jeu (par exemple, des salles, des missions, ou des ennemis).</li>
                <li><strong>Branches (arêtes) :</strong> relient deux nœuds et représentent les chemins ou les transitions possibles entre les différentes zones ou objectifs.</li>
            </ul>
            <p>Le joueur doit explorer l’arbre en visitant chaque nœud en suivant un parcours spécifique. Nous allons explorer trois types de parcours : pré-ordre, en-ordre, et post-ordre.</p>
        
            <h4>Définition d’un Arbre Binaire :</h4>
            <ul>
                <li><strong>Nœud Racine :</strong> Le point de départ de l’arbre.</li>
                <li><strong>Nœuds Fils :</strong> Deux sous-arbres, le fils gauche et le fils droit.</li>
                <li><strong>Feuille :</strong> Un nœud sans fils.</li>
            </ul>
        
            <h4>Exemple d’Arbre Binaire :</h4>
            <pre><code>
                A
               / \
              B   C
             / \   \
            D   E   F
            </code></pre>
            <p>Dans cet arbre, A est la racine, B et C sont ses enfants, et D, E, F sont des feuilles.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Algorithmes de Parcours d’Arbres (30 min)</h3>
            
            <h4>1. Parcours en Pré-ordre (Prefix Traversal) :</h4>
            <p>Le parcours en pré-ordre explore un arbre en visitant d’abord le nœud racine, puis le sous-arbre gauche, puis le sous-arbre droit. Il suit l’ordre suivant :</p>
            <ul>
                <li>Visiter la racine</li>
                <li>Explorer le sous-arbre gauche</li>
                <li>Explorer le sous-arbre droit</li>
            </ul>
            
            <h4>Exemple Visuel du Parcours en Pré-ordre :</h4>
            <pre><code>
                A
               / \
              B   C
             / \   \
            D   E   F
            
            Parcours pré-ordre : A → B → D → E → C → F
            </code></pre>
            
            <h4>Pseudo-code du Parcours en Pré-ordre :</h4>
            <pre><code>
        def parcours_preordre(noeud):
            if noeud:
                print(noeud.valeur)  # Visiter la racine
                parcours_preordre(noeud.gauche)  # Explorer le sous-arbre gauche
                parcours_preordre(noeud.droite)  # Explorer le sous-arbre droit
            </code></pre>
        
            <h4>Explication :</h4>
            <ul>
                <li>La racine est visitée en premier.</li>
                <li>Le sous-arbre gauche est entièrement exploré avant de passer au sous-arbre droit.</li>
            </ul>
        
            <h4>2. Parcours en En-ordre (Infix Traversal) :</h4>
            <p>Le parcours en en-ordre explore l’arbre en visitant d’abord le sous-arbre gauche, puis la racine, puis le sous-arbre droit. Il suit l’ordre suivant :</p>
            <ul>
                <li>Explorer le sous-arbre gauche</li>
                <li>Visiter la racine</li>
                <li>Explorer le sous-arbre droit</li>
            </ul>
        
            <h4>Exemple Visuel du Parcours en En-ordre :</h4>
            <pre><code>
                A
               / \
              B   C
             / \   \
            D   E   F
            
            Parcours en-ordre : D → B → E → A → C → F
            </code></pre>
        
            <h4>Pseudo-code du Parcours en En-ordre :</h4>
            <pre><code>
        def parcours_enordre(noeud):
            if noeud:
                parcours_enordre(noeud.gauche)  # Explorer le sous-arbre gauche
                print(noeud.valeur)  # Visiter la racine
                parcours_enordre(noeud.droite)  # Explorer le sous-arbre droit
            </code></pre>
        
            <h4>Explication :</h4>
            <ul>
                <li>Le sous-arbre gauche est entièrement exploré avant de visiter la racine.</li>
                <li>Le sous-arbre droit est visité en dernier.</li>
            </ul>
        
            <h4>3. Parcours en Post-ordre (Postfix Traversal) :</h4>
            <p>Le parcours en post-ordre explore l’arbre en visitant d’abord le sous-arbre gauche, puis le sous-arbre droit, et enfin la racine. Il suit l’ordre suivant :</p>
            <ul>
                <li>Explorer le sous-arbre gauche</li>
                <li>Explorer le sous-arbre droit</li>
                <li>Visiter la racine</li>
            </ul>
        
            <h4>Exemple Visuel du Parcours en Post-ordre :</h4>
            <pre><code>
                A
               / \
              B   C
             / \   \
            D   E   F
            
            Parcours post-ordre : D → E → B → F → C → A
            </code></pre>
        
            <h4>Pseudo-code du Parcours en Post-ordre :</h4>
            <pre><code>
        def parcours_postordre(noeud):
            if noeud:
                parcours_postordre(noeud.gauche)  # Explorer le sous-arbre gauche
                parcours_postordre(noeud.droite)  # Explorer le sous-arbre droit
                print(noeud.valeur)  # Visiter la racine
            </code></pre>
        
            <h4>Explication :</h4>
            <ul>
                <li>Les deux sous-arbres sont explorés avant de visiter la racine.</li>
                <li>Le parcours en post-ordre est souvent utilisé dans les contextes où des sous-arbres doivent être traités avant leur racine.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique dans le Contexte du Jeu Vidéo (40 min)</h3>
        
            <h4>1. Représentation d’un Arbre en Python :</h4>
            <p>Dans ce jeu vidéo, nous allons modéliser une série de niveaux interconnectés sous forme d’arbre binaire. Voici une classe Python pour représenter un nœud dans l’arbre :</p>
        
            <pre><code>
        class Noeud:
            def __init__(self, valeur):
                self.valeur = valeur
                self.gauche = None
                self.droite = None
        
        # Créer un exemple d'arbre
        racine = Noeud('A')
        racine.gauche = Noeud('B')
        racine.droite = Noeud('C')
        racine.gauche.gauche = Noeud('D')
        racine.gauche.droite = Noeud('E')
        racine.droite.droite = Noeud('F')
            </code></pre>
        
            <h4>2. Implémentation des Trois Parcours :</h4>
            <p>Les élèves implémenteront les trois types de parcours (pré-ordre, en-ordre, post-ordre) en Python, à partir de la structure d'arbre ci-dessus.</p>
        
            <pre><code>
        def parcours_preordre(noeud):
            if noeud:
                print(noeud.valeur)
                parcours_preordre(noeud.gauche)
                parcours_preordre(noeud.droite)
        
        def parcours_enordre(noeud):
            if noeud:
                parcours_enordre(noeud.gauche)
                print(noeud.valeur)
                parcours_enordre(noeud.droite)
        
        def parcours_postordre(noeud):
            if noeud:
                parcours_postordre(noeud.gauche)
                parcours_postordre(noeud.droite)
                print(noeud.valeur)
            </code></pre>
        
            <h4>Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Implémentez les trois parcours et testez-les sur l’arbre fourni.</li>
                <li><strong>Étape 2 :</strong> Modifiez l’arbre pour ajouter plus de niveaux et des valeurs différentes.</li>
                <li><strong>Étape 3 :</strong> Modélisez un système de progression dans un jeu vidéo où chaque nœud représente une mission ou un niveau, et le joueur suit un parcours spécifique (par exemple, post-ordre pour accomplir toutes les missions avant de rencontrer le boss final).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Comparaison (10 min)</h3>
            <p>À la fin de cette séance, les élèves auront appris à appliquer les trois parcours d’arbres dans différents contextes, et auront compris comment chaque type de parcours peut être utile selon le problème à résoudre. Ils auront également renforcé leur compréhension de la récursivité et de la structure des arbres binaires.</p>
        </section>
        
    </main>

    <!-- <footer>
        <p>&copy; 2024 Programme NSI Tle</p>
    </footer> -->

    <script>
        const holidays = {
            '2024-11-11': 'Armistice 1918',
            '2024-12-25': 'Noël',
            '2025-01-01': 'Jour de l\'An',
            '2025-04-21': 'Lundi de Pâques',
            '2025-05-01': 'Fête du Travail',
            '2025-05-08': 'Victoire 1945',
            '2025-05-29': 'Ascension',
            '2025-06-09': 'Lundi de Pentecôte'
        };
    
        const vacations = [
            { start: '2024-10-19', end: '2024-11-03', name: 'Vacances de la Toussaint' },
            { start: '2024-12-21', end: '2025-01-05', name: 'Vacances de Noël' },
            { start: '2025-02-22', end: '2025-03-09', name: 'Vacances d\'hiver' },
            { start: '2025-04-19', end: '2025-05-04', name: 'Vacances de printemps' },
            { start: '2025-07-05', end: '2025-09-02', name: 'Vacances d\'été' }
        ];
    
        const sessions = [
            'Séance 1 : Introduction à la récursivité (concepts de base)',
            'Séance 2 : Pratique - Implémentation d’une fonction récursive pour calculer une suite mathématique',
            'Séance 3 : Applications pratiques de la récursivité (problèmes simples)',
            'Séance 4 : Introduction aux Algorithmes de Recherche Récursive – Recherche Binaire',
            'Séance 5 : Pratique – Recherche d’un Personnage de Manga avec un Algorithme de Recherche Binaire',
            'Séance 6 : Analyse de la Complexité d’un Algorithme de Recherche Récursive',
            'Séance 7 : Introduction au Backtracking (Concepts de Base)',
            'Séance 8 : Pratique - Résolution d\'un Labyrinthe avec Backtracking (Jeu Vidéo)',
            'Séance 9 : Étude des Cas Où le Backtracking Est Utile et de Ses Limitations',
            'Séance 10 : Introduction à la Complexité Algorithmique – Notation Big-O',
            'Séance 11 : Pratique - Comparaison des Algorithmes de Tri Simples (Insertion, Sélection)',
            'Séance 12 : Exercices d’Analyse de la Complexité des Algorithmes dans des Jeux Vidéo et la Vie Réelle',
            'Séance 13 : Introduction aux Graphes et à leurs Applications',
            'Séance 14 : Pratique - Représentation d\'un Réseau de Routes dans un Jeu Vidéo avec des Graphes',
            'Séance 15 : Algorithmes de Parcours de Graphes – DFS et BFS',
            'Séance 16 : Approfondissement sur l’algorithme DFS (Depth-First Search)',
            'Séance 17 : Pratique - Exploration d’un Monde Ouvert (Jeu Vidéo) avec DFS',
            'Séance 18 : Applications Réelles des Graphes (Réseaux Sociaux, Chemins dans les Transports)',
            'Séance 19 : Introduction aux Arbres Binaires et leurs Applications',
            'Séance 20 : Pratique - Utilisation d’arbres pour organiser une base de données de personnages de manga'
        ];
    
        function isHoliday(date) {
            return holidays[date] !== undefined;
        }
    
        function isInVacation(date) {
            const parsedDate = new Date(date);
            return vacations.some(vacation => {
                const startDate = new Date(vacation.start);
                const endDate = new Date(vacation.end);
                return parsedDate >= startDate && parsedDate <= endDate;
            });
        }
    
        function getVacationName(date) {
            const parsedDate = new Date(date);
            const vacation = vacations.find(vacation => {
                const startDate = new Date(vacation.start);
                const endDate = new Date(vacation.end);
                return parsedDate >= startDate && parsedDate <= endDate;
            });
            return vacation ? vacation.name : '';
        }
    
        function formatFrenchDate(date) {
            const options = { year: 'numeric', month: '2-digit', day: '2-digit' };
            return new Date(date).toLocaleDateString('fr-FR', options);
        }
    
        function isCurrentWeek(date) {
            const currentDate = new Date();
            const firstDayOfWeek = new Date(date);
            const lastDayOfWeek = new Date(firstDayOfWeek);
            lastDayOfWeek.setDate(firstDayOfWeek.getDate() + 6);
            return currentDate >= firstDayOfWeek && currentDate <= lastDayOfWeek;
        }

        function isToday(date) {
            const today = new Date().toISOString().split('T')[0];
            return today === date;
        }
    
        function generateCalendar() {
            const calendarBody = document.getElementById('calendar-body');
            const startDate = new Date('2024-09-04');  // Premier mercredi de septembre 2024
            const endDate = new Date('2025-07-12');
            
            let currentDate = startDate;
            let sessionIndex = 0;
    
            while (currentDate <= endDate) {
                const row = document.createElement('tr');
    
                // Mercredi
                const wednesdayDateString = currentDate.toISOString().split('T')[0];
                const wednesdayCell = document.createElement('td');
                wednesdayCell.textContent = formatFrenchDate(wednesdayDateString);
    
                const wednesdayDescCell = document.createElement('td');
                if (isHoliday(wednesdayDateString)) {
                    wednesdayDescCell.textContent = holidays[wednesdayDateString];
                    wednesdayCell.classList.add('holiday');
                    wednesdayDescCell.classList.add('holiday');
                } else if (isInVacation(wednesdayDateString)) {
                    wednesdayDescCell.textContent = getVacationName(wednesdayDateString);
                    row.classList.add('vacation');
                } else {
                    wednesdayDescCell.textContent = sessions[sessionIndex] || 'Séance à définir';
                    sessionIndex++;
                }

                // Mise en évidence du jour actuel
                if (isToday(wednesdayDateString)) {
                    wednesdayCell.classList.add('today');
                    wednesdayDescCell.classList.add('today');
                }
    
                // Jeudi
                currentDate.setDate(currentDate.getDate() + 1);  // Jeudi
                const thursdayDateString = currentDate.toISOString().split('T')[0];
                const thursdayCell = document.createElement('td');
                thursdayCell.textContent = formatFrenchDate(thursdayDateString);
    
                const thursdayDescCell = document.createElement('td');
                if (isHoliday(thursdayDateString)) {
                    thursdayDescCell.textContent = holidays[thursdayDateString];
                    thursdayCell.classList.add('holiday');
                    thursdayDescCell.classList.add('holiday');
                } else if (isInVacation(thursdayDateString)) {
                    thursdayDescCell.textContent = getVacationName(thursdayDateString);
                    row.classList.add('vacation');
                } else {
                    thursdayDescCell.textContent = sessions[sessionIndex] || 'Séance à définir';
                    sessionIndex++;
                }

                // Mise en évidence du jour actuel
                if (isToday(thursdayDateString)) {
                    thursdayCell.classList.add('today');
                    thursdayDescCell.classList.add('today');
                }
    
                // Vendredi
                currentDate.setDate(currentDate.getDate() + 1);  // Vendredi
                const fridayDateString = currentDate.toISOString().split('T')[0];
                const fridayCell = document.createElement('td');
                fridayCell.textContent = formatFrenchDate(fridayDateString);
    
                const fridayDescCell = document.createElement('td');
                if (isHoliday(fridayDateString)) {
                    fridayDescCell.textContent = holidays[fridayDateString];
                    fridayCell.classList.add('holiday');
                    fridayDescCell.classList.add('holiday');
                } else if (isInVacation(fridayDateString)) {
                    fridayDescCell.textContent = getVacationName(fridayDateString);
                    row.classList.add('vacation');
                } else {
                    fridayDescCell.textContent = sessions[sessionIndex] || 'Séance à définir';
                    sessionIndex++;
                }

                // Mise en évidence du jour actuel
                if (isToday(fridayDateString)) {
                    fridayCell.classList.add('today');
                    fridayDescCell.classList.add('today');
                }
    
                // // Mettre en évidence la semaine en cours
                // if (isCurrentWeek(currentDate)) {
                //     row.classList.add('current-week');
                // }
    
                // Ajout des cellules à la ligne
                row.appendChild(wednesdayCell);
                row.appendChild(wednesdayDescCell);
                row.appendChild(thursdayCell);
                row.appendChild(thursdayDescCell);
                row.appendChild(fridayCell);
                row.appendChild(fridayDescCell);
                calendarBody.appendChild(row);
    
                // Passer au mercredi suivant
                currentDate.setDate(currentDate.getDate() + 5);
            }
        }
    
        // Générer le calendrier au chargement de la page
        generateCalendar();    

        // Toggle menu visibility
        function toggleMenu() {
            const menu = document.getElementById("session-nav");
            menu.style.display = menu.style.display === "block" ? "none" : "block";
        }

        // Show selected session content
        function showSession(sessionId) {
            const sessions = document.querySelectorAll('.content-section');
            sessions.forEach(session => {
                session.classList.remove('active');
                if (session.id === sessionId) {
                    session.classList.add('active');
                }
            });

            // Mettre en évidence la séance active dans le menu
            const menuLinks = document.querySelectorAll('#session-nav a');
            menuLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('onclick').includes(sessionId)) {
                    link.classList.add('active');
                }
            });
        }

        // Display the first session by default when page loads
        document.addEventListener('DOMContentLoaded', () => {
            showSession('session1');
        });
    </script>

</body>
</html>
