<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programme NSI Tle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Calibri, sans-serif;
        }

        body {
            line-height: 1.6;
            background-color: #f4f4f4;
        }

        header {
            background-color: #4CAF50;
            color: white;
            text-align: center;
            padding: 1rem;
        }

        main {
            margin-left: 200px;
            padding: 20px;
            min-height: 80vh;
        }

        a{
            color: black;
        }

        a:hover{
            color: orange;
        }

        .content-section {
            display: none;
        }

        .content-section.active {
            display: block;
        }

        aside {
            position: fixed;
            left: 0;
            top: 0;
            height: 100%;
            width: 200px;
            background-color: #333;
            color: white;
            padding-top: 20px;
            transition: width 0.3s ease;
            overflow-y: auto;
            scrollbar-width: none; /* Masque la barre de défilement pour Firefox */
        }

        aside::-webkit-scrollbar {
            display: none; /* Masque la barre de défilement pour Chrome, Safari, et Opera */
        }

        aside ul {
            list-style: none;
            padding: 0;
        }

        aside ul li {
            padding: 10px;
        }

        aside ul li a {
            color: white;
            text-decoration: none;
            display: block;
            padding: 10px;
        }

        /* Style pour l'élément de menu actif (séance en cours) */
        aside ul li a.active {
            background-color: #4CAF50; /* Couleur pour l'élément actif */
            color: white;
            font-weight: bold;
        }

        aside ul li a:hover {
            background-color: #555;
        }

        .hamburger {
            background-color: #4CAF50;
            color: white;
            border: none;
            width: 100%;
            padding: 15px;
            text-align: left;
            cursor: pointer;
        }

        footer {
            background-color: #4CAF50;
            color: white;
            text-align: center;
            padding: 10px 0;
            position: fixed;
            bottom: 0;
            width: 100%;
        }

        h2, h3, h4, h5{
            text-align: center;
        }

        h2 {
            color: #333;
            margin-bottom: 15px;
        }

        h4, h5, p, ul{
            margin-top: 10px;
            margin-bottom: 10px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }

        table, th, td {
            border: 1px solid black;
        }

        th, td {
            padding: 10px;
            text-align: center;
        }

        img {
            max-width: 100%;
            height: auto;
        }

        /* Styles spécifiques pour le calendrier */
        table.calendar {
            margin: 20px auto;
            border-collapse: collapse;
            width: 80%;
        }

        th, td {
            padding: 10px;
            text-align: center;
            border: 1px solid #ccc;
        }

        .current-week {
            background-color: #add8e6; /* Couleur bleue clair pour la semaine en cours */
        }

        pre{
            background-color: black;
            color: white;
        }

        .today {
            background-color: #007BFF; /* Bleu vif pour le jour actuel */
            color: white; /* Texte blanc pour le contraste */
        }

        .vacation {
            background-color: #B2E4A6; /* Vert pastel pour les vacances */
            color: black; /* Texte noir ou foncé pour la lisibilité */
        }

        .holiday {
            background-color: #FF6B6B; /* Rouge clair pour les jours fériés */
            color: white; /* Texte blanc ou clair */
        }

        iframe{
            width: 87vw;
            height: 42vw;
        }

        .rep {
            visibility: hidden;
        }
    </style>
</head>
<body>

    <header>
        <h1>Programme NSI Tle</h1>
    </header>

    <!-- Menu hamburger sur la gauche -->
    <aside id="menu">
        <button class="hamburger" onclick="toggleMenu()">☰ Menu</button>
        <nav id="session-nav">
            <ul>
                <!-- PROGRAMME -->
                <!-- <li><a href="#" onclick="showSession('programme-nsi')">Programme de l'année</a></li> -->

                <!-- CALENDRIER -->
                <li><a href="#" onclick="showSession('calendar')">Calendrier de cours</a></li>

                <!-- Actus -->
                <!-- <li><a href="#" onclick="showSession('session0')">Actus</a></li> -->

                <!-- Ressources -->
                <li><a href="#" onclick="showSession('session0')">Ressources</a></li>

                <!-- Révisions -->
                <li><a href="#" onclick="showSession('revision')">Pour réviser</a></li>

                <!-- Programme potentiel 1
                <li><a href="#" onclick="showSession('programme1')">Programme potentiel 1</a></li>

                Programme potentiel 2
                <li><a href="#" onclick="showSession('programme2')">Programme potentiel 2</a></li> -->

                <!-- Programme potentiel 1 : Jeux vidéos -->
                <li><a href="#" onclick="showSession('programme1')">Programme potentiel Jeux vidéos</a></li>

                <!-- Programme potentiel 2 : Application de gestion de budget -->
                <li><a href="#" onclick="showSession('programme2')">Programme potentiel Application de gestion de budget</a></li>

                <!-- Programme potentiel 3 : Application de gestion de mangas -->
                <li><a href="#" onclick="showSession('programme3')">Programme potentiel Application de gestion de mangas</a></li>

                <!-- Programme potentiel 4 : Site Web -->
                <li><a href="#" onclick="showSession('programme4')">Programme potentiel Site Web</a></li>

                <!-- COURS
                <li><a href="#" onclick="showSession('session1')">Séance 1 : Introduction à la récursivité (concepts de base)</a></li>
                <li><a href="#" onclick="showSession('session2')">Séance 2 : Pratique - Implémentation d’une fonction récursive pour calculer une suite mathématique</a></li>
                <li><a href="#" onclick="showSession('session3')">Séance 3 : Applications pratiques de la récursivité (problèmes simples)</a></li>
                <li><a href="#" onclick="showSession('session4')">Séance 4 : Introduction aux Algorithmes de Recherche Récursive – Recherche Binaire</a></li>
                <li><a href="#" onclick="showSession('session5')">Séance 5 : Pratique – Recherche d’un Personnage de Manga avec un Algorithme de Recherche Binaire</a></li>
                <li><a href="#" onclick="showSession('session6')">Séance 6 : Analyse de la Complexité d’un Algorithme de Recherche Récursive</a></li>
                <li><a href="#" onclick="showSession('session7')">Séance 7 : Introduction au Backtracking (Concepts de Base)</a></li>
                <li><a href="#" onclick="showSession('session8')">Séance 8 : Pratique - Résolution d'un Labyrinthe avec Backtracking (Jeu Vidéo)</a></li>
                <li><a href="#" onclick="showSession('session9')">Séance 9 : Étude des Cas Où le Backtracking Est Utile et de Ses Limitations</a></li>
                <li><a href="#" onclick="showSession('session10')">Séance 10 : Introduction à la Complexité Algorithmique – Notation Big-O</a></li>
                <li><a href="#" onclick="showSession('session11')">Séance 11 : Pratique - Comparaison des Algorithmes de Tri Simples (Insertion, Sélection)</a></li>
                <li><a href="#" onclick="showSession('session12')">Séance 12 : Exercices d’Analyse de la Complexité des Algorithmes dans des Jeux Vidéo et la Vie Réelle</a></li>
                <li><a href="#" onclick="showSession('session13')">Séance 13 : Introduction aux Graphes et à leurs Applications</a></li>
                <li><a href="#" onclick="showSession('session14')">Séance 14 : Pratique - Représentation d'un Réseau de Routes dans un Jeu Vidéo avec des Graphes</a></li>
                <li><a href="#" onclick="showSession('session15')">Séance 15 : Algorithmes de Parcours de Graphes – DFS et BFS</a></li>
                <li><a href="#" onclick="showSession('session16')">Séance 16 : Approfondissement sur l’algorithme DFS (Depth-First Search)</a></li>
                <li><a href="#" onclick="showSession('session17')">Séance 17 : Pratique - Exploration d’un Monde Ouvert (Jeu Vidéo) avec DFS</a></li>
                <li><a href="#" onclick="showSession('session18')">Séance 18 : Applications Réelles des Graphes (Réseaux Sociaux, Chemins dans les Transports)</a></li>
                <li><a href="#" onclick="showSession('session19')">Séance 19 : Introduction aux Arbres Binaires et leurs Applications</a></li>
                <li><a href="#" onclick="showSession('session20')">Séance 20 : Pratique - Utilisation d’arbres pour organiser une base de données de personnages de manga</a></li>
                <li><a href="#" onclick="showSession('session21')">Séance 21 : Algorithmes de Parcours d’Arbres (Pré-ordre, En-ordre, Post-ordre)</a></li>
                <li><a href="#" onclick="showSession('session22')">Séance 22 : Approfondissement sur les Algorithmes de Parcours d’Arbres</a></li>
                <li><a href="#" onclick="showSession('session23')">Séance 23 : Pratique - Création d’un Arbre de Décision pour un Jeu de Rôle (Jeu Vidéo)</a></li>
                <li><a href="#" onclick="showSession('session24')">Séance 24 : Analyse des performances et avantages des arbres dans la recherche et le tri</a></li>
                <li><a href="#" onclick="showSession('session25')">Séance 25 : Introduction au Tri Rapide (Quicksort)</a></li>
                <li><a href="#" onclick="showSession('session26')">Séance 26 : Pratique - Implémentation du Quicksort pour trier des scores de jeu vidéo</a></li>
                <li><a href="#" onclick="showSession('session27')">Séance 27 : Comparaison de la complexité des différents algorithmes de tri</a></li>
                <li><a href="#" onclick="showSession('session28')">Séance 28 : Introduction au tri par tas (Heapsort)</a></li>
                <li><a href="#" onclick="showSession('session29')">Séance 29 : Pratique - Utilisation du Heapsort pour organiser un inventaire dans un jeu vidéo</a></li>
                <li><a href="#" onclick="showSession('session30')">Séance 30 : Analyse de la Complexité du Heapsort et de ses Applications</a></li>
                <li><a href="#" onclick="showSession('session31')">Séance 31 : Introduction au Tri Fusion (Merge Sort)</a></li>
                <li><a href="#" onclick="showSession('session32')">Séance 32 : Pratique - Implémentation du Tri Fusion pour Classer des Mangas par Popularité</a></li>
                <li><a href="#" onclick="showSession('session33')">Séance 33 : Étude comparative des algorithmes de tri avancés (Quicksort, Heapsort, Merge Sort)</a></li>
                <li><a href="#" onclick="showSession('session34')">Séance 34 : Optimisation des Algorithmes de Tri dans des Contextes Réels</a></li>
                <li><a href="#" onclick="showSession('session35')">Séance 35 : Pratique - Choisir et implémenter l’algorithme de tri le plus efficace pour différentes situations</a></li>
                <li><a href="#" onclick="showSession('session36')">Séance 36 : Révision et consolidation des concepts d'algorithmes de tri</a></li>
                <li><a href="#" onclick="showSession('session37')">Séance 37 : Introduction à la Programmation Orientée Objet (POO) – Classes, Objets, Méthodes</a></li>
                <li><a href="#" onclick="showSession('session38')">Séance 38 : Pratique - Modélisation d’un personnage de jeu vidéo en POO</a></li>
                <li><a href="#" onclick="showSession('session39')">Séance 39 : Héritage et Polymorphisme (Théorie)</a></li>
                <li><a href="#" onclick="showSession('session40')">Séance 40 : Pratique - Implémentation d’un Système d’Héritage dans une Application de Gestion de Personnages (Jeu Vidéo)</a></li>
                <li><a href="#" onclick="showSession('session41')">Séance 41 : Introduction aux Design Patterns - Singleton et Factory</a></li>
                <li><a href="#" onclick="showSession('session42')">Séance 42 : Pratique - Utilisation de Design Patterns pour Optimiser la Gestion des Niveaux d’un Jeu Vidéo</a></li>
                <li><a href="#" onclick="showSession('session43')">Séance 43 : Théorie : Encapsulation, accès aux attributs, getters et setters.</a></li>
                <li><a href="#" onclick="showSession('session44')">Séance 44 : Pratique - Gestion d’attributs privés dans une application</a></li>
                <li><a href="#" onclick="showSession('session45')">Séance 45 : Gestion de la mémoire en POO</a></li>
                <li><a href="#" onclick="showSession('session46')">Séance 46 : Optimisation d’une application POO (jeu vidéo)</a></li>
                <li><a href="#" onclick="showSession('session47')">Séance 47 : Pratique - Réorganisation d’un projet pour améliorer l’efficacité et la gestion des ressources</a></li>
                <li><a href="#" onclick="showSession('session48')">Séance 48 : Analyse des performances dans des projets orientés objet</a></li>
                <li><a href="#" onclick="showSession('session49')">Séance 49 : Introduction aux bases de données relationnelles et SQL</a></li>
                <li><a href="#" onclick="showSession('session50')">Séance 50 : Pratique - Création d’une base de données pour gérer des scores de jeu vidéo</a></li>
                <li><a href="#" onclick="showSession('session51')">Séance 51 : Requêtes SQL de base (SELECT, INSERT, UPDATE, DELETE)</a></li>
                <li><a href="#" onclick="showSession('session52')">Séance 52 : Requêtes SQL avancées (JOIN, GROUP BY)</a></li>
                <li><a href="#" onclick="showSession('session53')">Séance 53 : Pratique - Interrogation complexe d'une base de données pour récupérer des données sur les personnages d’un manga</a></li>
                <li><a href="#" onclick="showSession('session54')">Séance 54 : Optimisation des requêtes SQL</a></li>
                <li><a href="#" onclick="showSession('session55')">Séance 55 : Introduction à la normalisation (1NF, 2NF, 3NF)</a></li>
                <li><a href="#" onclick="showSession('session56')">Séance 56 : Pratique - Réorganisation d’une base de données pour une meilleure gestion des données</a></li>
                <li><a href="#" onclick="showSession('session57')">Séance 57 : Cas pratiques de normalisation dans des projets réels (jeu vidéo, actualité)</a></li>
                <li><a href="#" onclick="showSession('session58')">Séance 58 : Introduction à l’indexation et optimisation des bases de données</a></li>
                <li><a href="#" onclick="showSession('session59')">Séance 59 : Pratique - Amélioration de la performance des requêtes SQL avec indexation</a></li>
                <li><a href="#" onclick="showSession('session60')">Séance 60 : Étude de cas sur les performances des bases de données dans un projet</a></li>
                <li><a href="#" onclick="showSession('session61')">Séance 61 : Introduction à la cryptographie (chiffrement symétrique)</a></li>
                <li><a href="#" onclick="showSession('session62')">Séance 62 : Pratique - Implémentation d’un chiffrement simple pour protéger les données d’un jeu vidéo</a></li>
                <li><a href="#" onclick="showSession('session63')">Séance 63 : Algorithmes de chiffrement asymétrique (RSA)</a></li>
                <li><a href="#" onclick="showSession('session64')">Séance 64 : Introduction aux protocoles de sécurité (SSL, HTTPS)</a></li>
                <li><a href="#" onclick="showSession('session65')">Séance 65 : Pratique - Sécurisation des échanges entre un serveur de jeu et un client</a></li>
                <li><a href="#" onclick="showSession('session66')">Séance 66 : Algorithmes de hachage et intégrité des données</a></li>
                <li><a href="#" onclick="showSession('session67')">Séance 67 : Signature numérique et validation de l’intégrité des données</a></li>
                <li><a href="#" onclick="showSession('session68')">Séance 68 : Pratique - Protection des données d’une application de gestion d’actualité</a></li>
                <li><a href="#" onclick="showSession('session69')">Séance 69 : Révision des concepts de sécurité et cryptographie</a></li>
                <li><a href="#" onclick="showSession('session70')">Séance 70 : Introduction aux Architectures Matérielles, fonctionnement du Processeur et des Bus</a></li>
                <li><a href="#" onclick="showSession('session71')">Séance 71 : Introduction aux Systèmes d’Exploitation</a></li>
                <li><a href="#" onclick="showSession('session72')">Séance 72 : Bases de l’Utilisation de Linux</a></li>
                <li><a href="#" onclick="showSession('session73')">Séance 73 : Introduction aux protocoles réseau (TCP, UDP, IP) et modèle OSI</a></li>
                <li><a href="#" onclick="showSession('session74')">Séance 74 : Les adresses IP et le routage</a></li>
                <li><a href="#" onclick="showSession('session75')">Séance 75 : Protocole HTTP et API REST</a></li>
                <li><a href="#" onclick="showSession('session76')"></a></li>
                <li><a href="#" onclick="showSession('session77')"></a></li>
                <li><a href="#" onclick="showSession('session78')"></a></li>
                <li><a href="#" onclick="showSession('session79')"></a></li>
                <li><a href="#" onclick="showSession('session80')"></a></li>
                <li><a href="#" onclick="showSession('session81')"></a></li>
                <li><a href="#" onclick="showSession('session82')"></a></li>
                <li><a href="#" onclick="showSession('session83')"></a></li>
                <li><a href="#" onclick="showSession('session84')"></a></li>
                <li><a href="#" onclick="showSession('session85')"></a></li>
                <li><a href="#" onclick="showSession('session86')"></a></li>
                <li><a href="#" onclick="showSession('session87')"></a></li>
                <li><a href="#" onclick="showSession('session88')"></a></li>
                <li><a href="#" onclick="showSession('session89')"></a></li>
                <li><a href="#" onclick="showSession('session90')"></a></li>
                <li><a href="#" onclick="showSession('session91')"></a></li>
                <li><a href="#" onclick="showSession('session92')"></a></li>
                <li><a href="#" onclick="showSession('session93')"></a></li>
                <li><a href="#" onclick="showSession('session94')"></a></li>
                <li><a href="#" onclick="showSession('session95')"></a></li>
                <li><a href="#" onclick="showSession('session96')"></a></li>
                <li><a href="#" onclick="showSession('session97')"></a></li>
                <li><a href="#" onclick="showSession('session98')"></a></li>
                <li><a href="#" onclick="showSession('session99')"></a></li>
                <li><a href="#" onclick="showSession('session100')"></a></li>
                <li><a href="#" onclick="showSession('session101')"></a></li>
                <li><a href="#" onclick="showSession('session102')"></a></li>
                <li><a href="#" onclick="showSession('session103')"></a></li>
                <li><a href="#" onclick="showSession('session104')"></a></li>
                <li><a href="#" onclick="showSession('session105')"></a></li>
                <li><a href="#" onclick="showSession('session106')"></a></li>
                <li><a href="#" onclick="showSession('session107')"></a></li>
                <li><a href="#" onclick="showSession('session108')"></a></li> -->
            </ul>
        </nav>
    </aside>

    <main id="content">
        <!-- Programme -->
        <!-- <section id="programme-nsi" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Programme Terminale NSI</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 1 : Récursivité</h3>
            <ul>
                <li><strong>Séance 1 :</strong> Introduction à la récursivité (concepts de base).</li>
                <li><strong>Séance 2 :</strong> Pratique - Implémentation d’une fonction récursive pour calculer une suite mathématique.</li>
                <li><strong>Séance 3 :</strong> Applications pratiques de la récursivité (problèmes simples).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 2 : Recherche Récursive</h3>
            <ul>
                <li><strong>Séance 4 :</strong> Introduction aux algorithmes de recherche récursive (recherche binaire).</li>
                <li><strong>Séance 5 :</strong> Pratique - Recherche d’un élément dans une liste de personnages de manga avec un algorithme de recherche binaire.</li>
                <li><strong>Séance 6 :</strong> Analyse de la complexité d'un algorithme de recherche récursive.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 3 : Backtracking</h3>
            <ul>
                <li><strong>Séance 7 :</strong> Introduction au backtracking (concepts de base).</li>
                <li><strong>Séance 8 :</strong> Pratique - Résolution d’un labyrinthe avec backtracking (jeu vidéo).</li>
                <li><strong>Séance 9 :</strong> Étude des cas où le backtracking est utile et de ses limitations.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 4 : Complexité Algorithmique</h3>
            <ul>
                <li><strong>Séance 10 :</strong> Introduction à la complexité algorithmique (notation Big-O).</li>
                <li><strong>Séance 11 :</strong> Pratique - Comparaison des algorithmes de tri simples (insertion, sélection).</li>
                <li><strong>Séance 12 :</strong> Exercices d’analyse de la complexité d’algorithmes dans des jeux vidéos et la vie réelle.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 5 : Structures de Données - Graphes</h3>
            <ul>
                <li><strong>Séance 13 :</strong> Introduction aux graphes et à leurs applications (théorie des graphes).</li>
                <li><strong>Séance 14 :</strong> Pratique - Représentation d'un réseau de routes dans un jeu vidéo avec des graphes.</li>
                <li><strong>Séance 15 :</strong> Algorithmes de parcours de graphes (DFS et BFS).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 6 : Algorithmes de Parcours de Graphes</h3>
            <ul>
                <li><strong>Séance 16 :</strong> Approfondissement sur l’algorithme DFS (Depth-First Search).</li>
                <li><strong>Séance 17 :</strong> Pratique - Exploration d'un monde ouvert (jeu vidéo) avec DFS.</li>
                <li><strong>Séance 18 :</strong> Applications réelles des graphes (réseaux sociaux, chemins dans les transports).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 7 : Arbres Binaires</h3>
            <ul>
                <li><strong>Séance 19 :</strong> Introduction aux arbres binaires et leurs applications.</li>
                <li><strong>Séance 20 :</strong> Pratique - Utilisation d’arbres pour organiser une base de données de personnages de manga.</li>
                <li><strong>Séance 21 :</strong> Algorithmes de parcours d’arbres (pré-ordre, en-ordre, post-ordre).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 8 : Algorithmes sur les Arbres</h3>
            <ul>
                <li><strong>Séance 22 :</strong> Approfondissement sur les algorithmes de parcours d’arbres.</li>
                <li><strong>Séance 23 :</strong> Pratique - Création d’un arbre de décision pour un jeu de rôle (jeu vidéo).</li>
                <li><strong>Séance 24 :</strong> Analyse des performances et avantages des arbres dans la recherche et le tri.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 9 : Algorithmes de Tri Avancés</h3>
            <ul>
                <li><strong>Séance 25 :</strong> Introduction au tri rapide (Quicksort).</li>
                <li><strong>Séance 26 :</strong> Pratique - Implémentation du Quicksort pour trier des scores de jeu vidéo.</li>
                <li><strong>Séance 27 :</strong> Comparaison de la complexité des différents algorithmes de tri.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 10 : Heapsort</h3>
            <ul>
                <li><strong>Séance 28 :</strong> Introduction au tri par tas (Heapsort).</li>
                <li><strong>Séance 29 :</strong> Pratique - Utilisation du Heapsort pour organiser un inventaire dans un jeu vidéo.</li>
                <li><strong>Séance 30 :</strong> Analyse de la complexité du Heapsort et de ses applications.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 11 : Tri Fusion</h3>
            <ul>
                <li><strong>Séance 31 :</strong> Introduction au tri fusion (Merge Sort).</li>
                <li><strong>Séance 32 :</strong> Pratique - Implémentation du tri fusion pour classer des mangas par popularité.</li>
                <li><strong>Séance 33 :</strong> Étude comparative des algorithmes de tri avancés (Quicksort, Heapsort, Merge Sort).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 12 : Optimisation des Algorithmes de Tri</h3>
            <ul>
                <li><strong>Séance 34 :</strong> Optimisation des algorithmes de tri dans des contextes réels.</li>
                <li><strong>Séance 35 :</strong> Pratique - Choisir et implémenter l’algorithme de tri le plus efficace pour différentes situations (jeu vidéo, actualité).</li>
                <li><strong>Séance 36 :</strong> Révision et consolidation des concepts d'algorithmes de tri.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 13 : Programmation Orientée Objet (POO)</h3>
            <ul>
                <li><strong>Séance 37 :</strong> Introduction à la POO (classes, objets, méthodes).</li>
                <li><strong>Séance 38 :</strong> Pratique - Modélisation d’un personnage de jeu vidéo en POO.</li>
                <li><strong>Séance 39 :</strong> Héritage et polymorphisme (théorie).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 14 : Héritage et Polymorphisme</h3>
            <ul>
                <li><strong>Séance 40 :</strong> Pratique - Implémentation d’un système d’héritage dans une application de gestion de personnages (jeu vidéo).</li>
                <li><strong>Séance 41 :</strong> Design patterns (Singleton, Factory).</li>
                <li><strong>Séance 42 :</strong> Pratique - Utilisation de design patterns pour optimiser la gestion des niveaux d’un jeu vidéo.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 36 : Bilan et Clôture</h3>
            <ul>
                <li><strong>Séance 106 :</strong> Bilan de l’année et retour sur les projets.</li>
                <li><strong>Séance 107 :</strong> Clôture et perspectives pour le futur.</li>
                <li><strong>Séance 108 :</strong> Journée de détente (activité créative, jeux de programmation).</li>
            </ul>
        </section> -->

        <!-- Calendrier -->
        <section id="calendar" class="content-section">
            <h2>Calendrier de cours des Tle NSI - 2024/2025</h2>
            <table class="calendar">
                <thead>
                    <tr>
                        <th>Date Mercredi</th>
                        <th>Cours Mercredi</th>
                        <th>Date Jeudi</th>
                        <th>Cours Jeudi</th>
                        <th>Date Vendredi</th>
                        <th>Cours Vendredi</th>
                    </tr>
                </thead>
                <tbody id="calendar-body">
                    <!-- Les lignes du calendrier seront générées ici par JavaScript -->
                </tbody>
            </table>
        </section>

        <!-- Pour réviser -->
        <section id="revision" class="content-section">
            <a href="https://www.annabac.com/terminale-generale/numerique-et-sciences-informatiques-nsi" target="_blank" rel="noopener noreferrer">C'est ici pour réviser</a>
        </section>

        <!-- Programme potentiel 1
        <section id="programme1" class="content-section">
            <h1>Programme annuel Terminale NSI : Création d’un jeu vidéo</h1>

            <h2>Objectif principal :</h2>
            <p>Réaliser un jeu vidéo fonctionnel en fin d’année, intégrant les concepts clés du programme officiel de NSI Terminale, en mettant un accent particulier sur la récursivité, la modularité, les commentaires/docstrings, le travail collaboratif via GitHub, et les tests unitaires.</p>

            <h2>Structure détaillée :</h2>

            <h3>1er Trimestre : Fondations et mécanique du jeu</h3>

            <h4>Module 1 : Architecture matérielle et systèmes (3 semaines)</h4>
            <h5>Objectifs :</h5>
            <ul>
                <li>Comprendre le fonctionnement des architectures matérielles et des systèmes d'exploitation.</li>
                <li>Réaliser des optimisations logicielles pertinentes.</li>
            </ul>
            <h5>Application au jeu vidéo :</h5>
            <ul>
                <li>Étudier comment les performances matérielles influencent les jeux.</li>
                <li>Optimiser des algorithmes simples pour la gestion de ressources.</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>TP : Créer une animation simple où un personnage bouge dans un environnement en fonction d’entrées clavier.</li>
                <li>Discussion sur l’impact du matériel sur le rendu du jeu (latence, FPS).</li>
            </ul>

            <h4>Module 2 : Programmation orientée objet et structuration du code (4 semaines)</h4>
            <h5>Objectifs :</h5>
            <ul>
                <li>Approfondir les notions d'encapsulation, d'héritage et de polymorphisme.</li>
                <li>Concevoir un code modulaire et réutilisable.</li>
            </ul>
            <h5>Application au jeu vidéo :</h5>
            <ul>
                <li>Structurer le jeu en modules indépendants (personnages, ennemis, objets, interface).</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>TP : Créer une classe "Personnage" avec des méthodes (se déplacer, sauter, attaquer) et des sous-classes pour des ennemis.</li>
                <li>Introduction aux commentaires/docstrings : Chaque méthode doit inclure une documentation claire.</li>
                <li>GitHub : Mise en place d’un dépôt GitHub pour versionner le code du jeu.</li>
            </ul>

            <h4>Module 3 : Algorithmique avancée (4 semaines)</h4>
            <h5>Objectifs :</h5>
            <ul>
                <li>Étudier les algorithmes de parcours de graphe et la récursivité.</li>
                <li>Implémenter des solutions optimales pour des problèmes courants.</li>
            </ul>
            <h5>Application au jeu vidéo :</h5>
            <ul>
                <li>Développer une IA de base pour un ennemi qui suit le joueur (algorithme A*).</li>
                <li>Utiliser la récursivité pour résoudre des problèmes dans le jeu (comme la génération de labyrinthes).</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>TP : Générer un labyrinthe récursivement.</li>
                <li>TP : Créer une IA pour un ennemi qui suit le joueur.</li>
                <li>Tests unitaires : Implémenter des tests pour vérifier la validité des algorithmes.</li>
            </ul>

            <h3>2e Trimestre : Interactions, données et interface</h3>

            <h4>Module 4 : Bases de données et gestion de la persistance (5 semaines)</h4>
            <h5>Objectifs :</h5>
            <ul>
                <li>Concevoir et interroger une base de données relationnelle.</li>
                <li>Utiliser une base de données pour la sauvegarde et la persistance.</li>
            </ul>
            <h5>Application au jeu vidéo :</h5>
            <ul>
                <li>Sauvegarder la progression d’un joueur (scores, niveaux atteints, inventaire).</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>TP : Créer une table SQLite pour gérer les scores et afficher un classement.</li>
                <li>Modularité : Intégrer la gestion des scores comme un module indépendant.</li>
                <li>Tests unitaires : Vérifier la robustesse des fonctions d'accès aux données.</li>
            </ul>

            <h4>Module 5 : Interface graphique et interactions utilisateur (5 semaines)</h4>
            <h5>Objectifs :</h5>
            <ul>
                <li>Concevoir des interfaces utilisateurs interactives.</li>
                <li>Intégrer des événements liés à l’interaction humaine.</li>
            </ul>
            <h5>Application au jeu vidéo :</h5>
            <ul>
                <li>Créer une interface utilisateur pour le menu principal, les options, et les instructions.</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>TP : Développer un menu de démarrage interactif.</li>
                <li>Commentaires/docstrings : Documentation obligatoire pour chaque fonction de l’interface.</li>
                <li>GitHub : Collaboration via branches pour développer des fonctionnalités spécifiques.</li>
            </ul>

            <h4>Module 6 : Programmation réseau (4 semaines)</h4>
            <h5>Objectifs :</h5>
            <ul>
                <li>Découvrir les principes des protocoles de communication.</li>
                <li>Concevoir une communication basique entre deux instances de programme.</li>
            </ul>
            <h5>Application au jeu vidéo :</h5>
            <ul>
                <li>Intégrer un mode multijoueur local ou en ligne simple.</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>TP : Faire interagir deux joueurs dans une arène en réseau local.</li>
                <li>Tests unitaires : Vérifier la transmission correcte des données entre deux joueurs.</li>
            </ul>

            <h3>3e Trimestre : Finalisation et intégration</h3>

            <h4>Module 7 : Cybersécurité et protection des données (3 semaines)</h4>
            <h5>Objectifs :</h5>
            <ul>
                <li>Comprendre les enjeux de la sécurité applicative.</li>
                <li>Mettre en place des mesures de sécurité simples dans le jeu.</li>
            </ul>
            <h5>Application au jeu vidéo :</h5>
            <ul>
                <li>Sécuriser les données de sauvegarde et les communications réseau.</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>TP : Ajouter un système de chiffrement pour la sauvegarde des scores.</li>
            </ul>

            <h4>Module 8 : Optimisation, déploiement, et travail collaboratif (3 semaines)</h4>
            <h5>Objectifs :</h5>
            <ul>
                <li>Optimiser les performances du jeu.</li>
                <li>Préparer le jeu pour une diffusion (création d’un exécutable ou hébergement en ligne).</li>
                <li>Collaborer efficacement sur un projet complexe.</li>
            </ul>
            <h5>Application au jeu vidéo :</h5>
            <ul>
                <li>Révision de tous les modules précédents pour améliorer les performances globales.</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>TP : Compiler le jeu en un exécutable.</li>
                <li>GitHub : Validation finale des pull requests et fusion dans la branche principale.</li>
                <li>Documentation finale : Ajout de docstrings pour toutes les classes et fonctions.</li>
            </ul>

            <h3>Projet final (4 semaines)</h3>
            <h5>Objectifs :</h5>
            <ul>
                <li>Travailler par groupes pour assembler tous les éléments créés durant l’année.</li>
                <li>Présenter un jeu fonctionnel en respectant un cahier des charges.</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Les élèves finalisent le jeu.</li>
                <li>Une soutenance est organisée, avec une évaluation de l’originalité, de la technicité, et de la clarté du code/documentation.</li>
            </ul>
        </section>

        Programme potentiel 2
        <section id="programme2" class="content-section">
            <section>
                <h2>1. Introduction aux outils et méthodologies</h2>
                <article>
                    <h3>1.1. Documentation et commentaires</h3>
                    <p><strong>Cours :</strong> Importance des commentaires et des docstrings pour rendre le code lisible et maintenable.</p>
                    <p><strong>Activité :</strong> Ajouter des docstrings à toutes les fonctions dès leur création.</p>
                </article>
                <article>
                    <h3>1.2. Gestion de version avec Git et GitHub</h3>
                    <p><strong>Cours :</strong> Introduction à GitHub : commits, branches, pull requests.</p>
                    <p><strong>Activité :</strong> Mise en place d’un dépôt collaboratif pour le projet.</p>
                </article>
                <article>
                    <h3>1.3. Tests unitaires</h3>
                    <p><strong>Cours :</strong> Introduction aux tests unitaires avec la bibliothèque <code>unittest</code>.</p>
                    <p><strong>Activité :</strong> Écrire des tests pour valider chaque fonctionnalité.</p>
                </article>
            </section>
    
            <section>
                <h2>2. Programmation et algorithmique</h2>
                <article>
                    <h3>2.1. Création du squelette du jeu</h3>
                    <p><strong>Cours :</strong> Bases de Python : boucles, gestion des événements.</p>
                    <p><strong>Activité :</strong> Création d’une fenêtre avec Pygame et boucle principale.</p>
                </article>
                <article>
                    <h3>2.2. Mouvement et interactions</h3>
                    <p><strong>Cours :</strong> Structuration avec des fonctions.</p>
                    <p><strong>Activité :</strong> Ajouter le déplacement d’un personnage.</p>
                </article>
            </section>
    
            <section>
                <h2>3. Modularité</h2>
                <p><strong>Cours :</strong> Organisation en modules pour améliorer la lisibilité et la maintenance.</p>
                <p><strong>Activité :</strong> Refactorisation : création de fichiers comme <code>player.py</code>, <code>enemy.py</code>, etc.</p>
            </section>
    
            <section>
                <h2>4. Structures de données</h2>
                <article>
                    <h3>4.1. Gestion des niveaux</h3>
                    <p><strong>Cours :</strong> Modélisation avec des listes 2D.</p>
                    <p><strong>Activité :</strong> Charger un niveau depuis un fichier texte.</p>
                </article>
                <article>
                    <h3>4.2. Inventaire et score</h3>
                    <p><strong>Cours :</strong> Dictionnaires et manipulation des données.</p>
                    <p><strong>Activité :</strong> Créer un système d’inventaire ou de score.</p>
                </article>
            </section>
    
            <section>
                <h2>5. Récursivité</h2>
                <p><strong>Cours :</strong> Introduction à la récursivité et ses applications.</p>
                <p><strong>Activité :</strong> Implémenter une recherche récursive pour explorer une carte.</p>
            </section>
    
            <section>
                <h2>6. Bases de données</h2>
                <p><strong>Cours :</strong> Introduction à SQLite : création et manipulation de tables.</p>
                <p><strong>Activité :</strong> Implémenter un système de sauvegarde des progressions.</p>
            </section>
    
            <section>
                <h2>7. Interfaces homme-machine (IHM)</h2>
                <p><strong>Cours :</strong> Création de menus interactifs et intégration de graphismes et sons.</p>
                <p><strong>Activité :</strong> Développer un menu principal avec navigation et ajouter des sprites et effets sonores.</p>
            </section>
    
            <section>
                <h2>8. Programmation orientée objet (POO)</h2>
                <article>
                    <h3>8.1. Organisation en classes</h3>
                    <p><strong>Cours :</strong> Encapsulation, héritage, modularité.</p>
                    <p><strong>Activité :</strong> Créer des classes pour le joueur, les ennemis, et les objets interactifs.</p>
                </article>
                <article>
                    <h3>8.2. IA basique</h3>
                    <p><strong>Cours :</strong> Comportements autonomes simples.</p>
                    <p><strong>Activité :</strong> Ajouter un ennemi qui suit le joueur ou patrouille.</p>
                </article>
            </section>
    
            <section>
                <h2>9. Algorithmes de tri</h2>
                <p><strong>Cours :</strong> Présentation des algorithmes de tri (sélection, insertion, fusion, rapide).</p>
                <p><strong>Activité :</strong> Implémenter un tri pour organiser un inventaire ou des scores.</p>
            </section>
    
            <section>
                <h2>10. Intelligence Artificielle (IA)</h2>
                <article>
                    <h3>10.1. Pathfinding</h3>
                    <p><strong>Cours :</strong> Algorithmes de recherche de chemin : A*, Dijkstra.</p>
                    <p><strong>Activité :</strong> Implémenter A* pour permettre aux ennemis de trouver un chemin vers le joueur.</p>
                </article>
                <article>
                    <h3>10.2. Prise de décision</h3>
                    <p><strong>Cours :</strong> Arbres de décision et machines à états finis.</p>
                    <p><strong>Activité :</strong> Ajouter des comportements stratégiques (attaquer, patrouiller).</p>
                </article>
            </section>
    
            <section>
                <h2>11. Projet final et évaluation</h2>
                <p><strong>Cours :</strong> Structuration finale, intégration des modules, optimisation.</p>
                <p><strong>Activité :</strong> Finalisation du jeu, revue de code, présentation lors d’un "Game Showcase".</p>
            </section>
        </section> -->

        <!-- Programme potentiel 1 -->
        <section id="programme1" class="content-section">
            <h2>Objectif Principal</h2>
            <p>Concevoir et développer un jeu vidéo complet.</p>

            <hr>

            <h3>1ère Période : Programmation Avancée, Modularité et Premiers Concepts</h3>
            <h4>Septembre - Octobre</h4>
            <h5>Thèmes abordés :</h5>
            <ul>
                <li>Programmation avancée</li>
                <li>Modularité et mise au point des programmes</li>
                <li>Récursivité</li>
                <li>Paradigmes de programmation</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Introduction au projet annuel : présentation du concept de jeu à développer (par exemple, un jeu de plateforme 2D).</li>
                <li>Élaboration du cahier des charges avec les élèves (gameplay, mécanismes de jeu).</li>
                <li>Initiation à la modularité avec Python : organisation des fichiers et modules du jeu.</li>
                <li>Exercices pratiques sur la récursivité : implémentation de mécanismes simples (ex. système de menus).</li>
                <li>Optimisation du code : réduction des temps de calcul et meilleure organisation.</li>
                <li>Exploration des paradigmes de programmation : programmation impérative, fonctionnelle et orientée objet appliqués à des sous-parties du jeu.</li>
            </ul>
            <h5>Livrable :</h5>
            <ul>
                <li>Premiers modules du jeu (menu principal et écran d’accueil).</li>
                <li>Code initial optimisé.</li>
            </ul>

            <hr>

            <h3>2ème Période : Structures de Données et Bases de Programmation Graphique</h3>
            <h4>Novembre - Décembre</h4>
            <h5>Thèmes abordés :</h5>
            <ul>
                <li>Interface et implémentation des structures de données</li>
                <li>Structures arborescentes</li>
                <li>Graphes</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Implémentation des structures de données pour le jeu (ex. gestion des niveaux ou inventaires).</li>
                <li>Introduction aux structures arborescentes : création d’un système de progression (arbre des niveaux).</li>
                <li>Manipulation des graphes : modélisation de cartes de jeu ou réseaux d'interconnexion (ex. système de téléportation ou ennemis).</li>
                <li>Découverte de Pygame : introduction aux bases du moteur graphique.</li>
            </ul>
            <h5>Livrable :</h5>
            <ul>
                <li>Implémentation des mécanismes de navigation et du système de progression dans le jeu.</li>
                <li>Prototype graphique simple avec Pygame.</li>
            </ul>

            <hr>

            <h3>3ème Période : Conception et Gestion des Bases de Données</h3>
            <h4>Janvier - Février</h4>
            <h5>Thèmes abordés :</h5>
            <ul>
                <li>Conception de bases de données</li>
                <li>Systèmes de gestion de bases de données – SQL</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Conception et modélisation de la base de données du jeu (sauvegarde des scores, gestion des utilisateurs).</li>
                <li>Implémentation avec SQLite et requêtes SQL.</li>
                <li>Intégration de la base de données au projet Python (liaison avec Pygame pour gérer les sauvegardes).</li>
            </ul>
            <h5>Livrable :</h5>
            <ul>
                <li>Système de sauvegarde et chargement des parties.</li>
                <li>Fonctionnalités de gestion de profils joueurs.</li>
            </ul>

            <hr>

            <h3>4ème Période : Systèmes et Communication</h3>
            <h4>Mars - Avril</h4>
            <h5>Thèmes abordés :</h5>
            <ul>
                <li>Composants et processus</li>
                <li>Protocoles de routage et sécurisation des communications</li>
                <li>Programmes et données – Calculabilité</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Exploration des processus et de la concurrence : implémentation de mécanismes de jeu asynchrones (ex. ennemis IA).</li>
                <li>Initiation aux protocoles de communication : système multijoueur basique (local).</li>
                <li>Discussions sur la calculabilité et les limitations des programmes.</li>
            </ul>
            <h5>Livrable :</h5>
            <ul>
                <li>Prototype de fonctionnalité multijoueur local.</li>
                <li>Gestion des interactions concurrentes (ex. plusieurs joueurs simultanément).</li>
            </ul>

            <hr>

            <h3>5ème Période : IA et Finalisation du Projet</h3>
            <h4>Mai</h4>
            <h5>Thèmes abordés :</h5>
            <ul>
                <li>Initiation à l’intelligence artificielle</li>
                <li>Les commentaires et docstrings</li>
                <li>GitHub</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Introduction aux concepts de base de l’IA : algorithmes simples appliqués au jeu (ex. comportements des ennemis).</li>
                <li>Améliorations finales avec Pygame : animations, effets visuels.</li>
                <li>Rédaction de commentaires et docstrings pour une documentation claire.</li>
                <li>Introduction à GitHub : gestion des versions du projet, travail collaboratif.</li>
                <li>Test et validation du jeu par les élèves.</li>
            </ul>
            <h5>Livrable :</h5>
            <ul>
                <li>Jeu final optimisé, bien documenté, et disponible sur un dépôt GitHub.</li>
                <li>Rapport final sur les compétences acquises et bilan du projet.</li>
            </ul>
        </section>

        <!-- Programme potentiel 2 -->
        <section id="programme2" class="content-section">
            <h2>Objectif Principal</h2>
            <p>Concevoir et développer une application Python complète pour gérer les dépenses d’un foyer français.</p>

            <hr>

            <h3>1ère Période : Programmation Avancée, Modularité et Premiers Concepts</h3>
            <h4>Septembre - Octobre</h4>
            <h5>Thèmes abordés :</h5>
            <ul>
                <li>Programmation avancée</li>
                <li>Modularité et mise au point des programmes</li>
                <li>Récursivité</li>
                <li>Paradigmes de programmation</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Introduction au projet annuel : présentation du concept d’application (gestion des dépenses).</li>
                <li>Élaboration du cahier des charges avec les élèves (fonctionnalités principales : suivi des dépenses, gestion des catégories, budget).</li>
                <li>Initiation à la modularité avec Python : organisation des fichiers et modules du projet.</li>
                <li>Exercices pratiques sur la récursivité : implémentation d’algorithmes simples pour le traitement des données.</li>
                <li>Optimisation du code : réduction des temps de calcul et meilleure organisation.</li>
                <li>Exploration des paradigmes de programmation : programmation impérative, fonctionnelle et orientée objet appliqués à des sous-parties du projet.</li>
            </ul>
            <h5>Livrable :</h5>
            <ul>
                <li>Premiers modules de l’application (interface de base et logique métier simple).</li>
                <li>Code initial optimisé.</li>
            </ul>

            <hr>

            <h3>2ème Période : Structures de Données et Interfaces Graphiques</h3>
            <h4>Novembre - Décembre</h4>
            <h5>Thèmes abordés :</h5>
            <ul>
                <li>Interface et implémentation des structures de données</li>
                <li>Conception d’interfaces graphiques (Tkinter)</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Implémentation des structures de données pour gérer les dépenses (ex. dictionnaires pour catégories, listes pour transactions).</li>
                <li>Création de l’interface graphique de base avec Tkinter (ajout, suppression et visualisation des dépenses).</li>
                <li>Interaction entre l’interface graphique et la logique métier.</li>
            </ul>
            <h5>Livrable :</h5>
            <ul>
                <li>Interface fonctionnelle pour gérer les dépenses avec des fonctionnalités de base.</li>
                <li>Visualisation des dépenses par catégorie.</li>
            </ul>

            <hr>

            <h3>3ème Période : Gestion des Bases de Données</h3>
            <h4>Janvier - Février</h4>
            <h5>Thèmes abordés :</h5>
            <ul>
                <li>Conception de bases de données</li>
                <li>Systèmes de gestion de bases de données – SQL</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Conception et modélisation de la base de données pour stocker les transactions et catégories.</li>
                <li>Implémentation avec SQLite et requêtes SQL.</li>
                <li>Intégration de la base de données au projet Python : sauvegarde et chargement des données via l’interface Tkinter.</li>
            </ul>
            <h5>Livrable :</h5>
            <ul>
                <li>Système de sauvegarde et chargement des données de l’application.</li>
                <li>Gestion efficace des transactions et des catégories à partir de la base de données.</li>
            </ul>

            <hr>

            <h3>4ème Période : Analyse, Graphiques et Finalisation</h3>
            <h4>Mars - Avril</h4>
            <h5>Thèmes abordés :</h5>
            <ul>
                <li>Visualisation des données</li>
                <li>Composants et processus</li>
                <li>Protocoles de sécurisation des données</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Ajout de fonctionnalités d’analyse : calcul des dépenses mensuelles, dépassements de budget.</li>
                <li>Création de graphiques (par exemple avec Matplotlib) pour visualiser les dépenses.</li>
                <li>Implémentation de la sécurisation des données : cryptage basique des informations sensibles.</li>
            </ul>
            <h5>Livrable :</h5>
            <ul>
                <li>Application avec visualisation des données (tableaux et graphiques).</li>
                <li>Système sécurisé pour les données sensibles.</li>
            </ul>

            <hr>

            <h3>5ème Période : Documentation et Présentation</h3>
            <h4>Mai</h4>
            <h5>Thèmes abordés :</h5>
            <ul>
                <li>Les commentaires et docstrings</li>
                <li>GitHub</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Rédaction de commentaires et docstrings pour une documentation claire et complète.</li>
                <li>Introduction à GitHub : gestion des versions du projet, travail collaboratif.</li>
                <li>Préparation de la présentation finale : test et validation de l’application.</li>
            </ul>
            <h5>Livrable :</h5>
            <ul>
                <li>Application finalisée, bien documentée, et disponible sur un dépôt GitHub.</li>
                <li>Rapport final sur les compétences acquises et bilan du projet.</li>
            </ul>
        </section>

        <!-- Programme potentiel 3 -->
        <section id="programme3" class="content-section">
            <h2>Objectif Principal</h2>
            <p>Concevoir et développer une application Python complète pour gérer les épisodes de mangas vus, ceux qu’il reste à voir, ainsi que les chapitres de mangas lus et ceux qu’il reste à lire.</p>

            <hr>

            <h3>1ère Période : Programmation Avancée, Modularité et Premiers Concepts</h3>
            <h4>Septembre - Octobre</h4>
            <h5>Thèmes abordés :</h5>
            <ul>
                <li>Programmation avancée</li>
                <li>Modularité et mise au point des programmes</li>
                <li>Récursivité</li>
                <li>Paradigmes de programmation</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Introduction au projet annuel : présentation du concept d’application à développer (gestion des épisodes et chapitres de mangas).</li>
                <li>Élaboration du cahier des charges avec les élèves (fonctionnalités principales : ajout, suivi, et statistiques).</li>
                <li>Initiation à la modularité avec Python : organisation des fichiers et modules de l’application.</li>
                <li>Exercices pratiques sur la récursivité : implémentation de mécanismes simples (ex. navigation entre listes d’épisodes et chapitres).</li>
                <li>Optimisation du code : réduction des temps de calcul et meilleure organisation.</li>
                <li>Exploration des paradigmes de programmation : programmation impérative, fonctionnelle et orientée objet appliqués à des sous-parties de l’application.</li>
            </ul>
            <h5>Livrable :</h5>
            <ul>
                <li>Premiers modules de l’application (menu principal et écran d’accueil).</li>
                <li>Code initial optimisé.</li>
            </ul>

            <hr>

            <h3>2ème Période : Structures de Données et Interfaces Graphiques</h3>
            <h4>Novembre - Décembre</h4>
            <h5>Thèmes abordés :</h5>
            <ul>
                <li>Interface et implémentation des structures de données</li>
                <li>Structures arborescentes</li>
                <li>Graphes</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Implémentation des structures de données pour l’application (ex. gestion des séries de mangas, épisodes, et chapitres).</li>
                <li>Introduction aux structures arborescentes : création d’un système de classification des séries par genre ou statut.</li>
                <li>Manipulation des graphes : modélisation des relations entre épisodes ou chapitres (ex. arcs pour progression ou dépendances).</li>
                <li>Introduction à tkinter : création de fenêtres et composants graphiques basiques.</li>
            </ul>
            <h5>Livrable :</h5>
            <ul>
                <li>Interfaces graphiques simples pour la saisie et la visualisation des données.</li>
                <li>Implémentation des mécanismes de navigation dans l’application.</li>
            </ul>

            <hr>

            <h3>3ème Période : Conception et Gestion des Bases de Données</h3>
            <h4>Janvier - Février</h4>
            <h5>Thèmes abordés :</h5>
            <ul>
                <li>Conception de bases de données</li>
                <li>Systèmes de gestion de bases de données – SQL</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Conception et modélisation de la base de données de l’application (sauvegarde des épisodes vus, chapitres lus, statistiques).</li>
                <li>Implémentation avec SQLite et requêtes SQL.</li>
                <li>Intégration de la base de données au projet Python (liaison avec tkinter pour afficher et mettre à jour les données).</li>
            </ul>
            <h5>Livrable :</h5>
            <ul>
                <li>Système de sauvegarde et affichage des données.</li>
                <li>Fonctionnalités de gestion de l’historique des épisodes et chapitres.</li>
            </ul>

            <hr>

            <h3>4ème Période : Systèmes, IA et Finalisation</h3>
            <h4>Mars - Mai</h4>
            <h5>Thèmes abordés :</h5>
            <ul>
                <li>Composants et processus</li>
                <li>Protocoles de routage et sécurisation des communications</li>
                <li>Initiation à l’intelligence artificielle</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Exploration des processus et de la concurrence : implémentation de mécanismes d’analyse en temps réel (ex. progression des séries en direct).</li>
                <li>Discussions sur la sécurisation des données : cryptage des données sensibles (ex. profils utilisateurs).</li>
                <li>Introduction aux concepts de base de l’IA : algorithmes simples pour analyser les préférences de l’utilisateur (ex. recommandations de séries).</li>
                <li>Améliorations finales avec tkinter : ajout d’animations ou d’effets visuels pour l’interface.</li>
            </ul>
            <h5>Livrable :</h5>
            <ul>
                <li>Application finale prête à être utilisée.</li>
                <li>Documentation complète et dépôt GitHub avec gestion des versions.</li>
            </ul>
        </section>

        <!-- Programme potentiel 4 -->
        <section id="programme4" class="content-section">
            <h2>Objectif Principal</h2>
            <p>Concevoir et développer un site web complet en Python.</p>

            <hr>

            <h3>1ère Période : Programmation Avancée, Modularité et Premiers Concepts</h3>
            <h4>Septembre - Octobre</h4>
            <h5>Thèmes abordés :</h5>
            <ul>
                <li>Programmation avancée</li>
                <li>Modularité et mise au point des programmes</li>
                <li>Récursivité</li>
                <li>Paradigmes de programmation</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Introduction au projet annuel : création d’un site web pour gérer un contenu spécifique (par exemple, un gestionnaire de ressources éducatives).</li>
                <li>Élaboration du cahier des charges avec les élèves (pages principales, fonctionnalités de base).</li>
                <li>Initiation à la modularité avec Python : organisation des fichiers et modules Flask.</li>
                <li>Exercices pratiques sur la récursivité : implémentation d’un algorithme de navigation dans des catégories ou sous-menus.</li>
                <li>Exploration des paradigmes de programmation : application des principes au backend Flask.</li>
            </ul>
            <h5>Livrable :</h5>
            <ul>
                <li>Structure de base du site web (routes principales, navigation).</li>
                <li>Modules Flask organisés pour les différentes fonctionnalités.</li>
            </ul>

            <hr>

            <h3>2ème Période : Structures de Données et Interfaces Web</h3>
            <h4>Novembre - Décembre</h4>
            <h5>Thèmes abordés :</h5>
            <ul>
                <li>Interface et implémentation des structures de données</li>
                <li>Structures arborescentes</li>
                <li>Graphes</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Implémentation des structures de données pour le site (ex. gestion de listes ou bases de données temporaires).</li>
                <li>Introduction aux structures arborescentes : création d’un système de navigation basé sur une hiérarchie (ex. catégories, sous-catégories).</li>
                <li>Manipulation des graphes : modélisation des relations entre les données (ex. liens entre articles ou ressources).</li>
                <li>Création d’interfaces web basiques avec HTML, CSS, et intégration dans Flask.</li>
            </ul>
            <h5>Livrable :</h5>
            <ul>
                <li>Navigation fonctionnelle avec des données dynamiques générées par Flask.</li>
                <li>Structuration claire des pages et interactions utilisateur.</li>
            </ul>

            <hr>

            <h3>3ème Période : Conception et Gestion des Bases de Données</h3>
            <h4>Janvier - Février</h4>
            <h5>Thèmes abordés :</h5>
            <ul>
                <li>Conception de bases de données</li>
                <li>Systèmes de gestion de bases de données – SQL</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Conception et modélisation de la base de données pour le site (ex. gestion des utilisateurs, des ressources).</li>
                <li>Implémentation avec SQLite et requêtes SQL pour gérer les données du site.</li>
                <li>Intégration de la base de données avec Flask : création de fonctionnalités CRUD (Create, Read, Update, Delete).</li>
            </ul>
            <h5>Livrable :</h5>
            <ul>
                <li>Base de données fonctionnelle intégrée au site.</li>
                <li>Pages web permettant de gérer les données de manière dynamique.</li>
            </ul>

            <hr>

            <h3>4ème Période : Systèmes, IA et Finalisation</h3>
            <h4>Mars - Mai</h4>
            <h5>Thèmes abordés :</h5>
            <ul>
                <li>Composants et processus</li>
                <li>Protocoles de routage et sécurisation des communications</li>
                <li>Initiation à l’intelligence artificielle</li>
            </ul>
            <h5>Activités :</h5>
            <ul>
                <li>Implémentation de fonctionnalités avancées : gestion des processus pour les tâches asynchrones.</li>
                <li>Discussions sur la sécurisation des communications : introduction au HTTPS, gestion des utilisateurs et mots de passe avec Flask.</li>
                <li>Introduction aux concepts de base de l’IA : algorithmes simples pour personnaliser le contenu (ex. recommandations basées sur les données utilisateurs).</li>
                <li>Améliorations finales avec Flask : gestion des erreurs, optimisation des performances.</li>
            </ul>
            <h5>Livrable :</h5>
            <ul>
                <li>Site web complet, incluant les fonctionnalités de personnalisation et de sécurité.</li>
                <li>Documentation complète et dépôt GitHub avec gestion des versions.</li>
            </ul>
        </section>

        <!-- <section id="session0" class="content-section">
            <iframe src="../pass_ton_hack.pdf" frameborder="0"></iframe>
        </section> -->

        <section id="session0" class="content-section">
            <iframe src="../Python par les jeux.pdf" frameborder="0"></iframe>
        </section>

        <!-- Cours -->
        <section id="session1" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 1 : Introduction à la Récursivité (Concepts de Base)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectifs de la séance :</h3>
            <ul>
                <li>Comprendre le concept de récursivité (cas de base et cas récursif).</li>
                <li>Savoir identifier et écrire des fonctions récursives.</li>
                <li>Appliquer la récursivité dans un problème lié aux jeux vidéo.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte : Sauver le héros d’un labyrinthe</h3>
            <p>L’objectif est d'aider un héros à sortir d’un labyrinthe en utilisant la récursivité. Chaque étape dans le labyrinthe représente une décision à prendre pour avancer ou reculer. Le labyrinthe est un tableau 2D où chaque cellule peut être un mur, un chemin ou la sortie.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Introduction au concept de récursivité</h3>
            <p>Qu’est-ce que la récursivité ?</p>
            <p>Une fonction récursive est une fonction qui s'appelle elle-même pour résoudre une version plus simple d’un problème.</p>
        
            <p>Une fonction récursive suit deux règles :</p>
            <ul>
                <li><strong>Cas de base :</strong> Condition d’arrêt pour éviter que la fonction ne s'appelle indéfiniment.</li>
                <li><strong>Cas récursif :</strong> Un appel à la fonction elle-même avec une version réduite du problème.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple simple : La Factorielle</h4>
            <pre><code>
    def factorielle(n):
        if n == 0:  # Cas de base
            return 1
        else:
            return n * factorielle(n - 1)  # Cas récursif
            </code></pre>
        
            <p>Explication du fonctionnement :</p>
            <p>Si <code>n = 3</code>, la fonction va appeler <code>factorielle(2)</code>, puis <code>factorielle(1)</code>, puis <code>factorielle(0)</code> qui est le cas de base, et renverra le résultat en remontant.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Application : Sauver un Héros Coincé dans un Labyrinthe</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Problème</h4>
            <p>Le héros est piégé dans un labyrinthe modélisé par une grille 2D. Il peut se déplacer à gauche, à droite, en haut ou en bas. L'objectif est de trouver la sortie (marquée par un "E") en utilisant une approche récursive.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Modélisation du labyrinthe</h4>
            <p>Nous représentons le labyrinthe comme une liste de listes en Python :</p>
        
            <pre><code>
    labyrinthe = [
        ['S', 1, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0]
    ]
            </code></pre>
        
            <ul>
                <li><strong>'S' :</strong> Point de départ (start).</li>
                <li><strong>'E' :</strong> Sortie.</li>
                <li><strong>0 :</strong> Chemin libre.</li>
                <li><strong>1 :</strong> Mur.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exploration récursive du labyrinthe</h4>
            <p>Le héros doit explorer toutes les directions possibles. Pour cela, nous allons créer une fonction récursive qui essaie toutes les directions (haut, bas, gauche, droite).</p>
        
            <pre><code>
    def explorer_labyrinthe(labyrinthe, x, y, visitees):
        # Vérifier les limites du labyrinthe
        if x < 0 or x >= len(labyrinthe) or y < 0 or y >= len(labyrinthe[0]):
            return False
        
        # Vérifier si la case est un mur ou déjà visitée
        if labyrinthe[x][y] == 1 or (x, y) in visitees:
            return False
        
        # Si on a trouvé la sortie
        if labyrinthe[x][y] == 'E':
            print(f"Sortie trouvée à la position ({x}, {y})")
            return True
        
        # Marquer la case comme visitée
        visitees.add((x, y))
        
        # Appeler la fonction récursive dans les 4 directions
        if (explorer_labyrinthe(labyrinthe, x+1, y, visitees) or  # Bas
            explorer_labyrinthe(labyrinthe, x-1, y, visitees) or  # Haut
            explorer_labyrinthe(labyrinthe, x, y+1, visitees) or  # Droite
            explorer_labyrinthe(labyrinthe, x, y-1, visitees)):   # Gauche
            return True
        
        # Si aucune direction ne fonctionne, on retourne False
        return False
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Explication du Code</h4>
            <ul>
                <li><strong>Cas de base :</strong> Si le héros sort du labyrinthe ou rencontre un mur (<code>1</code>), la fonction retourne <code>False</code>. Si le héros atteint la sortie (<code>'E'</code>), la fonction retourne <code>True</code>.</li>
                <li><strong>Cas récursif :</strong> Le héros essaie chaque direction (bas, haut, gauche, droite) en appelant la fonction récursive pour continuer à explorer le labyrinthe.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Mise en Pratique</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Tester l’exploration du labyrinthe</h4>
            <p>Les élèves doivent modifier et exécuter la fonction pour que le héros puisse trouver la sortie.</p>
        
            <pre><code>
    # Position de départ (0, 0)
    position_depart = (0, 0)
    
    # Ensemble des cases visitées
    cases_visitees = set()
    
    # Lancer la recherche de la sortie
    explorer_labyrinthe(labyrinthe, position_depart[0], position_depart[1], cases_visitees)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Améliorations</h4>
            <ul>
                <li><strong>Marquer le chemin parcouru :</strong> Ajouter une fonctionnalité pour afficher le chemin que le héros a pris jusqu'à la sortie.</li>
                <li><strong>Compter les mouvements :</strong> Ajouter un compteur pour afficher combien de mouvements le héros a effectués avant de trouver la sortie.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Conclusion et Récapitulatif</h3>
        
            <p><strong>Ce qu’ils ont appris :</strong></p>
            <ul>
                <li>Comprendre les concepts de récursivité avec un cas de base et un cas récursif.</li>
                <li>Appliquer la récursivité pour résoudre des problèmes complexes, comme un labyrinthe.</li>
            </ul>
        
            <p><strong>Défis à venir :</strong></p>
            <ul>
                <li>D'autres applications de la récursivité dans les jeux vidéo et les structures de données (arbres, tri récursif).</li>
                <li>Combiner récursivité et optimisations (mémoïsation) pour rendre les algorithmes plus efficaces.</li>
            </ul>
        </section>

        <section id="session2" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 2 : Pratique - Implémentation d’une Fonction Récursive pour Calculer une Suite Mathématique</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif :</h3>
            <ul>
                <li>Comprendre et implémenter une fonction récursive.</li>
                <li>Appliquer la récursivité pour résoudre un problème pratique, inspiré des mécanismes de jeux vidéo.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte :</h3>
            <p>Dans un jeu vidéo, un personnage accumule des points d'attaque supplémentaires au fil du temps à chaque coup porté à l'ennemi, mais les points bonus diminuent à chaque itération jusqu'à atteindre un seuil minimum. Cela peut être représenté par une suite mathématique où le bonus d'attaque à chaque coup est calculé récursivement.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple Concret :</h4>
            <p>Le personnage gagne 10 points d'attaque lors du premier coup, puis le bonus diminue de 1 point à chaque coup suivant. Cela forme une série mathématique décrite par :</p>
            <pre><code>Attaque(n) = Attaque(n−1) + (bonus initial − n)</code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 1 : Introduction à la Récursivité</h3>
            <p><strong>Concept de la récursivité :</strong></p>
            <p>Une fonction récursive s'appelle elle-même pour résoudre un problème plus simple à chaque étape, jusqu'à atteindre une condition de fin (ou cas de base).</p>
            
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple théorique :</h4>
            <p>Calcul de la suite de Fibonacci ou de la factorielle pour illustrer la récursivité.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 2 : Implémentation d'une Fonction Récursive</h3>
            <p><strong>Problème :</strong> Dans le jeu, à chaque attaque, le personnage accumule des points bonus. Le premier coup ajoute 10 points, puis chaque coup suivant ajoute 1 point de moins que le précédent jusqu'à atteindre 0. L'objectif est de calculer combien de points d'attaque sont accumulés après un certain nombre de coups.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Fonction récursive pour calculer le bonus d'attaque :</h4>
            <pre><code>
    def attaque_bonus(n):
        # Cas de base : quand le bonus atteint 0
        if n == 0:
            return 0
        else:
            # Récursion : bonus initial (10) - n + bonus précédent
            return (10 - n) + attaque_bonus(n - 1)
    
    # Exemple d'utilisation :
    coups = 5  # Le personnage donne 5 coups
    total_bonus = attaque_bonus(coups)
    print(f"Le total des points d'attaque après {coups} coups est de : {total_bonus}")
            </code></pre>
        
            <p><strong>Explication :</strong></p>
            <ul>
                <li>La fonction se base sur un cas de base où aucun coup n'est porté (0 bonus).</li>
                <li>À chaque appel récursif, le nombre de coups diminue de 1, et le bonus est calculé en fonction du coup précédent.</li>
                <li>Le bonus d’attaque diminue jusqu'à ce que la fonction atteigne le cas de base (0).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 3 : Étendre la Fonctionnalité</h3>
            <p>Amélioration du jeu : Proposer aux élèves d’ajouter des conditions supplémentaires :</p>
            <ul>
                <li>Le bonus ne peut pas descendre en dessous de 0.</li>
                <li>Ajouter un effet multiplicateur pour chaque coup critique (par exemple, multiplier par 2 si c’est un coup critique).</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple d’amélioration :</h4>
            <pre><code>
    def attaque_bonus(n, critique=False):
        if n == 0:
            return 0
        else:
            bonus = (10 - n)  # Le bonus diminue avec chaque coup
            if critique and n % 3 == 0:
                bonus *= 2  # Coup critique tous les 3 coups
            return bonus + attaque_bonus(n - 1, critique)
    
    # Exemple d'utilisation :
    coups = 5
    total_bonus = attaque_bonus(coups, critique=True)
    print(f"Le total des points d'attaque avec coups critiques est de : {total_bonus}")
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 4 : Exercices Pratiques</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Calcul d'attaque simple :</h4>
            <p>Modifier le nombre de coups portés et afficher le total des points d'attaque.</p>
            <p><strong>Exercice :</strong> Demander aux élèves de tester avec 3, 5 et 10 coups pour voir comment la récursivité calcule le total.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">2. Scénario avancé : Combats de boss :</h4>
            <p>Simuler un combat contre un boss où chaque coup critique donne des points bonus supplémentaires.</p>
            <p><strong>Exercice :</strong> Les élèves doivent implémenter une version du programme où tous les 5 coups, le personnage inflige un coup critique (multiplication du bonus par 3).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion</h3>
            <p><strong>Retour sur la notion de récursivité :</strong></p>
            <ul>
                <li><strong>Avantage :</strong> La récursivité permet de simplifier des calculs répétitifs en divisant le problème en sous-problèmes.</li>
                <li><strong>Inconvénient :</strong> Elle peut entraîner des problèmes de performance si elle est mal utilisée (pile d'appels récursifs trop grande).</li>
            </ul>
        
            <p><strong>Lien avec le jeu vidéo :</strong> La récursivité est un outil puissant pour modéliser des mécanismes de jeu où des actions répétitives évoluent à chaque itération, comme la gestion des dégâts dans les combats.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice final :</h4>
            <p>Les élèves devront créer une version améliorée de la fonction récursive qui inclut plusieurs types de coups (coup normal, coup critique, coup spécial) avec des bonus différents et implémenter une stratégie pour battre un boss avec un nombre limité de coups.</p>
        </section>

        <section id="session3" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 3 : Applications Pratiques de la Récursivité - Problèmes Simples</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectifs de la séance :</h3>
            <ul>
                <li>Comprendre la récursivité à travers des exemples simples.</li>
                <li>Appliquer la récursivité pour résoudre des problèmes inspirés des jeux vidéo.</li>
                <li>Créer des programmes interactifs et ludiques en utilisant la récursivité.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Rappel des concepts de base de la récursivité</h3>
            <p><strong>Cas de base :</strong> Condition qui permet d'arrêter la récursivité.</p>
            <p><strong>Cas récursif :</strong> La fonction qui s'appelle elle-même avec une version simplifiée du problème.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple théorique :</h4>
            <p>Calcul de la factorielle d’un nombre.</p>
            <pre><code>
    def factorielle(n):
        if n == 0:
            return 1  # Cas de base
        else:
            return n * factorielle(n - 1)  # Cas récursif
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Application : Exploration d'un Donjon Récursif</h3>
            <p>Dans ce projet, nous allons simuler un héros explorant un donjon. Le donjon est représenté par un labyrinthe (sous forme de matrice 2D), où le héros doit trouver la sortie. La récursivité sera utilisée pour explorer toutes les directions possibles à chaque intersection du labyrinthe.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Modélisation du donjon</h4>
            <p>Le donjon est représenté par une matrice où :</p>
            <ul>
                <li>1 représente un mur,</li>
                <li>0 représente un chemin libre,</li>
                <li><strong>S</strong> la position de départ,</li>
                <li><strong>E</strong> la sortie à atteindre.</li>
            </ul>
            <pre><code>
    donjon = [
        ['S', 1, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0]
    ]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Création de la fonction récursive d’exploration</h4>
            <p>On écrit une fonction récursive pour explorer le donjon. À chaque étape, le héros explore les cases adjacentes (haut, bas, gauche, droite) jusqu'à trouver la sortie.</p>
            <pre><code>
    def explorer_donjon(donjon, x, y, visitees):
        # Vérifier les limites du donjon
        if x < 0 or x >= len(donjon) or y < 0 or y >= len(donjon[0]):
            return False
        
        # Vérifier si c'est un mur ou une case déjà visitée
        if donjon[x][y] == 1 or (x, y) in visitees:
            return False
        
        # Si on a trouvé la sortie
        if donjon[x][y] == 'E':
            print(f"Sortie trouvée à la position ({x}, {y})")
            return True
        
        # Marquer la case comme visitée
        visitees.add((x, y))
        
        # Exploration récursive des 4 directions
        if (explorer_donjon(donjon, x+1, y, visitees) or  # Bas
            explorer_donjon(donjon, x-1, y, visitees) or  # Haut
            explorer_donjon(donjon, x, y+1, visitees) or  # Droite
            explorer_donjon(donjon, x, y-1, visitees)):   # Gauche
            return True
        
        # Si aucune direction ne permet d’avancer, retour en arrière
        return False
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Lancement de l'exploration</h4>
            <p>L’appel de la fonction d'exploration depuis la position de départ :</p>
            <pre><code>
    visitees = set()
    explorer_donjon(donjon, 0, 0, visitees)
            </code></pre>
            <p>Les élèves peuvent visualiser comment la récursivité permet au héros de tester différentes directions jusqu'à trouver la sortie du donjon.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Application : Génération de Terrains Fractals avec la Récursivité</h3>
            <p>Un autre exemple ludique pour explorer la récursivité est la génération de terrains fractals. C’est un algorithme utilisé dans certains jeux vidéo pour générer des paysages ou des environnements de manière procédurale.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Introduction au concept des fractals</h4>
            <p>Explication de la notion de fractal : une figure qui se divise en parties similaires à l'ensemble.</p>
            <p>On montre un exemple simple, tel que le triangle de Sierpinski ou un arbre fractal, qui est un arbre où chaque branche se divise en deux sous-branches plus petites.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Génération d’un arbre fractal</h4>
            <p>Nous allons utiliser la récursivité pour dessiner un arbre où chaque branche se divise en deux sous-branches plus petites. Pour simplifier, on peut utiliser la bibliothèque turtle de Python, qui permet de dessiner facilement.</p>
            <pre><code>
    import turtle

    def dessiner_arbre(longueur, angle):
        if longueur > 5:
            turtle.forward(longueur)
            turtle.right(angle)
            dessiner_arbre(longueur - 15, angle)
            turtle.left(angle * 2)
            dessiner_arbre(longueur - 15, angle)
            turtle.right(angle)
            turtle.backward(longueur)
    
    # Initialisation de Turtle
    turtle.speed("fastest")
    turtle.left(90)  # Faire pointer la tortue vers le haut
    dessiner_arbre(100, 30)  # Commence avec une longueur de 100
    turtle.done()
            </code></pre>
            <p>Les élèves pourront voir comment la récursivité permet de générer une figure qui se répète de manière auto-similaire.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Conclusion et Améliorations</h3>
            <p><strong>Extension de l’exploration du donjon :</strong> Les élèves peuvent être encouragés à ajouter des obstacles, des trésors ou d'autres éléments interactifs dans le donjon pour rendre l'exploration plus intéressante.</p>
            <p><strong>Améliorations sur l’arbre fractal :</strong> Les élèves peuvent modifier l’angle de l’arbre fractal ou ajouter des couleurs pour rendre le dessin plus complexe et esthétique.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Discussion :</h4>
            <ul>
                <li>Quand utiliser la récursivité vs les boucles ?</li>
                <li>Les limites de la récursivité (profondeur maximale de récursion, efficacité).</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice :</h4>
            <p>Modifier le code de l’exploration du donjon pour ajouter des monstres ou des pièges à éviter pendant l'exploration.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion de la Séance</h3>
            <p>À la fin de cette séance, les élèves auront appris à utiliser la récursivité pour résoudre des problèmes d’exploration et de génération d’environnements, avec des exemples concrets tirés des jeux vidéo. Cela les prépare à appliquer la récursivité dans des projets plus complexes à l'avenir.</p>
        </section>

        <section id="session4" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 4 : Introduction aux Algorithmes de Recherche Récursive – Recherche Binaire</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre et implémenter un algorithme de recherche binaire en utilisant une approche récursive. Ils doivent également l'appliquer à un contexte ludique (jeu vidéo) pour renforcer la compréhension par la pratique.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction à la Recherche Binaire</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Le Contexte :</h4>
            <p>Dans un jeu vidéo de chasse au trésor, le joueur doit trouver un trésor caché sur une île divisée en 100 sections numérotées de 1 à 100. Le joueur ne sait pas où le trésor est caché et doit le retrouver en posant des questions.</p>
            <p><strong>Problème initial :</strong> Si le joueur cherche le trésor en vérifiant chaque section, cela peut prendre beaucoup de temps. On appelle cela une recherche linéaire. Si le trésor est dans la dernière section, il devra vérifier toutes les sections avant d'arriver à la bonne, ce qui est peu efficace.</p>
            <p><strong>Solution optimisée :</strong> Utiliser la recherche binaire pour diviser l’espace de recherche en deux à chaque étape. Cela permet de réduire le nombre de vérifications nécessaires.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">L'idée de la Recherche Binaire :</h4>
            <p>La recherche binaire est un algorithme qui repose sur le principe de diviser pour régner (divide and conquer). Voici les étapes :</p>
            <ul>
                <li>Le joueur divise la zone de recherche en deux parties égales.</li>
                <li>Le joueur demande si le trésor se trouve dans la partie supérieure ou inférieure.</li>
                <li>À chaque étape, l’algorithme divise à nouveau la zone en deux et répète le processus jusqu’à ce que la section contenant le trésor soit trouvée.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple Concret :</h4>
            <p>Imaginons que le trésor soit dans la section 75.</p>
            <ol>
                <li>Étape 1 : Le joueur commence par diviser la zone en deux et vérifie la section du milieu (50).</li>
                <li>Est-ce que le trésor est dans la section 50 ? Non.</li>
                <li>Le trésor est-il dans une section plus haute ou plus basse que 50 ? Le trésor est dans une section plus haute.</li>
                <li>Étape 2 : Le joueur cherche donc dans les sections 51 à 100. La nouvelle section du milieu est 75.</li>
                <li>Est-ce que le trésor est dans la section 75 ? Oui !</li>
                <li>Le trésor est trouvé.</li>
            </ol>
            <p><strong>Avantage :</strong> En seulement 2 étapes, le joueur a trouvé le trésor, alors qu'une recherche linéaire aurait pris 75 étapes.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Explication Théorique de la Recherche Binaire</h3>
            <p>Comment ça fonctionne en termes d’algorithme :</p>
            <ol>
                <li><strong>Début :</strong> L’algorithme commence avec une liste triée de sections (de 1 à 100).</li>
                <li><strong>Milieu :</strong> Il trouve la section au milieu de la liste.</li>
                <li><strong>Comparaison :</strong> Il compare la section du milieu avec la section où le trésor est caché :
                    <ul>
                        <li>Si le trésor est dans la section du milieu, il s’arrête là.</li>
                        <li>Si le trésor est dans une section plus petite, il continue à chercher dans la moitié inférieure.</li>
                        <li>Si le trésor est dans une section plus grande, il continue à chercher dans la moitié supérieure.</li>
                    </ul>
                </li>
                <li><strong>Récursion :</strong> L’algorithme répète ce processus jusqu’à ce qu’il trouve le trésor.</li>
            </ol>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple de Pseudo-code :</h4>
            <pre><code>
    recherche_binaire(liste, debut, fin, cible):
    Si debut > fin, retourner -1 (le trésor n'est pas dans la liste)
    
    milieu = (debut + fin) // 2
    
    Si liste[milieu] == cible, retourner milieu (le trésor est trouvé)
    
    Si liste[milieu] < cible:
        Rechercher dans la moitié supérieure (milieu + 1 à fin)
    Sinon:
        Rechercher dans la moitié inférieure (debut à milieu - 1)
            </code></pre>
        
            <p><strong>Cas de base :</strong> Si la liste est vide (début > fin), le trésor n’est pas dans la liste.</p>
            <p><strong>Cas récursif :</strong> À chaque étape, la liste est divisée en deux, et l’algorithme est rappelé sur la moitié pertinente (supérieure ou inférieure).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique dans le Contexte du Jeu Vidéo</h3>
            
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Créer la Liste des Sections</h4>
            <p>Tout d’abord, nous allons représenter l’île avec une liste de sections numérotées de 1 à 100 :</p>
            <pre><code>
    sections = list(range(1, 101))
            </code></pre>
            <p>Ensuite, nous allons choisir une section aléatoire pour cacher le trésor :</p>
            <pre><code>
    import random
    section_tresor = random.choice(sections)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Implémenter la Recherche Binaire</h4>
            <p>Nous allons maintenant implémenter l'algorithme de recherche binaire récursive pour chercher le trésor. À chaque étape, le programme indiquera si le trésor est dans la moitié supérieure ou inférieure :</p>
            <pre><code>
    def recherche_binaire(liste, debut, fin, cible):
        if debut > fin:
            print("Le trésor n'est pas sur cette île !")
            return -1
        
        milieu = (debut + fin) // 2
        print(f"Vous cherchez dans la section {milieu}...")
        
        if liste[milieu] == cible:
            print(f"Félicitations ! Vous avez trouvé le trésor dans la section {milieu} !")
            return milieu
        elif liste[milieu] < cible:
            print("Le trésor est dans une section plus haute.")
            return recherche_binaire(liste, milieu + 1, fin, cible)
        else:
            print("Le trésor est dans une section plus basse.")
            return recherche_binaire(liste, debut, milieu - 1, cible)
    
    # Appel de la fonction
    recherche_binaire(sections, 0, len(sections) - 1, section_tresor)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Extension et Challenge : Limite de Tentatives</h4>
            <p>Pour ajouter un défi supplémentaire, introduisez une limite de tentatives. Comme la recherche binaire divise la zone par deux à chaque étape, le nombre maximum de tentatives pour trouver le trésor dans une liste de 100 éléments est de 7 (car log2(100) ≈ 7).</p>
            <p>Modifiez l'algorithme pour limiter le nombre de tentatives à 7. Si le joueur dépasse ce nombre, il échoue à trouver le trésor.</p>
        
            <pre><code>
    def recherche_binaire(liste, debut, fin, cible, tentatives=7):
        if debut > fin or tentatives == 0:
            print("Le trésor n'a pas été trouvé, vous avez épuisé vos tentatives.")
            return -1
        
        milieu = (debut + fin) // 2
        print(f"Vous cherchez dans la section {milieu}... Tentatives restantes : {tentatives}")
        
        if liste[milieu] == cible:
            print(f"Félicitations ! Vous avez trouvé le trésor dans la section {milieu} !")
            return milieu
        elif liste[milieu] < cible:
            print("Le trésor est dans une section plus haute.")
            return recherche_binaire(liste, milieu + 1, fin, cible, tentatives - 1)
        else:
            print("Le trésor est dans une section plus basse.")
            return recherche_binaire(liste, debut, milieu - 1, cible, tentatives - 1)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Réflexion</h3>
            <p>À la fin de cette séance :</p>
            <ul>
                <li>Les élèves auront compris le concept de récursivité et comment elle peut être utilisée pour diviser un problème en sous-problèmes plus petits.</li>
                <li>Ils auront appris à implémenter un algorithme de recherche binaire pour améliorer l’efficacité de la recherche par rapport à une recherche linéaire.</li>
            </ul>
        
            <p><strong>Discussion sur la complexité temporelle :</strong> La recherche linéaire prend O(n) opérations, tandis que la recherche binaire prend O(log n) opérations, ce qui est bien plus rapide pour de grandes listes.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice complémentaire :</h4>
            <p>Comparer la recherche linéaire et la recherche binaire : Demander aux élèves d’implémenter une recherche linéaire et de compter combien de tentatives elle nécessite en moyenne pour trouver le trésor.</p>
        </section>

        <section id="session5" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 5 : Pratique – Recherche d’un Personnage de Manga avec un Algorithme de Recherche Binaire</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent utiliser l’algorithme de recherche binaire pour retrouver un personnage de manga dans une liste triée. Cela permettra de consolider les notions de recherche efficace et d’appliquer la récursivité dans un contexte concret.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte Manga :</h3>
            <p>Dans cette séance, vous allez simuler une recherche dans une base de données de personnages de manga. Imaginez une application où les utilisateurs peuvent rechercher un personnage de manga par son nom. Comme la base de données contient de nombreux personnages, une recherche linéaire serait inefficace. La solution ? Utiliser un algorithme de recherche binaire pour accélérer la recherche.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Introduction au Problème</h3>
            <p><strong>Problème :</strong> Vous avez une liste triée de personnages de manga et vous devez trouver un personnage spécifique rapidement. Plutôt que de chercher chaque nom un par un (recherche linéaire), vous allez utiliser un algorithme de recherche binaire pour optimiser le processus.</p>
            <ul>
                <li><strong>Recherche linéaire :</strong> Il faut potentiellement parcourir tous les éléments de la liste pour trouver le bon personnage. Si la liste contient 100 personnages, il pourrait falloir jusqu'à 100 comparaisons dans le pire des cas.</li>
                <li><strong>Recherche binaire :</strong> La liste est triée, donc à chaque étape, vous pouvez diviser la liste en deux, ce qui accélère la recherche de manière exponentielle.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Explication du Contexte et de la Recherche Binaire</h3>
            <p><strong>Contexte Manga :</strong> Imaginez une application de fans de manga où les utilisateurs peuvent rechercher des personnages. Chaque personnage a un nom, et la liste de personnages est déjà triée alphabétiquement.</p>
            <p><strong>Exemple :</strong> Voici une liste simplifiée de personnages de mangas (cette liste est triée) :</p>
        
            <pre><code>["Asta", "Edward", "Goku", "Luffy", "Naruto", "Sasuke", "Tanjiro", "Vegeta", "Zoro"]</code></pre>
        
            <p>Si vous cherchez "Luffy", au lieu de commencer à chercher depuis le début de la liste et d’aller un par un (recherche linéaire), vous pouvez commencer au milieu et diviser la recherche en deux.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Recherche Binaire : Principe et Explication</h3>
            <p>La recherche binaire consiste à diviser la liste en deux parties égales, à comparer l’élément du milieu avec le nom que vous cherchez, puis à continuer à diviser la moitié pertinente jusqu'à ce que vous trouviez l'élément, ou que vous déterminiez qu'il n'est pas dans la liste.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple Concret :</h4>
            <p>Si vous cherchez "Luffy", voici les étapes :</p>
            <ol>
                <li>La liste contient 9 personnages, l’élément du milieu est à la position 4 (index 4, c’est "Naruto").</li>
                <li>"Luffy" est plus petit que "Naruto" dans l’ordre alphabétique, donc on cherche dans la première moitié de la liste (éléments [0, 3]).</li>
                <li>Dans cette nouvelle sous-liste, l’élément du milieu est à la position 1 (index 1, c’est "Edward").</li>
                <li>"Luffy" est plus grand que "Edward", donc on cherche dans la moitié supérieure de cette sous-liste.</li>
                <li>On trouve "Luffy" à l’index 3.</li>
            </ol>
        
            <p>Conclusion : La recherche binaire a permis de trouver "Luffy" en seulement 3 comparaisons, au lieu de 5 comparaisons en recherche linéaire.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Explication Théorique de l'Algorithme</h4>
            <pre><code>
    recherche_binaire(liste, debut, fin, cible):
    Si debut > fin, retourner -1 (le personnage n'est pas dans la liste)
    
    milieu = (debut + fin) // 2
    
    Si liste[milieu] == cible, retourner milieu (personnage trouvé)
    
    Si liste[milieu] < cible:
        Rechercher dans la moitié supérieure (milieu + 1 à fin)
    Sinon:
        Rechercher dans la moitié inférieure (debut à milieu - 1)
            </code></pre>
        
            <p><strong>Cas de base :</strong> Si la sous-liste est vide (debut > fin), le personnage n'est pas dans la liste.</p>
            <p><strong>Cas récursif :</strong> La fonction appelle récursivement la recherche binaire sur la moitié supérieure ou inférieure selon la comparaison du personnage du milieu avec celui recherché.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique : Recherche Binaire sur une Liste de Personnages de Manga</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Créer la Liste des Personnages de Manga</h4>
            <p>On va d’abord créer une liste de personnages triée alphabétiquement.</p>
        
            <pre><code>
    personnages_manga = ["Asta", "Edward", "Goku", "Luffy", "Naruto", "Sasuke", "Tanjiro", "Vegeta", "Zoro"]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Implémenter la Recherche Binaire</h4>
            <p>On implémente l’algorithme de recherche binaire pour chercher un personnage dans cette liste. L’algorithme prend la liste de personnages, les indices de début et de fin, et le nom du personnage à chercher.</p>
        
            <pre><code>
    def recherche_binaire(liste, debut, fin, cible):
        if debut > fin:
            print(f"{cible} n'est pas dans la liste.")
            return -1
        
        milieu = (debut + fin) // 2
        print(f"Vérification du personnage au milieu : {liste[milieu]}")
    
        if liste[milieu] == cible:
            print(f"Félicitations ! {cible} a été trouvé à la position {milieu}.")
            return milieu
        elif liste[milieu] < cible:
            print(f"{cible} est après {liste[milieu]}. Recherche dans la moitié supérieure.")
            return recherche_binaire(liste, milieu + 1, fin, cible)
        else:
            print(f"{cible} est avant {liste[milieu]}. Recherche dans la moitié inférieure.")
            return recherche_binaire(liste, debut, milieu - 1, cible)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Recherche d’un Personnage</h4>
            <p>Invitez les élèves à tester cette fonction en recherchant des personnages comme Luffy, Naruto, ou d'autres dans la liste.</p>
        
            <pre><code>
    # Appel de la fonction de recherche
    recherche_binaire(personnages_manga, 0, len(personnages_manga) - 1, "Luffy")
            </code></pre>
        
            <p><strong>Exemple de sortie :</strong></p>
            <pre><code>
    Vérification du personnage au milieu : Naruto
    Luffy est avant Naruto. Recherche dans la moitié inférieure.
    Vérification du personnage au milieu : Edward
    Luffy est après Edward. Recherche dans la moitié supérieure.
    Vérification du personnage au milieu : Luffy
    Félicitations ! Luffy a été trouvé à la position 3.
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Extension : Limite de Tentatives</h3>
            <p>Ajoutez une fonctionnalité pour limiter le nombre de tentatives à un certain nombre, comme 4 tentatives, pour rendre l'exercice plus difficile et montrer comment l’algorithme optimise les recherches.</p>
        
            <pre><code>
    def recherche_binaire(liste, debut, fin, cible, tentatives):
        if debut > fin or tentatives == 0:
            print(f"{cible} n'a pas été trouvé ou les tentatives sont épuisées.")
            return -1
        
        milieu = (debut + fin) // 2
        print(f"Vérification du personnage au milieu : {liste[milieu]} - Tentatives restantes : {tentatives}")
    
        if liste[milieu] == cible:
            print(f"Félicitations ! {cible} a été trouvé à la position {milieu}.")
            return milieu
        elif liste[milieu] < cible:
            print(f"{cible} est après {liste[milieu]}. Recherche dans la moitié supérieure.")
            return recherche_binaire(liste, milieu + 1, fin, cible, tentatives - 1)
        else:
            print(f"{cible} est avant {liste[milieu]}. Recherche dans la moitié inférieure.")
            return recherche_binaire(liste, debut, milieu - 1, cible, tentatives - 1)
    
    # Lancer la recherche avec une limite de tentatives
    recherche_binaire(personnages_manga, 0, len(personnages_manga) - 1, "Luffy", tentatives=4)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Réflexion</h3>
            <ul>
                <li><strong>Discussion sur l’efficacité :</strong> Demandez aux élèves de comparer le nombre de tentatives nécessaires pour une recherche binaire par rapport à une recherche linéaire. Pour une liste de 9 éléments, la recherche binaire prend généralement 3 comparaisons, contre 9 dans le pire des cas pour une recherche linéaire.</li>
                <li><strong>Introduction à la complexité algorithmique :</strong> La recherche binaire a une complexité de O(log n), ce qui la rend beaucoup plus rapide que la recherche linéaire O(n) pour de grandes listes.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif de la Séance :</h3>
            <ul>
                <li>Utiliser l'algorithme de recherche binaire dans un contexte de liste de personnages de manga.</li>
                <li>Appliquer des concepts de récursivité pour diviser un problème complexe en sous-problèmes plus simples.</li>
                <li>Comparer les performances entre une recherche linéaire et une recherche binaire, notamment en termes de nombre de comparaisons.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exercice Complémentaire :</h3>
            <ul>
                <li>Implémenter une recherche linéaire et la comparer à la recherche binaire.</li>
                <li>Ajouter d’autres fonctionnalités à l’application, comme la possibilité de rechercher par d'autres attributs (ex : force, univers d’origine des personnages).</li>
            </ul>
        </section>

        <section id="session6" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 6 : Analyse de la Complexité d’un Algorithme de Recherche Récursive</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre comment analyser la complexité d’un algorithme récursif en termes de temps d’exécution. Ils découvriront la différence entre la complexité linéaire et la complexité logarithmique, et appliqueront ces concepts à un contexte de jeu vidéo.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte :</h3>
            <p>Dans un jeu vidéo, le joueur doit rechercher des objets cachés dans une carte divisée en sections. Vous avez déjà appris à implémenter des algorithmes de recherche récursive comme la recherche binaire. Maintenant, nous allons voir comment mesurer et analyser la complexité de cet algorithme, c’est-à-dire, combien de temps il prend en fonction du nombre de sections à explorer.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Introduction à la Notion de Complexité d’un Algorithme</h3>
            <p><strong>Qu’est-ce que la complexité d’un algorithme ?</strong></p>
            <p>La complexité d’un algorithme est une manière de mesurer combien de temps ou combien de ressources (comme la mémoire) un algorithme va utiliser en fonction de la taille du problème à résoudre. En général, la complexité est exprimée en termes de nombre d’opérations que l’algorithme doit effectuer, et elle est souvent notée à l’aide de la notation Big-O.</p>
            
            <p><strong>Big-O :</strong> Il s'agit d'une notation utilisée pour décrire comment le temps d’exécution ou l’utilisation de la mémoire d’un algorithme augmente lorsque la taille de l’entrée (comme le nombre de sections sur la carte) augmente.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemples de complexités communes :</h4>
            <ul>
                <li><strong>Complexité linéaire (O(n)) :</strong> Si l’algorithme doit effectuer une opération pour chaque élément de la liste, le temps d'exécution augmente en ligne droite avec la taille du problème. Exemple : Recherche linéaire.</li>
                <li><strong>Complexité logarithmique (O(log n)) :</strong> Si l’algorithme divise le problème en deux à chaque étape, le temps d'exécution augmente beaucoup plus lentement que la taille du problème. Exemple : Recherche binaire.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Pourquoi c'est important ?</h4>
            <ul>
                <li>Dans un jeu vidéo, si un algorithme est trop lent (complexité élevée), il pourrait ralentir le jeu.</li>
                <li>Un algorithme plus rapide permet de rechercher des objets ou des ennemis sur de grandes cartes sans affecter les performances du jeu.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Revue des Algorithmes de Recherche</h3>
            <p>Nous avons déjà implémenté deux algorithmes de recherche :</p>
            <ul>
                <li><strong>Recherche linéaire :</strong> Le joueur vérifie chaque section de la carte une à une jusqu’à trouver l’objet. Cet algorithme prend du temps, surtout si l’objet est dans la dernière section.</li>
                <li><strong>Recherche binaire :</strong> Le joueur divise la carte en deux à chaque étape, réduisant le nombre de sections à chercher. Cet algorithme est beaucoup plus rapide.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple Visuel :</h4>
            <p>Prenons l’exemple d’une carte divisée en 32 sections. Le joueur doit chercher un objet caché quelque part.</p>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">1. Recherche linéaire :</h5>
            <p>Si l'objet est dans la 32e section, il faudra vérifier 32 sections avant de trouver l'objet.</p>
            <p><strong>Nombre d’opérations =</strong> 32 (pour une carte de 32 sections).</p>
            <p><strong>Complexité :</strong> O(n) (linéaire).</p>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">2. Recherche binaire :</h5>
            <p>Avec cet algorithme, on divise par deux à chaque étape. Pour 32 sections, il ne faudra que 5 vérifications pour trouver l’objet.</p>
            <p><strong>Nombre d’opérations ≈</strong> log2(32) = 5 (car 2^5 = 32).</p>
            <p><strong>Complexité :</strong> O(log n) (logarithmique).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Analyse de la Recherche Linéaire</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Algorithme de recherche linéaire :</h4>
        
            <pre><code>
    def recherche_lineaire(liste, cible):
        for i in range(len(liste)):
            print(f"Vérification de la section {liste[i]}")
            if liste[i] == cible:
                print(f"Objet trouvé dans la section {liste[i]}")
                return i
        print("Objet non trouvé")
        return -1
    
    # Création d'une liste de sections
    sections = list(range(1, 33))  # Carte avec 32 sections
    
    # Appel de la fonction de recherche
    recherche_lineaire(sections, 32)
            </code></pre>
        
            <p><strong>Analyse :</strong></p>
            <p>Dans le pire des cas (l’objet est dans la dernière section), l’algorithme doit parcourir 32 sections.</p>
            <p>Le nombre d’opérations nécessaires est donc directement proportionnel au nombre de sections : O(n).</p>
            <p><strong>Question pour les élèves :</strong> Que se passe-t-il si on augmente le nombre de sections à 100 ? Combien d’opérations faudra-t-il faire ?</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Analyse de la Recherche Binaire</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Rappel de l'algorithme de recherche binaire :</h4>
        
            <pre><code>
    def recherche_binaire(liste, debut, fin, cible):
        if debut > fin:
            print("Objet non trouvé")
            return -1
        
        milieu = (debut + fin) // 2
        print(f"Vérification de la section {liste[milieu]}...")
        
        if liste[milieu] == cible:
            print(f"Objet trouvé dans la section {liste[milieu]}")
            return milieu
        elif liste[milieu] < cible:
            return recherche_binaire(liste, milieu + 1, fin, cible)
        else:
            return recherche_binaire(liste, debut, milieu - 1, cible)
    
    # Appel de la fonction de recherche binaire
    sections = list(range(1, 33))  # Carte avec 32 sections
    recherche_binaire(sections, 0, len(sections) - 1, 32)
            </code></pre>
        
            <p><strong>Analyse :</strong></p>
            <p>À chaque étape, l'algorithme divise la liste en deux. Cela signifie que le nombre d’opérations est proportionnel à log2(n).</p>
            <p>Pour 32 sections, il faut au maximum 5 vérifications (car 2^5 = 32).</p>
            <p><strong>Complexité :</strong> O(log n).</p>
            <p><strong>Question pour les élèves :</strong> Que se passe-t-il si la carte contient 100 sections ?</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">5. Conclusion et Discussion</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Discussion finale :</h4>
            <p>Les élèves doivent comprendre que la recherche binaire est bien plus rapide que la recherche linéaire, surtout lorsque le nombre de sections devient très grand.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Résumé des points clés :</h4>
            <ul>
                <li><strong>Recherche linéaire :</strong> Complexité O(n), ce qui signifie que le nombre d’opérations augmente linéairement avec la taille du problème.</li>
                <li><strong>Recherche binaire :</strong> Complexité O(log n), ce qui signifie que le nombre d’opérations augmente beaucoup plus lentement, même pour de grandes tailles de problèmes.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice de réflexion :</h4>
            <p>Demander aux élèves d’expliquer pourquoi un jeu vidéo qui utilise des cartes énormes aurait intérêt à utiliser des algorithmes comme la recherche binaire plutôt que la recherche linéaire.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Extension : Exercice complémentaire :</h4>
            <p><strong>Challenge :</strong> Demandez aux élèves d’ajouter un chronomètre dans le programme pour mesurer le temps réel que prend chaque algorithme pour trouver l’objet dans une liste de 1 000 sections. Ils devront comparer le temps d'exécution entre la recherche linéaire et la recherche binaire en utilisant la bibliothèque Python <code>time</code>.</p>
        
            <pre><code>
    import time

    # Chronométrer la recherche linéaire
    start_time = time.time()
    recherche_lineaire(sections, 32)
    print("Temps d'exécution de la recherche linéaire :", time.time() - start_time)
    
    # Chronométrer la recherche binaire
    start_time = time.time()
    recherche_binaire(sections, 0, len(sections) - 1, 32)
    print("Temps d'exécution de la recherche binaire :", time.time() - start_time)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif de la Séance :</h3>
            <p>À la fin de cette séance, les élèves auront appris à :</p>
            <ul>
                <li>Analyser la complexité d’un algorithme.</li>
                <li>Comprendre pourquoi certains algorithmes (comme la recherche binaire) sont beaucoup plus rapides que d'autres (recherche linéaire).</li>
                <li>Appliquer ces notions de complexité à des cas concrets, comme la recherche d’objets dans un jeu vidéo.</li>
            </ul>
        </section>

        <section id="session7" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 7 : Introduction au Backtracking (Concepts de Base)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre les concepts de base du backtracking et les implémenter dans un contexte pratique en lien avec un jeu vidéo. Le backtracking est un algorithme qui permet de résoudre des problèmes en explorant toutes les solutions possibles et en revenant en arrière si une solution ne fonctionne pas.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte du Jeu Vidéo :</h3>
            <p>Dans un jeu d'exploration, le joueur est perdu dans un labyrinthe complexe. Il doit trouver le chemin vers la sortie. Cependant, certains chemins sont bloqués ou mènent à des culs-de-sac. L’objectif est d’utiliser un algorithme de backtracking pour trouver la sortie en explorant le labyrinthe, tout en revenant en arrière lorsqu’un chemin ne fonctionne pas.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Introduction au Problème</h3>
            <p>Le joueur doit naviguer dans un labyrinthe (représenté par une grille 2D) et trouver la sortie. À chaque case, il peut se déplacer vers le haut, bas, gauche, ou droite, mais certains chemins sont bloqués (murs), et certains conduisent à des impasses.</p>
            <p><strong>Problème initial :</strong> Comment trouver le chemin optimal pour sortir du labyrinthe sans devoir essayer toutes les combinaisons possibles manuellement ?</p>
            <p><strong>Solution optimisée :</strong> Utiliser un algorithme de backtracking pour explorer tous les chemins possibles, tout en revenant en arrière (backtrack) lorsqu'on atteint un cul-de-sac ou un chemin bloqué.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Explication Théorique du Backtracking</h3>
            <p>Le backtracking est un algorithme récursif qui explore toutes les solutions possibles à un problème en essayant différentes options. Lorsqu’une option échoue, l'algorithme revient en arrière (backtrack) et essaie une autre option.</p>
            <p><strong>Étapes générales de l'algorithme de backtracking :</strong></p>
            <ul>
                <li>Commencer à partir d’un point de départ (ici, l’entrée du labyrinthe).</li>
                <li>Essayer une direction (haut, bas, gauche, droite).</li>
                <li>Vérifier si la direction est valide (pas de mur, pas de chemin déjà emprunté).</li>
                <li>Si la direction mène à la sortie, on a trouvé une solution.</li>
                <li>Si la direction ne mène nulle part (cul-de-sac), revenir en arrière et essayer une autre direction.</li>
                <li>Répéter jusqu’à trouver la sortie ou épuiser toutes les options.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple de Pseudo-code :</h4>
            <pre><code>
    trouver_sortie(labyrinthe, position_x, position_y):
    Si la position actuelle est la sortie :
        Afficher "Sortie trouvée"
        Finir l'algorithme
    
    Marquer la position actuelle comme visitée
    
    Pour chaque direction possible (haut, bas, gauche, droite) :
        Si la direction est valide et non visitée :
            Appeler récursivement trouver_sortie avec la nouvelle position
            Si cela conduit à la sortie, Finir
    
    Si aucune direction ne fonctionne, revenir en arrière (backtrack)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Implémentation du Backtracking dans un Labyrinthe</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Modélisation du Labyrinthe</h4>
            <p>Nous allons représenter le labyrinthe comme une grille 2D où chaque case peut être soit un mur (1), soit un chemin libre (0), soit l’entrée (S), soit la sortie (E).</p>
            <p><strong>Voici un exemple de labyrinthe :</strong></p>
            <pre><code>
    labyrinthe = [
        ['S', 1, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0]
    ]
            </code></pre>
            <ul>
                <li><strong>S :</strong> point de départ (entrée).</li>
                <li><strong>E :</strong> point d'arrivée (sortie).</li>
                <li><strong>1 :</strong> mur (chemin bloqué).</li>
                <li><strong>0 :</strong> chemin possible.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Implémenter l'Algorithme de Backtracking</h4>
            <pre><code>
    # Labyrinthe 2D
    labyrinthe = [
        ['S', 1, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0]
    ]
    
    # Fonction de backtracking pour explorer le labyrinthe
    def explorer_labyrinthe(labyrinthe, x, y, visitees):
        # Vérifier si la position est hors du labyrinthe
        if x < 0 or x >= len(labyrinthe) or y < 0 or y >= len(labyrinthe[0]):
            return False
        
        # Si la position est un mur ou déjà visitée
        if labyrinthe[x][y] == 1 or (x, y) in visitees:
            return False
        
        # Si on a trouvé la sortie
        if labyrinthe[x][y] == 'E':
            print(f"Sortie trouvée à la position ({x}, {y})")
            return True
        
        # Marquer la position comme visitée
        visitees.add((x, y))
        
        # Explorer les directions : bas, haut, droite, gauche
        if (explorer_labyrinthe(labyrinthe, x+1, y, visitees) or  # Bas
            explorer_labyrinthe(labyrinthe, x-1, y, visitees) or  # Haut
            explorer_labyrinthe(labyrinthe, x, y+1, visitees) or  # Droite
            explorer_labyrinthe(labyrinthe, x, y-1, visitees)):   # Gauche
            return True
        
        # Si aucune direction ne fonctionne, revenir en arrière
        visitees.remove((x, y))
        return False
    
    # Position de départ
    position_depart = (0, 0)
    
    # Ensemble des cases visitées
    cases_visitees = set()
    
    # Lancer la recherche de la sortie
    explorer_labyrinthe(labyrinthe, position_depart[0], position_depart[1], cases_visitees)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Explication de l'Algorithme</h3>
            <ol>
                <li><strong>Exploration des Chemins :</strong> L’algorithme commence à la position de départ (S). Il essaie de se déplacer dans les quatre directions possibles (bas, haut, gauche, droite) et appelle récursivement la fonction pour chaque nouvelle position.</li>
                <li><strong>Conditions de Validité :</strong> Si la position est en dehors des limites du labyrinthe, ou si la case est un mur (1), ou si elle a déjà été visitée, le programme ne continue pas dans cette direction.</li>
                <li><strong>Si la sortie est atteinte :</strong> Si l’algorithme arrive sur la case de la sortie (E), il arrête l’exploration et affiche un message.</li>
                <li><strong>Backtracking (Retour en arrière) :</strong> Si l’algorithme ne trouve pas de solution dans une direction, il revient en arrière (backtrack), annule son choix (retire la case visitée de la liste des cases visitées), et essaie une autre direction.</li>
            </ol>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Prolongements et Extensions</h3>
            <ul>
                <li><strong>Ajouter des éléments dans le labyrinthe :</strong> Les élèves peuvent ajouter des pièges ou des portes fermées qui nécessitent de trouver une clé pour progresser. Modification du labyrinthe pour le rendre plus grand ou plus complexe.</li>
                <li><strong>Limiter le nombre de déplacements :</strong> Proposer une version du jeu où le joueur a un nombre limité de mouvements pour sortir du labyrinthe, ou il échoue.</li>
                <li><strong>Ajouter un deuxième joueur :</strong> Introduire un mode compétition où deux joueurs doivent trouver la sortie, le premier qui trouve la sortie gagne. On peut utiliser le backtracking pour gérer l'IA du second joueur.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion</h3>
            <p>À la fin de cette séance :</p>
            <ul>
                <li>Les élèves auront appris ce qu’est le backtracking, comment il permet d’explorer toutes les solutions possibles à un problème, et pourquoi il est efficace pour les labyrinthes.</li>
                <li>Ils auront implémenté une solution complète pour trouver la sortie d’un labyrinthe en utilisant ce concept.</li>
            </ul>
            <p><strong>Discussion :</strong> Applications pratiques du backtracking dans d’autres problèmes informatiques (ex. : sudoku, puzzles, algorithmes de parcours de graphes, optimisation combinatoire).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exercices Complémentaires :</h3>
            <ul>
                <li><strong>Explorer un plus grand labyrinthe :</strong> Créer un labyrinthe aléatoire de taille 10x10 ou plus grand, et tester l’efficacité du backtracking.</li>
                <li><strong>Ajouter des contraintes :</strong> Imposer des chemins où certaines cases ne peuvent être empruntées qu'une seule fois.</li>
            </ul>
        </section>

        <section id="session8" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 8 : Pratique - Résolution d'un Labyrinthe avec Backtracking (Jeu Vidéo)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves vont apprendre à utiliser l’algorithme de backtracking pour résoudre un labyrinthe. Cet algorithme permet de trouver une sortie dans un environnement en revenant en arrière lorsque le chemin pris est bloqué.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte du Jeu Vidéo :</h3>
            <p>Dans ce jeu, un personnage est perdu dans un labyrinthe représenté sous la forme d'une grille. Le joueur doit trouver un chemin entre le point de départ S (Start) et le point d’arrivée E (End). Certains chemins sont bloqués par des murs, représentés par des 1, et seuls les chemins libres (0) peuvent être empruntés.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Introduction au Problème</h4>
            <p><strong>Expliquer le problème du labyrinthe :</strong></p>
            <p>Le personnage doit trouver la sortie d’un labyrinthe représenté par une grille où certains chemins sont bloqués par des murs.</p>
        
            <p><strong>Représentation du labyrinthe :</strong></p>
            <ul>
                <li>S représente le point de départ.</li>
                <li>E représente le point de sortie.</li>
                <li>1 représente un mur (infranchissable).</li>
                <li>0 représente un chemin libre.</li>
            </ul>
        
            <p><strong>Exemple de labyrinthe simple :</strong></p>
            <pre><code>
    labyrinthe = [    
        ['S', 1, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0]
    ]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">2. Qu'est-ce que le Backtracking ?</h4>
            <p>L’algorithme de backtracking est une méthode récursive qui essaie de trouver une solution à un problème en avançant étape par étape. Si un chemin s’avère incorrect, l’algorithme revient en arrière (backtrack) et essaie un autre chemin.</p>
        
            <p><strong>Explication du principe :</strong></p>
            <ul>
                <li>Le personnage commence au point de départ.</li>
                <li>Il explore les chemins dans toutes les directions (haut, bas, gauche, droite).</li>
                <li>Si le chemin mène à un mur ou à une impasse, il revient à la position précédente et essaie une autre direction.</li>
                <li>Ce processus continue jusqu’à ce qu’il trouve la sortie ou qu’il n’y ait plus de chemin possible.</li>
            </ul>
        
            <p><strong>Application au labyrinthe :</strong></p>
            <p>L'algorithme va explorer tous les chemins possibles et revenir en arrière si un chemin ne mène pas à la sortie. Cela permet de tester toutes les solutions possibles pour trouver celle qui fonctionne.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">3. Algorithme de Backtracking pour Résoudre le Labyrinthe</h4>
            <p>L'algorithme de backtracking est généralement implémenté de manière récursive. Voici un exemple d'algorithme en pseudo-code :</p>
        
            <pre><code>
    explorer_labyrinthe(labyrinthe, x, y, visitees):
    Si (x, y) est hors du labyrinthe ou un mur ou déjà visité :
        Retourner False
                
    Si (x, y) est la sortie :
        Retourner True (la sortie est trouvée)
    
    Marquer (x, y) comme visité
                
    Explorer les 4 directions (haut, bas, gauche, droite) :
        Si l’une des directions mène à la sortie :
            Retourner True
    
    Si aucune direction ne fonctionne :
        Retourner False (chemin bloqué)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">4. Implémentation en Python</h4>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Représenter le Labyrinthe</h5>
            <p>Le labyrinthe sera représenté par une matrice (liste de listes en Python). 0 représente un chemin ouvert, 1 représente un mur, S représente la position de départ, et E la sortie.</p>
        
            <pre><code>
    labyrinthe = [
        ['S', 1, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0]
    ]
            </code></pre>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Fonction de Backtracking</h5>
            <pre><code>
    def explorer_labyrinthe(labyrinthe, x, y, visitees):
        # Vérifier les limites du labyrinthe
        if x < 0 or x >= len(labyrinthe) or y < 0 or y >= len(labyrinthe[0]):
            return False
    
        # Vérifier si la case est un mur ou déjà visitée
        if labyrinthe[x][y] == 1 or (x, y) in visitees:
            return False
    
        # Si on a trouvé la sortie
        if labyrinthe[x][y] == 'E':
            print(f"Sortie trouvée à la position ({x}, {y})")
            return True
    
        # Marquer la case comme visitée
        visitees.add((x, y))
    
        # Appeler la fonction récursive dans les 4 directions
        if (explorer_labyrinthe(labyrinthe, x + 1, y, visitees) or  # Bas
            explorer_labyrinthe(labyrinthe, x - 1, y, visitees) or  # Haut
            explorer_labyrinthe(labyrinthe, x, y + 1, visitees) or  # Droite
            explorer_labyrinthe(labyrinthe, x, y - 1, visitees)):   # Gauche
            return True
    
        # Si aucune direction ne fonctionne, on retourne False (backtrack)
        return False
            </code></pre>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Tester l'Algorithme avec un Labyrinthe</h5>
            <pre><code>
    # Position de départ
    position_depart = (0, 0)
    
    # Ensemble des cases visitées
    cases_visitees = set()
    
    # Lancer la recherche de la sortie
    if not explorer_labyrinthe(labyrinthe, position_depart[0], position_depart[1], cases_visitees):
        print("Aucun chemin trouvé pour sortir du labyrinthe.")
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">5. Ajout d'une Interface Graphique Simple</h4>
            <p>Pour rendre l'algorithme plus interactif, nous allons ajouter une interface graphique simple avec Pygame pour visualiser le personnage se déplaçant dans le labyrinthe.</p>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Installer Pygame</h5>
            <p>Installer Pygame avec la commande :</p>
            <pre><code>
    pip install pygame
            </code></pre>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Visualisation du Labyrinthe</h5>
            <pre><code>
    import pygame

    # Dimensions de la fenêtre
    TAILLE_BLOC = 40
    LARGEUR = len(labyrinthe[0]) * TAILLE_BLOC
    HAUTEUR = len(labyrinthe) * TAILLE_BLOC
    
    # Couleurs
    COULEUR_MUR = (0, 0, 0)
    COULEUR_CHEMIN = (255, 255, 255)
    COULEUR_JOUEUR = (0, 255, 0)
    COULEUR_SORTIE = (255, 0, 0)
    
    # Initialiser Pygame
    pygame.init()
    fenetre = pygame.display.set_mode((LARGEUR, HAUTEUR))
    pygame.display.set_caption("Labyrinthe")
    
    def dessiner_labyrinthe(labyrinthe, position_joueur):
        fenetre.fill(COULEUR_CHEMIN)
        for i in range(len(labyrinthe)):
            for j in range(len(labyrinthe[0])):
                x = j * TAILLE_BLOC
                y = i * TAILLE_BLOC
                if labyrinthe[i][j] == 1:
                    pygame.draw.rect(fenetre, COULEUR_MUR, (x, y, TAILLE_BLOC, TAILLE_BLOC))
                elif labyrinthe[i][j] == 'E':
                    pygame.draw.rect(fenetre, COULEUR_SORTIE, (x, y, TAILLE_BLOC, TAILLE_BLOC))
        # Dessiner le joueur
        joueur_x, joueur_y = position_joueur
        pygame.draw.rect(fenetre, COULEUR_JOUEUR, (joueur_y * TAILLE_BLOC, joueur_x * TAILLE_BLOC, TAILLE_BLOC, TAILLE_BLOC))
    
    # Position initiale du joueur
    position_joueur = (0, 0)
    
    # Boucle du jeu
    continuer = True
    while continuer:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                continuer = False
    
        dessiner_labyrinthe(labyrinthe, position_joueur)
        pygame.display.flip()
    
    pygame.quit()
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">6. Challenge et Extension</h4>
            <ul>
                <li><strong>Challenge 1 :</strong> Limiter le nombre de déplacements - Limiter le nombre de mouvements que le joueur peut faire avant de trouver la sortie.</li>
                <li><strong>Challenge 2 :</strong> Génération aléatoire de labyrinthes - Modifier l’algorithme pour générer des labyrinthes aléatoires et les résoudre en utilisant le backtracking.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Réflexion</h3>
            <ul>
                <li>Les élèves auront appris à implémenter un algorithme de backtracking pour résoudre un labyrinthe de manière efficace.</li>
                <li>Ils auront vu comment appliquer cet algorithme à un jeu vidéo pour rendre la solution plus interactive.</li>
                <li>Discussion sur la récursivité et le backtracking : revenir en arrière dans l'exploration d'un problème permet de résoudre des situations complexes où plusieurs chemins sont possibles.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice Complémentaire :</h4>
            <p>Créer une intelligence artificielle pour explorer le labyrinthe automatiquement, ou modifier l’algorithme pour trouver tous les chemins possibles vers la sortie.</p>
        </section>

        <section id="session9" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 9 : Étude des Cas Où le Backtracking Est Utile et de Ses Limitations</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre le fonctionnement de l'algorithme de backtracking (retour en arrière), les cas où il est utile et ses limites en termes de complexité. Ils l'implémenteront dans le cadre d’un jeu vidéo où le joueur doit trouver un chemin dans un labyrinthe.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte :</h3>
            <p>Dans un jeu de labyrinthe, le joueur doit trouver une sortie à travers un labyrinthe complexe. L’algorithme de backtracking est utilisé pour explorer tous les chemins possibles jusqu’à ce que la sortie soit trouvée. Si un chemin mène à une impasse, l’algorithme revient en arrière (backtrack) et essaie un autre chemin.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Introduction au Problème du Labyrinthe</h4>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Scénario du Jeu Vidéo :</h4>
            <p>Le joueur se trouve à l'entrée d'un labyrinthe et doit trouver la sortie. Le labyrinthe est représenté sous forme de grille, où certaines cases sont des chemins possibles (0), et d'autres sont des murs (1). Le joueur peut se déplacer vers le haut, le bas, la gauche, ou la droite. Le but est de trouver un chemin de l'entrée à la sortie.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Structure du Labyrinthe :</h4>
            <pre><code>
    labyrinthe = [
        ['S', 0, 0, 1, 0],
        [1, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 1, 1, 1],
        [0, 0, 0, 0, 0]
    ]
            </code></pre>
            <ul>
                <li><strong>S</strong> représente le point de départ (Start).</li>
                <li><strong>E</strong> représente la sortie (End).</li>
                <li><strong>1</strong> représente un mur (impossible à traverser).</li>
                <li><strong>0</strong> représente un chemin possible.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Explication Théorique du Backtracking</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Concept du Backtracking :</h4>
            <p>Le backtracking est une technique algorithmique qui consiste à essayer toutes les solutions possibles jusqu’à ce que la bonne solution soit trouvée. Le principe est le suivant :</p>
            <ul>
                <li><strong>1. Choisir une option :</strong> On avance dans une direction (ou on prend une décision).</li>
                <li><strong>2. Tester la solution :</strong> Si cette direction (ou décision) mène à une impasse, on "revient en arrière" et on essaie une autre option.</li>
                <li><strong>3. Répéter :</strong> On continue ainsi jusqu’à ce que la solution soit trouvée ou qu'il n'y ait plus de possibilités à explorer.</li>
            </ul>
        
            <p>Dans le cas du labyrinthe :</p>
            <ul>
                <li>On commence à l’entrée du labyrinthe (<strong>S</strong>) et on essaie de se déplacer dans une direction (haut, bas, gauche, droite).</li>
                <li>Si le joueur rencontre un mur ou un chemin déjà exploré, il revient en arrière et essaie une autre direction.</li>
                <li>Le processus se répète jusqu'à ce que le joueur trouve la sortie (<strong>E</strong>).</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Pseudo-code du Backtracking :</h4>
            <pre><code>
    fonction résoudre_labyrinthe(labyrinthe, x, y):
    Si (x, y) est la sortie :
        Retourner vrai (le chemin est trouvé)
            
    Si (x, y) est un mur ou déjà visité :
        Retourner faux (impasse)
            
    Marquer (x, y) comme visité
            
    Tenter de se déplacer dans les 4 directions :
        Si résoudre_labyrinthe(labyrinthe, x + 1, y) retourne vrai :
            Retourner vrai (la direction est correcte)
        Si résoudre_labyrinthe(labyrinthe, x - 1, y) retourne vrai :
            Retourner vrai
        Si résoudre_labyrinthe(labyrinthe, x, y + 1) retourne vrai :
            Retourner vrai
        Si résoudre_labyrinthe(labyrinthe, x, y - 1) retourne vrai :
            Retourner vrai
            
    Si aucune direction ne mène à la sortie :
        Retourner en arrière (backtrack) et Retourner faux
            </code></pre>
        
            <p><strong>Idée Clé :</strong> Le backtracking consiste à tester chaque chemin possible et à revenir en arrière lorsqu'on atteint une impasse. Cela permet d'explorer tous les chemins possibles.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Mise en Pratique du Backtracking pour Résoudre un Labyrinthe</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Représenter le Labyrinthe en Python</h4>
            <p>Nous allons d’abord représenter notre labyrinthe sous forme de liste de listes (2D array), comme précédemment décrit. Chaque case contient soit un chemin possible (0), soit un mur (1), soit l’entrée (S) et la sortie (E).</p>
        
            <pre><code>
    labyrinthe = [
        ['S', 0, 0, 1, 0],
        [1, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 1, 1, 1],
        [0, 0, 0, 0, 0]
    ]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Implémenter l'Algorithme de Backtracking</h4>
            <p>L'algorithme va chercher le chemin à partir du point de départ (x, y) et essayer toutes les directions possibles (haut, bas, gauche, droite) jusqu’à ce qu’il atteigne la sortie (E).</p>
        
            <pre><code>
    # Fonction pour résoudre le labyrinthe
    def résoudre_labyrinthe(labyrinthe, x, y, visitees):
        # Vérifier si on est à la sortie
        if labyrinthe[x][y] == 'E':
            print(f"Sortie trouvée à la position ({x}, {y})")
            return True
                    
        # Vérifier les limites du labyrinthe
        if x < 0 or x >= len(labyrinthe) or y < 0 or y >= len(labyrinthe[0]):
            return False
                
        # Vérifier si la case est un mur ou déjà visitée
        if labyrinthe[x][y] == 1 or (x, y) in visitees:
            return False
                    
        # Marquer la case comme visitée
        visitees.add((x, y))
                
        # Appeler récursivement la fonction dans les 4 directions
        if (résoudre_labyrinthe(labyrinthe, x + 1, y, visitees) or  # Bas
            résoudre_labyrinthe(labyrinthe, x - 1, y, visitees) or  # Haut
            résoudre_labyrinthe(labyrinthe, x, y + 1, visitees) or  # Droite
            résoudre_labyrinthe(labyrinthe, x, y - 1, visitees)):   # Gauche
            return True
                    
        # Si aucune direction ne fonctionne, revenir en arrière
        return False
                
    # Initialisation
    visitees = set()  # Ensemble des cases déjà visitées
    résoudre_labyrinthe(labyrinthe, 0, 0, visitees)  # Commence à (0, 0)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Cas d'Utilisation du Backtracking</h3>
        
            <p><strong>Quand le Backtracking est-il utile ?</strong></p>
            <ul>
                <li><strong>1. Résolution de labyrinthes :</strong> comme dans notre exemple de jeu vidéo, où il y a plusieurs chemins possibles à explorer.</li>
                <li><strong>2. Jeux de puzzle :</strong> comme le Sudoku, où chaque choix possible doit être exploré avant de revenir en arrière si nécessaire.</li>
                <li><strong>3. Problèmes de recherche de combinaisons :</strong> trouver toutes les combinaisons possibles d’un ensemble (par exemple, dans un problème de sac à dos où plusieurs combinaisons doivent être explorées).</li>
                <li><strong>4. Coloration de graphes :</strong> assigner des couleurs à des nœuds d’un graphe tout en respectant certaines contraintes.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Limites du Backtracking :</h4>
            <ul>
                <li><strong>1. Complexité exponentielle :</strong> Le backtracking est souvent inefficace pour de très grands problèmes, car il peut nécessiter d'explorer un nombre exponentiel de solutions.</li>
                <li><strong>2. Exploration complète :</strong> Il n'y a pas de raccourci pour éviter d'explorer tous les chemins possibles, sauf si l’on combine le backtracking avec d'autres techniques comme la programmation dynamique ou l’élagage (pruning).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">5. Limites du Backtracking</h3>
        
            <p>Le backtracking peut devenir inefficace dans certaines situations, en particulier lorsque :</p>
            <ul>
                <li><strong>Trop de solutions possibles :</strong> Par exemple, dans un labyrinthe trop complexe avec de nombreuses impasses, le backtracking explorera chaque chemin, même s’il est inutile.</li>
                <li><strong>Complexité exponentielle :</strong> La recherche d'une solution peut prendre un temps très long lorsque le problème devient très grand, car le nombre de combinaisons possibles à tester augmente de façon exponentielle.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion</h3>
            <p>Les élèves auront appris :</p>
            <ul>
                <li>Comment utiliser le backtracking pour résoudre des problèmes tels que des labyrinthes dans des jeux vidéo.</li>
                <li>Pourquoi le backtracking est une méthode efficace pour explorer plusieurs solutions mais pourquoi il peut être limité pour les problèmes de grande envergure.</li>
                <li>Comprendre l'idée de retour en arrière : explorer, tester, revenir en arrière en cas d'impasse, et continuer à chercher jusqu’à la solution.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercices Complémentaires :</h4>
            <ul>
                <li><strong>Amélioration du labyrinthe :</strong> Ajouter plus d’éléments au labyrinthe (ennemis, objets à collecter, etc.).</li>
                <li><strong>Élagage (pruning) :</strong> Modifier l'algorithme pour éviter certains chemins déjà identifiés comme inutiles.</li>
            </ul>
        </section>

        <section id="session10" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 10 : Introduction à la Complexité Algorithmique – Notation Big-O</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <ul>
                <li>Comprendre le concept de complexité algorithmique.</li>
                <li>Apprendre à utiliser la notation Big-O.</li>
                <li>Appliquer la notation Big-O dans des situations concrètes à travers des exemples de jeux vidéo.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Contexte et Introduction</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Le Problème :</h4>
            <p>Dans le contexte d'un jeu vidéo, imaginons que le joueur doit interagir avec un certain nombre d’éléments à l’écran (monstres, objets, personnages). Ces éléments sont stockés dans une liste ou un tableau, et le joueur doit effectuer des actions comme :</p>
            <ul>
                <li>Trouver un monstre spécifique pour l’attaquer.</li>
                <li>Ramasser un objet spécifique.</li>
                <li>Parcourir tous les éléments pour effectuer une action (comme infliger des dégâts à tous les monstres).</li>
            </ul>
            <p>Pour rendre ces actions efficaces, il est crucial de comprendre combien de temps ou combien d'opérations l'algorithme prend pour effectuer la tâche, en fonction du nombre d’éléments. C'est là que la complexité algorithmique intervient.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Qu’est-ce que la Complexité Algorithmique ?</h4>
            <p>La complexité algorithmique mesure l'efficacité d'un algorithme en fonction de la taille de l'entrée (nombre d'éléments à traiter).</p>
            <p>Plutôt que de mesurer le temps en secondes, on mesure le nombre d’opérations que l’algorithme doit effectuer pour résoudre le problème.</p>
            <p><strong>Exemple simple :</strong> Si vous devez chercher un objet spécifique dans une liste, combien de comparaisons l'algorithme devra-t-il faire en fonction de la longueur de la liste ?</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Notation Big-O : Mesurer l’Efficacité des Algorithmes</h3>
            <p>La notation Big-O permet de classer les algorithmes selon le nombre d’opérations qu’ils effectuent en fonction de la taille de l’entrée (souvent notée n).</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Définitions des Complexités :</h4>
            <ul>
                <li><strong>O(1) : Complexité constante</strong> - L’algorithme prend le même temps, quel que soit le nombre d’éléments.
                    <br>Exemple : Accéder directement à un élément dans un tableau (par index), comme dans une liste de potions dans un inventaire.
                </li>
                <li><strong>O(n) : Complexité linéaire</strong> - Le nombre d’opérations augmente proportionnellement au nombre d’éléments.
                    <br>Exemple : Parcourir une liste d'objets pour trouver un objet spécifique dans un inventaire (recherche linéaire).
                </li>
                <li><strong>O(log n) : Complexité logarithmique</strong> - Le nombre d’opérations croît logarithmiquement avec le nombre d'éléments.
                    <br>Exemple : Recherche binaire dans une liste triée d’objets.
                </li>
                <li><strong>O(n²) : Complexité quadratique</strong> - Le nombre d'opérations est proportionnel au carré du nombre d'éléments.
                    <br>Exemple : Comparer chaque monstre à chaque autre monstre dans un jeu de combat (algorithme de tri par sélection).
                </li>
                <li><strong>O(n log n) : Complexité linéaro-logarithmique</strong> - Utilisée pour des algorithmes de tri efficaces comme le tri rapide (Quicksort).
                </li>
                <li><strong>O(2ⁿ) : Complexité exponentielle</strong> - Le nombre d'opérations double à chaque ajout d'élément. Très inefficace.
                    <br>Exemple : Problèmes avec des combinaisons ou la génération d'arbres de décisions très profonds.
                </li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Exemples Concrets avec des Jeux Vidéo</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple 1 : Recherche dans un Inventaire de Jeu Vidéo</h4>
            <p>Imaginons que le joueur possède un inventaire avec n objets (potions, épées, boucliers). Il doit trouver une potion spécifique.</p>
            <ul>
                <li><strong>O(n)</strong> (recherche linéaire) : Le joueur doit parcourir tous les objets de l’inventaire un par un, en comparant chaque objet avec la potion recherchée.</li>
                <li>Si l’inventaire contient 100 objets, il faudra au pire 100 opérations pour trouver la potion (ou ne pas la trouver).</li>
            </ul>
            <p><strong>Exercice pratique :</strong> Implémenter une recherche linéaire sur une liste d’objets de jeu.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple 2 : Attaque de Tous les Monstres</h4>
            <p>Dans un jeu de type RPG, le joueur a la capacité d'attaquer tous les monstres présents sur le terrain en une seule action. Si chaque attaque prend une unité de temps, le nombre d'opérations sera proportionnel au nombre de monstres.</p>
            <ul>
                <li><strong>O(n)</strong> : S’il y a 50 monstres sur le terrain, il faudra 50 attaques, soit 50 opérations.</li>
            </ul>
            <p><strong>Exercice pratique :</strong> Implémenter une boucle qui applique une attaque à chaque monstre dans une liste de 50 monstres.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple 3 : Recherche Binaire pour Trouver un Objet dans un Inventaire Trié</h4>
            <p>Dans un inventaire trié d’un jeu, le joueur peut utiliser la recherche binaire pour trouver un objet plus rapidement.</p>
            <ul>
                <li><strong>O(log n)</strong> : Si l’inventaire contient 100 objets, la recherche binaire permet de trouver un objet en 7 étapes au lieu de 100.</li>
                <li>Chaque étape divise la liste en deux, ce qui fait que l’algorithme est logarithmique.</li>
            </ul>
            <p><strong>Exercice pratique :</strong> Implémenter une recherche binaire dans une liste triée d'objets (similaire à la recherche du trésor vue en séance précédente).</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple 4 : Comparer Chaque Monstre avec Chaque Autre Monstre (Algorithme Quadratique)</h4>
            <p>Dans certains jeux, vous pourriez avoir un système où chaque monstre doit interagir avec tous les autres (par exemple, vérifier les collisions entre eux).</p>
            <ul>
                <li><strong>O(n²)</strong> : Si vous avez 10 monstres, vous devez comparer chaque monstre avec les 9 autres, soit 100 comparaisons.</li>
                <li>Si vous avez 100 monstres, cela fera 10 000 comparaisons (un algorithme quadratique).</li>
            </ul>
            <p><strong>Exercice pratique :</strong> Implémenter un algorithme de comparaison entre chaque paire de monstres dans un jeu.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Expérimentation et Simulation avec des Listes de Données</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Implémenter des Algorithmes Différents</h4>
            <p>Les élèves vont créer une liste d'objets de jeu (par exemple, 100 objets avec des noms aléatoires).</p>
            <ul>
                <li><strong>Exercice 1 :</strong> Recherche linéaire : Implémenter une recherche d’un objet spécifique dans cette liste.</li>
                <li><strong>Exercice 2 :</strong> Recherche binaire : Si la liste est triée, utiliser la recherche binaire pour trouver l’objet plus rapidement.</li>
                <li><strong>Exercice 3 :</strong> Comparaison de tous les éléments : Simuler un combat où chaque monstre est comparé avec tous les autres.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Mesurer et Comparer la Performance</h4>
            <p>Pour chaque exercice, les élèves devront :</p>
            <ul>
                <li>Mesurer le nombre d’opérations nécessaires.</li>
                <li>Comparer la performance des algorithmes en fonction de la taille de la liste (par exemple, en augmentant la taille de la liste de 100 à 1000).</li>
            </ul>
            <p><strong>Exercice pratique :</strong> Afficher le temps pris par chaque algorithme pour trouver un objet dans une liste d’objets. Demander aux élèves d’expliquer pourquoi certains algorithmes sont plus rapides que d'autres pour de grandes listes.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">5. Discussion sur la Notion de Limite et d’Optimisation</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">La Limite des Algorithmes Inefficaces :</h4>
            <p>Discuter avec les élèves sur le fait qu’un algorithme linéaire (<strong>O(n)</strong>) peut être acceptable pour un petit nombre d’éléments, mais qu'il devient trop lent pour un grand nombre.</p>
            <p>Par exemple, rechercher un objet dans une liste de 100 éléments avec <strong>O(n)</strong> peut être acceptable, mais dans une liste de 1 000 000 d’éléments, il faut optimiser avec un algorithme plus rapide (comme <strong>O(log n)</strong> ou <strong>O(1)</strong>).</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Optimiser dans les Jeux Vidéo :</h4>
            <p>Dans les jeux vidéo, optimiser les algorithmes est crucial pour maintenir la performance, surtout si le jeu implique des centaines d'ennemis, des interactions complexes, et des actions en temps réel.</p>
            <p>Par exemple, pour un jeu où des dizaines de monstres doivent être gérés, il est important d’utiliser des algorithmes efficaces pour éviter les ralentissements.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">6. Conclusion et Résumé</h3>
            <p><strong>Ce que les élèves ont appris :</strong></p>
            <ul>
                <li><strong>Complexité algorithmique :</strong> Comprendre comment mesurer l’efficacité d’un algorithme en fonction du nombre d’opérations qu’il effectue.</li>
                <li><strong>Notation Big-O :</strong> Apprendre à classer les algorithmes en fonction de leur performance.</li>
                <li><strong>Exemples concrets :</strong> Les élèves ont appliqué la notion de complexité algorithmique à des cas pratiques dans des jeux vidéo.</li>
                <li><strong>Comparaison des algorithmes :</strong> Voir comment différents algorithmes (<strong>O(n)</strong>, <strong>O(log n)</strong>, <strong>O(n²)</strong>) fonctionnent dans des situations réelles et pourquoi certains sont plus efficaces.</li>
            </ul>
        
            <p><strong>Exercices Complémentaires :</strong></p>
            <ul>
                <li>Étendre l’exercice sur <strong>O(n log n)</strong> : Implémenter un algorithme de tri rapide (Quicksort) et comparer ses performances avec un tri basique (tri par sélection <strong>O(n²)</strong>).</li>
                <li>Tester des algorithmes sur de très grandes listes : Demander aux élèves de simuler des listes contenant des millions d’éléments et de comparer la rapidité des algorithmes.</li>
            </ul>
        </section>

        <section id="session11" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 11 : Pratique - Comparaison des Algorithmes de Tri Simples (Insertion, Sélection)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront à implémenter et comparer les algorithmes de tri par insertion et par sélection, en utilisant une approche pratique. Ces concepts seront appliqués dans le contexte d'un jeu vidéo où il faut organiser les objets de l'inventaire d'un personnage pour optimiser le gameplay.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte du Jeu Vidéo :</h3>
            <p>Dans un jeu d’aventure, le joueur collecte de nombreux objets (armes, potions, armures) pendant son exploration. Ces objets sont initialement mélangés dans son inventaire. Le joueur doit organiser son inventaire, par exemple en triant les objets selon leur valeur ou leur poids.</p>
            <p>Problème initial : Le joueur a besoin d’un inventaire trié pour accéder rapidement à ses objets les plus précieux ou les plus utiles. Si l’inventaire est désorganisé, cela peut nuire à l’efficacité du jeu.</p>
            <p>Solution : Utiliser des algorithmes de tri pour organiser l'inventaire.</p>
            <p>Les élèves vont comparer deux algorithmes de tri simples :</p>
            <ol>
                <li>Tri par insertion (Insertion Sort).</li>
                <li>Tri par sélection (Selection Sort).</li>
            </ol>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Introduction aux Algorithmes de Tri</h3>
            <p>Avant de plonger dans la pratique, il est important de comprendre les deux algorithmes de tri et leurs mécanismes.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Tri par Insertion :</h4>
            <p>Le tri par insertion fonctionne comme si vous triiez une main de cartes :</p>
            <ul>
                <li>Vous prenez les cartes (ici des objets de l’inventaire) une par une et les insérez au bon endroit dans une liste déjà triée.</li>
                <li>À chaque itération, la portion triée de la liste s’agrandit.</li>
            </ul>
            <p><strong>Principe :</strong> On compare l’élément actuel avec les éléments précédents et on l’insère à la bonne position pour que la partie gauche de la liste soit triée.</p>
        
            <pre><code>
    def tri_insertion(liste):
        for i in range(1, len(liste)):
            element = liste[i]
            j = i - 1
            while j >= 0 and liste[j] > element:
                liste[j + 1] = liste[j]
                j -= 1
            liste[j + 1] = element
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Tri par Sélection :</h4>
            <p>Le tri par sélection fonctionne en trouvant l'élément le plus petit et en le plaçant au début de la liste. Ensuite, on cherche le deuxième plus petit, et ainsi de suite.</p>
            <p><strong>Principe :</strong> On sélectionne l'élément le plus petit dans la partie non triée de la liste, puis on le place au début. On répète le processus jusqu'à ce que la liste soit entièrement triée.</p>
        
            <pre><code>
    def tri_selection(liste):
        for i in range(len(liste)):
            min_index = i
            for j in range(i + 1, len(liste)):
                if liste[j] < liste[min_index]:
                    min_index = j
            liste[i], liste[min_index] = liste[min_index], liste[i]
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Application dans le Contexte du Jeu Vidéo</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Préparation de l’Inventaire</h4>
            <p>L’inventaire du personnage est représenté par une liste d’objets, chaque objet ayant une valeur et un poids. Pour simplifier, les élèves peuvent utiliser une liste de nombres représentant les valeurs des objets.</p>
            <pre><code>
    inventaire = [50, 10, 40, 30, 20, 60]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Implémentation du Tri par Insertion</h4>
            <p>Les élèves commenceront par implémenter le tri par insertion pour organiser les objets de l’inventaire en fonction de leur valeur.</p>
            <ul>
                <li>Rappeler le principe : Le joueur veut trier ses objets du moins précieux au plus précieux pour les retrouver facilement.</li>
                <li>Exercice pratique : Écrire la fonction <code>tri_insertion</code> pour trier l’inventaire.</li>
            </ul>
        
            <pre><code>
    def tri_insertion(liste):
        for i in range(1, len(liste)):
            element = liste[i]
            j = i - 1
            while j >= 0 and liste[j] > element:
                liste[j + 1] = liste[j]
                j -= 1
            liste[j + 1] = element
                
    # Exemple d'utilisation
    inventaire = [50, 10, 40, 30, 20, 60]
    print("Inventaire avant tri :", inventaire)
    tri_insertion(inventaire)
    print("Inventaire après tri par insertion :", inventaire)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Implémentation du Tri par Sélection</h4>
            <p>Les élèves passent ensuite à l'implémentation du tri par sélection pour organiser l’inventaire de manière alternative.</p>
            <ul>
                <li>Rappeler le principe : On cherche l'objet le moins précieux et on le place au début de l’inventaire, puis on répète le processus.</li>
                <li>Exercice pratique : Écrire la fonction <code>tri_selection</code>.</li>
            </ul>
        
            <pre><code>
    def tri_selection(liste):
        for i in range(len(liste)):
            min_index = i
            for j in range(i + 1, len(liste)):
                if liste[j] < liste[min_index]:
                    min_index = j
            liste[i], liste[min_index] = liste[min_index], liste[i]
                
    # Exemple d'utilisation
    inventaire = [50, 10, 40, 30, 20, 60]
    print("Inventaire avant tri :", inventaire)
    tri_selection(inventaire)
    print("Inventaire après tri par sélection :", inventaire)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Comparaison des Algorithmes</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 4 : Comparaison sur la Base des Performances</h4>
            <p>Demander aux élèves de comparer les deux algorithmes de tri en termes de :</p>
            <ul>
                <li>Vitesse (nombre de comparaisons) : Combien de comparaisons sont faites dans chaque algorithme ?</li>
                <li>Tri par insertion : Bon pour des listes presque triées.</li>
                <li>Tri par sélection : Meilleur pour des listes complètement désordonnées.</li>
                <li>Simplicité d’implémentation : Lequel est plus simple à comprendre et à écrire ?</li>
                <li>Complexité temporelle :
                    <ul>
                        <li><strong>Insertion sort :</strong> O(n^2) dans le pire des cas.</li>
                        <li><strong>Selection sort :</strong> O(n^2) dans tous les cas.</li>
                    </ul>
                </li>
            </ul>
            <p>Demander aux élèves d’essayer ces algorithmes sur différentes tailles de listes (par exemple, 10, 100, 1000 éléments) et de mesurer le temps que chaque algorithme prend pour terminer le tri. Voici un code simple pour chronométrer :</p>
        
            <pre><code>
    import time
        
    # Exemple pour le tri par insertion
    start_time = time.time()
    tri_insertion(inventaire)
    end_time = time.time()
    print("Temps pris par le tri par insertion :", end_time - start_time)
                
    # Faire de même pour le tri par sélection
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Extension et Discussion</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 5 : Extension - Trier par Poids</h4>
            <p>Ajouter une nouvelle caractéristique aux objets de l’inventaire : le poids. Demander aux élèves de modifier leur code pour trier les objets non plus par valeur, mais par poids.</p>
        
            <pre><code>
    inventaire_avec_poids = [
        {"nom": "épée", "valeur": 50, "poids": 5},
        {"nom": "potion", "valeur": 10, "poids": 1},
        {"nom": "armure", "valeur": 40, "poids": 15},
        {"nom": "bouclier", "valeur": 30, "poids": 8},
        {"nom": "arc", "valeur": 20, "poids": 3},
        {"nom": "flèches", "valeur": 60, "poids": 0.5}
    ]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 6 : Discussion Finale</h4>
            <ul>
                <li><strong>Avantages et inconvénients de chaque algorithme :</strong></li>
                <li>Le tri par insertion est plus rapide pour les petites listes ou les listes presque triées.</li>
                <li>Le tri par sélection est simple à comprendre, mais peu efficace pour les grandes listes.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Objectif Atteint</h3>
            <ul>
                <li>Implémenter les algorithmes de tri par insertion et tri par sélection.</li>
                <li>Comparer leurs performances sur des listes de différentes tailles.</li>
                <li>Appliquer ces concepts à un contexte ludique avec l’organisation d’un inventaire dans un jeu vidéo.</li>
                <li>Comprendre les forces et faiblesses de chaque méthode de tri.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice Complémentaire :</h4>
            <p>Tri d'une liste de dictionnaires : Demander aux élèves de trier une liste de dictionnaires (objets du jeu) non seulement par valeur ou poids, mais aussi par d’autres critères comme la rareté.</p>
        </section>

        <section id="session12" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 12 : Exercices d’Analyse de la Complexité des Algorithmes dans des Jeux Vidéo et la Vie Réelle</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre et analyser la complexité temporelle des algorithmes à travers des exemples concrets tirés de jeux vidéo et de la vie réelle. Ils apprendront à évaluer l’efficacité d’un algorithme en fonction de la taille des données sur lesquelles il opère et à utiliser la notation Big-O.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction à la Complexité Algorithmique</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Qu’est-ce que la Complexité Algorithmique ?</h4>
            <p>Lorsqu’on écrit un programme ou un algorithme, il est important de se demander "combien de temps prend l’algorithme pour s'exécuter" en fonction de la taille des données à traiter.</p>
            <p>La complexité algorithmique est une manière de mesurer et comparer l’efficacité de différents algorithmes en fonction du nombre d’opérations qu’ils effectuent.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">2. La Notation Big-O</h4>
            <p>La notation Big-O est une manière de représenter la croissance du temps d’exécution d’un algorithme en fonction de la taille des données (n).</p>
            <p><strong>Quelques exemples courants :</strong></p>
            <ul>
                <li><strong>O(1)</strong> : Temps constant. L'algorithme prend toujours le même temps, quelle que soit la taille des données.</li>
                <li><strong>O(n)</strong> : Temps linéaire. Le temps de l'algorithme augmente proportionnellement à la taille des données.</li>
                <li><strong>O(log n)</strong> : Temps logarithmique. Le temps de l'algorithme augmente lentement à mesure que les données augmentent.</li>
                <li><strong>O(n²)</strong> : Temps quadratique. Le temps augmente rapidement à mesure que la taille des données augmente (ex. : tri par sélection).</li>
                <li><strong>O(2ⁿ)</strong> : Temps exponentiel. Très inefficace pour de grandes quantités de données.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">3. Exemple de la Recherche dans un Jeu Vidéo</h4>
            <p>Dans un jeu vidéo de type open-world (monde ouvert), imaginons que le joueur cherche un objet caché. L’algorithme peut utiliser différents types de recherche pour aider le joueur à trouver cet objet.</p>
            <ul>
                <li><strong>Recherche linéaire (O(n)) :</strong> Si le joueur explore toutes les sections de la carte une par une, cela prendra du temps proportionnel à la taille de la carte. Si la carte contient 100 sections, il devra en moyenne en parcourir 50 avant de trouver l'objet.</li>
                <li><strong>Recherche binaire (O(log n)) :</strong> Si l'algorithme divise la carte en deux parties à chaque étape (comme vu lors de la recherche binaire), la recherche sera bien plus rapide. Pour 100 sections, il suffit de 7 étapes pour trouver l’objet.</li>
                <li><strong>Recherche dans un graphe (DFS/BFS) (O(n)) :</strong> Si le jeu est un labyrinthe ou un réseau complexe de chemins, les algorithmes de parcours de graphes peuvent être utilisés pour trouver l'objet.</li>
            </ul>
        
            <pre><code>
    # Pseudo-code pour la recherche linéaire :
    def recherche_lineaire(liste, cible):
        for i in range(len(liste)):
            if liste[i] == cible:
                return i
        return -1
                
    # Recherche binaire (comme vu dans une séance précédente) :
    def recherche_binaire(liste, debut, fin, cible):
        if debut > fin:
            return -1
        milieu = (debut + fin) // 2
        if liste[milieu] == cible:
            return milieu
        elif liste[milieu] < cible:
            return recherche_binaire(liste, milieu + 1, fin, cible)
        else:
            return recherche_binaire(liste, debut, milieu - 1, cible)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exercice Pratique 1 : Comparaison des Algorithmes de Recherche</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Scénario dans le Jeu Vidéo :</h4>
            <p>Dans un monde ouvert, un monstre doit suivre le joueur. Le monstre doit déterminer où se trouve le joueur sur une carte divisée en sections numérotées de 1 à 1000.</p>
            <ul>
                <li>Recherche linéaire : Le monstre vérifie chaque section une par une.</li>
                <li>Recherche binaire : Le monstre divise la carte en deux à chaque étape.</li>
            </ul>
            <p><strong>Objectif :</strong> Implémenter les deux algorithmes et comparer le nombre d’étapes nécessaires pour que le monstre trouve le joueur.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étapes :</h4>
            <ol>
                <li>Implémenter la recherche linéaire et la recherche binaire.</li>
                <li>Effectuer des tests avec différentes tailles de carte (ex. : 100, 500, 1000 sections).</li>
                <li>Comparer le nombre d'étapes nécessaires pour trouver le joueur à chaque fois.</li>
            </ol>
        
            <pre><code>
    # Code pour la Recherche Linéaire et Binaire :
    import random
                
    # Simulation d'une carte avec 1000 sections
    sections = list(range(1, 1001))
    # Le joueur se trouve dans une section aléatoire
    joueur = random.choice(sections)
                
    # Recherche linéaire
    def recherche_lineaire(liste, cible):
        etapes = 0
        for i in range(len(liste)):
            etapes += 1
            if liste[i] == cible:
                return i, etapes
        return -1, etapes
                
    # Recherche binaire
    def recherche_binaire(liste, debut, fin, cible, etapes=0):
        if debut > fin:
            return -1, etapes
        milieu = (debut + fin) // 2
        etapes += 1
        if liste[milieu] == cible:
            return milieu, etapes
        elif liste[milieu] < cible:
            return recherche_binaire(liste, milieu + 1, fin, cible, etapes)
        else:
            return recherche_binaire(liste, debut, milieu - 1, cible, etapes)
                
    # Comparaison des algorithmes
    lin_result, lin_etapes = recherche_lineaire(sections, joueur)
    bin_result, bin_etapes = recherche_binaire(sections, 0, len(sections) - 1, joueur)
                
    print(f"Recherche linéaire : trouvé en {lin_etapes} étapes")
    print(f"Recherche binaire : trouvé en {bin_etapes} étapes")
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Analyse des Résultats :</h3>
            <ul>
                <li><strong>Recherche linéaire :</strong> Plus la carte est grande, plus le monstre doit effectuer d'étapes pour trouver le joueur. La recherche linéaire est donc proportionnelle à la taille de la carte.</li>
                <li><strong>Recherche binaire :</strong> Le nombre d'étapes est beaucoup plus faible, car l'algorithme divise la carte en deux à chaque étape.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exercice Pratique 2 : Algorithmes de Tri dans les Jeux Vidéo</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Scénario dans le Jeu Vidéo :</h4>
            <p>Dans un inventaire de jeu vidéo, les objets doivent être triés par valeur ou par poids. L'algorithme de tri utilisé impacte la vitesse avec laquelle le joueur peut afficher son inventaire trié.</p>
            <ul>
                <li><strong>Tri par sélection (O(n²)) :</strong> Un tri basique mais lent.</li>
                <li><strong>Tri rapide (Quicksort, O(n log n)) :</strong> Un tri plus rapide utilisé dans les systèmes de gestion d'inventaire modernes.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Implémenter le Tri par Sélection</h4>
            <pre><code>
    def tri_selection(liste):
        n = len(liste)
        for i in range(n):
            min_idx = i
            for j in range(i+1, n):
                if liste[j] < liste[min_idx]:
                    min_idx = j
            liste[i], liste[min_idx] = liste[min_idx], liste[i]
        return liste
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Implémenter le Tri Rapide (Quicksort)</h4>
            <pre><code>
    def tri_rapide(liste):
        if len(liste) <= 1:
            return liste
        pivot = liste[0]
        inferieur = [x for x in liste[1:] if x <= pivot]
        superieur = [x for x in liste[1:] if x > pivot]
        return tri_rapide(inferieur) + [pivot] + tri_rapide(superieur)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Comparer les Deux Algorithmes de Tri</h4>
            <p>Les élèves doivent comparer les performances des deux algorithmes sur des listes d’inventaires de tailles différentes (10, 100, 1000 objets). Ils analyseront combien de temps chaque tri prend pour s'exécuter.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Discussion et Conclusion</h3>
            <p><strong>Complexité des Algorithmes :</strong> Pourquoi certains algorithmes sont-ils plus lents que d'autres ?</p>
            <p><strong>Big-O et l’importance de la taille des données :</strong> Discuter de la manière dont la taille des données influe sur les performances d'un algorithme.</p>
            <p><strong>Jeux Vidéo et Algorithmes :</strong> Comment des concepts théoriques comme la complexité algorithmique impactent directement des expériences de jeu.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Extensions possibles :</h4>
            <ul>
                <li>Analyser la complexité spatiale (mémoire utilisée) en plus de la complexité temporelle.</li>
                <li>Étudier d'autres algorithmes utilisés dans les jeux vidéo, comme les algorithmes d'IA pour le comportement des ennemis ou la génération procédurale de niveaux.</li>
            </ul>
        </section>

        <section id="session13" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 13 : Introduction aux Graphes et à leurs Applications</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre la notion de graphe en informatique, comment il est représenté et ses différentes applications pratiques, y compris dans le domaine des jeux vidéo. Ils apprendront les concepts de sommets, arêtes, parcours, et utiliseront des graphes pour résoudre des problèmes concrets, comme la navigation dans un jeu vidéo.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Graphes</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Qu’est-ce qu’un graphe ?</h4>
            <p>Un graphe est une structure de données composée :</p>
            <ul>
                <li><strong>De sommets (ou nœuds) :</strong> ce sont les points d’un graphe, souvent utilisés pour représenter des objets, des lieux, ou des états.</li>
                <li><strong>D’arêtes (ou arcs) :</strong> ce sont les lignes qui relient les sommets entre eux, représentant des relations ou des chemins entre ces objets.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Applications des graphes :</h4>
            <ul>
                <li><strong>Jeux vidéo :</strong> Représentation de mondes ou cartes de jeu (les sommets représentent les lieux, les arêtes représentent les chemins entre eux).</li>
                <li><strong>Réseaux sociaux :</strong> Chaque utilisateur est un sommet, et les relations entre eux (amis) sont des arêtes.</li>
                <li><strong>Navigation GPS :</strong> Les intersections (sommets) sont reliées par des routes (arêtes) pour trouver le chemin optimal.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Représentation d’un Graphe :</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Représentation par une matrice d’adjacence :</h4>
            <p>Une matrice carrée où les lignes et colonnes représentent les sommets. Si deux sommets sont connectés, la case correspondante contient une valeur (1 pour les non pondérés, un poids pour les pondérés).</p>
        
            <pre><code>
      |  A  |  B  |  C  |
       ------------------
    A |  0  |  1  |  0  |
    B |  1  |  0  |  1  |
    C |  0  |  1  |  0  |
            </code></pre>
            <p>Ici, A et B sont connectés, et B et C sont connectés.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">2. Représentation par liste d’adjacence :</h4>
            <p>Chaque sommet a une liste de sommets voisins. Cette représentation est plus économe en mémoire pour les graphes peu denses.</p>
        
            <pre><code>
    graphe = {
        'A': ['B'],
        'B': ['A', 'C'],
        'C': ['B']
    }
            </code></pre>
            <p>A est connecté à B, et B est connecté à C.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exemple Ludique : Utilisation des Graphes dans un Jeu Vidéo</h3>
            <p>Dans un jeu vidéo, vous êtes un personnage qui doit se déplacer d'un point A à un point B à travers un réseau de chemins connectant différents lieux. Le monde du jeu peut être représenté sous forme de graphe où :</p>
            <ul>
                <li><strong>Les sommets</strong> représentent des lieux (villes, salles dans un donjon, etc.).</li>
                <li><strong>Les arêtes</strong> représentent des chemins (routes, portes entre les salles, etc.).</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple de Graphe dans le Jeu :</h4>
            <pre><code>
    A ----- B ----- C
    |       |       |
    D ----- E ----- F
            </code></pre>
            <p>Chaque lettre représente une pièce (un sommet). Chaque trait représente un chemin entre deux pièces (une arête).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Types de Graphes</h3>
            <ul>
                <li><strong>Graphe non orienté :</strong> Les arêtes n'ont pas de direction. On peut aller dans les deux sens entre deux sommets.</li>
                <li><strong>Graphe orienté :</strong> Les arêtes ont une direction. On ne peut aller que dans un sens d’un sommet à un autre.</li>
                <li><strong>Graphe pondéré :</strong> Chaque arête a un poids (un coût), qui peut représenter la distance, le temps ou le coût énergétique pour se déplacer d’un sommet à un autre.</li>
                <li><strong>Graphe connexe :</strong> Il est possible d’atteindre n’importe quel sommet à partir de n’importe quel autre sommet.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique : Représentation d'un Monde de Jeu Vidéo avec un Graphe</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Créer un Graphe Représentant un Monde de Jeu</h4>
            <pre><code>
    graphe_donjon = {
        'A': ['B', 'D'],
        'B': ['A', 'C', 'E'],
        'C': ['B', 'F'],
        'D': ['A', 'E'],
        'E': ['B', 'D', 'F'],
        'F': ['C', 'E']
    }
            </code></pre>
            <p>Ici, chaque clé représente une pièce, et les valeurs sont les pièces connectées par une porte.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Représenter le Monde et les Connexions</h4>
            <p>Visualisez ce graphe dans le contexte d’un jeu :</p>
            <ul>
                <li><strong>Les sommets :</strong> Chaque lettre (A, B, C, etc.) représente une salle du donjon.</li>
                <li><strong>Les arêtes :</strong> Les portes qui relient les salles entre elles.</li>
            </ul>
            <p>Demandez aux élèves de dessiner ce graphe sur papier ou sur un tableau pour mieux le visualiser.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Définir des Chemins dans le Graphe</h4>
            <p>Le joueur commence dans la salle A et veut se rendre dans la salle F. L’objectif est de parcourir le graphe et de trouver un chemin du point A au point F en suivant les arêtes du graphe.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Parcours de Graphe : Introduction à la Recherche de Chemin</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Parcours en largeur (BFS - Breadth First Search) :</h4>
            <p>Utilisé pour trouver le plus court chemin dans un graphe non pondéré. Il explore tous les voisins d’un sommet avant de passer à la couche suivante.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">2. Parcours en profondeur (DFS - Depth First Search) :</h4>
            <p>Utile pour explorer toutes les branches d’un graphe. Il explore aussi loin que possible dans une branche avant de revenir en arrière.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique : Parcours en Largeur (BFS)</h3>
            <pre><code>
    from collections import deque
        
    def bfs(graphe, depart, objectif):
        file_attente = deque([depart])
        visites = set()
        
        while file_attente:
            sommet = file_attente.popleft()
            if sommet == objectif:
                print(f"Vous avez trouvé le chemin vers {objectif} depuis {depart} !")
                return
            if sommet not in visites:
                print(f"Vous explorez la pièce {sommet}")
                visites.add(sommet)
                file_attente.extend(graphe[sommet])
        print(f"Pas de chemin trouvé de {depart} à {objectif}.")
    
    # Appel de la fonction
    bfs(graphe_donjon, 'A', 'F')
            </code></pre>
            <p>Ce programme parcourt le donjon en utilisant une approche BFS (parcours en largeur) pour explorer les pièces adjacentes et trouver le chemin de la pièce A à la pièce F.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Application et Conclusion</h3>
            <p>Réflexion sur les Applications des Graphes :</p>
            <ul>
                <li><strong>Jeux vidéo :</strong> Les graphes sont utiles pour gérer les déplacements des personnages, que ce soit pour les joueurs ou pour les ennemis.</li>
                <li><strong>Navigation :</strong> Les GPS utilisent des graphes pondérés pour calculer les meilleurs itinéraires entre deux lieux.</li>
                <li><strong>Réseaux sociaux :</strong> Les graphes sont utilisés pour représenter les connexions entre utilisateurs (sommets) et leurs relations (arêtes).</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Challenge Supplémentaire (pour les élèves avancés) :</h4>
            <p>Ajoutez des poids aux arêtes pour représenter le coût (distance, énergie) du déplacement entre les salles, puis utilisez l’algorithme de Dijkstra pour trouver le chemin le plus court entre deux salles.</p>
            <p>Amélioration du jeu : Implémentez une fonction qui permet au joueur de trouver automatiquement le chemin le plus court pour s’échapper du donjon en évitant certains pièges.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectifs de la Séance :</h3>
            <ul>
                <li>Comprendre les concepts de base des graphes (sommets, arêtes, connexions).</li>
                <li>Savoir représenter un monde de jeu vidéo sous forme de graphe.</li>
                <li>Utiliser un algorithme de parcours de graphe pour résoudre un problème de navigation dans un jeu.</li>
                <li>Bonus : Introduction à l’application des graphes dans des domaines plus vastes (réseaux sociaux, GPS).</li>
            </ul>
        </section>

        <section id="session14" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 14 : Pratique - Représentation d'un Réseau de Routes dans un Jeu Vidéo avec des Graphes</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif de la Séance :</h3>
            <p>Les élèves vont apprendre à modéliser un réseau de routes dans un jeu vidéo en utilisant des graphes. Ils vont comprendre comment utiliser un graphe pour représenter des routes entre différentes villes et comment ces structures peuvent être utilisées pour trouver les chemins les plus courts dans un jeu vidéo de type simulation de transport.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte du Jeu Vidéo</h3>
            <p>Imaginez un jeu de simulation où le joueur doit gérer le réseau de transport d’un royaume. Le royaume est constitué de plusieurs villes reliées entre elles par des routes. Chaque ville est un nœud (ou sommet) du réseau, et chaque route entre deux villes est une arête (ou arc) dans le graphe.</p>
            <p><strong>Objectif du joueur :</strong> Le joueur doit transporter des marchandises d'une ville à l'autre en optimisant le trajet pour gagner du temps et des ressources. Il devra donc utiliser un algorithme de parcours de graphe pour trouver le chemin le plus court entre deux villes.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Graphes</h3>
            <p><strong>Qu’est-ce qu’un Graphe ?</strong></p>
            <p>Un graphe est une structure mathématique utilisée pour modéliser des relations entre des objets. Il est composé de :</p>
            <ul>
                <li><strong>Nœuds (ou sommets)</strong> : Ici, chaque nœud représente une ville.</li>
                <li><strong>Arêtes (ou arcs)</strong> : Ce sont les routes qui relient les villes entre elles.</li>
            </ul>
            <p><strong>Types de graphes :</strong></p>
            <ul>
                <li><strong>Graphes non orientés :</strong> Les arêtes n'ont pas de direction, comme une route bidirectionnelle entre deux villes.</li>
                <li><strong>Graphes orientés :</strong> Les arêtes ont une direction, comme une autoroute à sens unique entre deux villes.</li>
            </ul>
            <p>Dans notre exemple de jeu vidéo, nous utiliserons un graphe non orienté pour modéliser les routes, où chaque route est bidirectionnelle.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Représentation d’un Graphe en Python</h3>
            <p>Il existe plusieurs manières de représenter un graphe dans un programme :</p>
            <ul>
                <li><strong>Matrice d’adjacence :</strong> Une matrice où chaque élément (i, j) est 1 si une route existe entre les villes i et j, sinon 0.</li>
                <li><strong>Liste d’adjacence :</strong> Un dictionnaire où chaque ville est associée à une liste de villes adjacentes reliées par une route.</li>
            </ul>
            <p>Pour cette séance, nous allons utiliser une liste d’adjacence car elle est plus intuitive et plus efficace pour représenter des graphes avec peu de connexions.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 1 : Créer le Réseau de Routes avec une Liste d’Adjacence</h3>
            <p><strong>Exemple :</strong></p>
            <p>Supposons que nous avons cinq villes dans le royaume : A, B, C, D, et E. Les routes sont les suivantes :</p>
            <ul>
                <li>Route entre A et B.</li>
                <li>Route entre A et C.</li>
                <li>Route entre B et D.</li>
                <li>Route entre C et D.</li>
                <li>Route entre D et E.</li>
            </ul>
            <pre><code>
    # Représentation du réseau de routes avec une liste d'adjacence
    routes = {
        'A': ['B', 'C'],
        'B': ['A', 'D'],
        'C': ['A', 'D'],
        'D': ['B', 'C', 'E'],
        'E': ['D']
    }
            </code></pre>
            <p><strong>Explication :</strong></p>
            <ul>
                <li>La ville A est reliée aux villes B et C.</li>
                <li>La ville B est reliée aux villes A et D, etc.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 2 : Parcourir le Graphe – Algorithme DFS et BFS</h3>
            <p><strong>Pourquoi parcourir un graphe ?</strong></p>
            <p>Dans un jeu vidéo, le joueur peut vouloir savoir le chemin le plus court entre deux villes ou simplement vérifier si une ville est atteignable depuis une autre. Pour cela, on utilise des algorithmes de parcours de graphe, comme DFS (Depth First Search) ou BFS (Breadth First Search).</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Implémentation de DFS :</h4>
            <pre><code>
    # Fonction DFS pour parcourir le graphe
    def dfs(graphe, ville, visitees):
        print(f"Visite de {ville}")
        visitees.add(ville)  # Marquer la ville comme visitée
        
        # Explorer les voisins
        for voisin in graphe[ville]:
            if voisin not in visitees:
                dfs(graphe, voisin, visitees)
    
    # Appel de DFS à partir de la ville A
    visitees = set()
    dfs(routes, 'A', visitees)
            </code></pre>
            <p><strong>Explication de DFS :</strong></p>
            <ul>
                <li><strong>Départ :</strong> On commence par la ville A, puis on visite tous les voisins de A qui n’ont pas encore été visités (ici B et C).</li>
                <li><strong>Récursivité :</strong> L’algorithme appelle récursivement DFS sur chaque voisin jusqu’à ce que toutes les villes connectées soient visitées.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Implémentation de BFS :</h4>
            <pre><code>
    from collections import deque

    # Fonction BFS pour parcourir le graphe
    def bfs(graphe, ville_depart):
        file = deque([ville_depart])
        visitees = set([ville_depart])
        
        while file:
            ville = file.popleft()
            print(f"Visite de {ville}")
            
            # Parcourir les voisins
            for voisin in graphe[ville]:
                if voisin not in visitees:
                    file.append(voisin)
                    visitees.add(voisin)
    
    # Appel de BFS à partir de la ville A
    bfs(routes, 'A')
            </code></pre>
            <p><strong>Explication de BFS :</strong></p>
            <ul>
                <li>On commence par visiter la ville A, puis on ajoute ses voisins dans une file (ou file d’attente) pour les visiter à leur tour.</li>
                <li>Le parcours se fait par niveaux : on visite d’abord les voisins immédiats (ici B et C), puis les voisins des voisins.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 3 : Application au Jeu Vidéo – Trouver le Chemin le Plus Court</h3>
            <p><strong>Objectif :</strong></p>
            <p>Dans le jeu, le joueur doit transporter des marchandises entre deux villes et doit trouver le chemin le plus court. Pour cela, nous allons utiliser BFS car il est bien adapté pour trouver les chemins les plus courts dans les graphes non pondérés.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Ajout de la Fonction de Recherche du Chemin le Plus Court :</h4>
            <pre><code>
    def bfs_chemin_court(graphe, ville_depart, ville_arrivee):
        file = deque([[ville_depart]])  # File qui contient les chemins explorés
        visitees = set([ville_depart])
                    
        while file:
            chemin = file.popleft()
            ville = chemin[-1]
            
            # Si on arrive à la ville cible, on renvoie le chemin emprunté
            if ville == ville_arrivee:
                return chemin
            
            # Parcourir les voisins
            for voisin in graphe[ville]:
                if voisin not in visitees:
                    nouveau_chemin = list(chemin)  # Copier le chemin actuel
                    nouveau_chemin.append(voisin)  # Ajouter le voisin au chemin
                    file.append(nouveau_chemin)
                    visitees.add(voisin)
        
        return None  # Retourner None si aucun chemin n'est trouvé
    
    # Trouver le chemin le plus court entre A et E
    chemin = bfs_chemin_court(routes, 'A', 'E')
    print(f"Le chemin le plus court est : {chemin}")
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 4 : Extensions et Améliorations</h3>
            <ul>
                <li><strong>Pondération des routes :</strong> Ajouter des poids aux routes (distance ou temps de trajet) pour utiliser des algorithmes plus avancés comme Dijkstra pour trouver le chemin le plus court dans un graphe pondéré.</li>
                <li><strong>Modéliser plus de villes :</strong> Ajouter davantage de villes et routes dans le réseau de transport.</li>
                <li><strong>Gestion des trajets multiples :</strong> Permettre au joueur de planifier plusieurs trajets entre différentes villes.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion</h3>
            <ul>
                <li>Modéliser un réseau de routes avec un graphe en utilisant une liste d’adjacence.</li>
                <li>Implémenter des algorithmes de parcours (DFS et BFS) pour explorer un réseau de villes.</li>
                <li>Utiliser BFS pour trouver le chemin le plus court dans un graphe non pondéré, et comprendre comment cela s'applique aux jeux vidéo.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice Complémentaire :</h4>
            <p>Si certains élèves avancent plus rapidement, ils peuvent travailler sur un réseau de routes plus complexe et implémenter un algorithme plus avancé comme Dijkstra pour trouver le chemin le plus rapide en fonction du temps de trajet sur chaque route.</p>
        </section>

        <section id="session15" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 15 : Algorithmes de Parcours de Graphes – DFS et BFS</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre et implémenter deux algorithmes fondamentaux de parcours de graphes : DFS (Depth-First Search) et BFS (Breadth-First Search). Ils apprendront à les utiliser dans le cadre d’un jeu vidéo où un personnage doit explorer un réseau de niveaux ou un labyrinthe.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Graphes et Parcours</h3>
            <h4>Le Contexte du Jeu Vidéo :</h4>
            <p>Dans un jeu vidéo d’aventure, un personnage doit naviguer à travers un labyrinthe ou un réseau de niveaux pour atteindre la sortie ou accomplir une mission. Chaque niveau est représenté comme un graphe, où :</p>
            <ul>
                <li>Chaque nœud du graphe représente une salle ou un point d’intérêt dans le labyrinthe.</li>
                <li>Chaque arête entre deux nœuds représente un chemin que le personnage peut emprunter.</li>
            </ul>
            <p>Le joueur doit explorer le labyrinthe pour trouver la sortie ou un trésor. Pour rendre cette exploration efficace, nous allons utiliser deux algorithmes de parcours de graphes : DFS (parcours en profondeur) et BFS (parcours en largeur).</p>
        
            <h4>Définition de Base d’un Graphe :</h4>
            <ul>
                <li><strong>Nœuds (ou sommets) :</strong> chaque nœud représente un point, comme une salle dans un labyrinthe ou un niveau dans un jeu.</li>
                <li><strong>Arêtes :</strong> les connexions entre les nœuds, qui représentent des chemins.</li>
            </ul>
            <p>Dans notre jeu, nous pouvons modéliser un labyrinthe ou un réseau de niveaux sous forme de graphe.</p>
        
            <h4>Exemple Visuel :</h4>
            <pre><code>
    1 --- 2 --- 3
    |     |     |
    4 --- 5 --- 6
            </code></pre>
            <p>Chaque numéro (1, 2, 3, etc.) représente une salle du labyrinthe.</p>
            <p>Chaque trait (--- ou |) représente un chemin que le personnage peut emprunter pour aller d'une salle à l'autre.</p>
            <p>Nous allons voir comment le personnage peut explorer ce labyrinthe en utilisant les algorithmes DFS et BFS pour parcourir le graphe.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Algorithme DFS (Depth-First Search) – Parcours en Profondeur</h3>
            <h4>1. Principe de DFS :</h4>
            <p>Le parcours en profondeur consiste à explorer le plus loin possible dans une direction avant de revenir en arrière. Cela signifie que l’algorithme suit un chemin jusqu’à ce qu’il n’y ait plus d’arêtes à suivre, puis il revient en arrière pour explorer d’autres chemins.</p>
        
            <p>DFS fonctionne de manière récursive, en suivant un chemin jusqu’à atteindre un nœud sans issue (feuille), puis en revenant pour explorer les autres chemins.</p>
        
            <h4>Exemple Visuel avec DFS :</h4>
            <p>Dans notre labyrinthe ci-dessus, un parcours DFS à partir du nœud 1 pourrait suivre cette séquence : 1 → 2 → 3 → 6 → 5 → 4 (exploration la plus profonde possible avant de revenir).</p>
        
            <h4>Pseudo-code de DFS :</h4>
            <pre><code>
    def dfs(graphe, noeud, visites):
        if noeud not in visites:
            print(f"Visite du nœud {noeud}")
            visites.add(noeud)  # Marquer le nœud comme visité
            for voisin dans graphe[noeud]:  # Explorer tous les voisins non visités
                dfs(graphe, voisin, visites)
            </code></pre>
        
            <h4>Explication Étape par Étape :</h4>
            <ul>
                <li><strong>Initialisation :</strong> On commence au premier nœud (par exemple, la salle de départ).</li>
                <li><strong>Exploration :</strong> On explore un des voisins non visités, puis on continue à explorer les voisins des voisins.</li>
                <li><strong>Retour en arrière :</strong> Si un nœud n’a plus de voisins non visités, on revient en arrière pour explorer les autres chemins.</li>
            </ul>
        
            <h4>Implémentation DFS dans le Contexte du Jeu (Exemple en Python) :</h4>
            <pre><code>
    graphe = {
        1: [2, 4],
        2: [1, 3, 5],
        3: [2, 6],
        4: [1, 5],
        5: [2, 4, 6],
        6: [3, 5]
    }
    
    def dfs(graphe, noeud, visites):
        if noeud not in visites:
            print(f"Visite de la salle {noeud}")
            visites.add(noeud)
            for voisin dans graphe[noeud]:
                dfs(graphe, voisin, visites)
    
    # Initialiser un ensemble de nœuds visités
    visites = set()
    
    # Lancer le parcours DFS à partir de la salle 1
    dfs(graphe, 1, visites)
            </code></pre>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez le graphe pour que certaines salles contiennent des trésors.</li>
                <li><strong>Étape 2 :</strong> Implémentez un DFS pour que le joueur explore toutes les salles et affiche si un trésor est trouvé dans une salle.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Algorithme BFS (Breadth-First Search) – Parcours en Largeur</h3>
            <h4>1. Principe de BFS :</h4>
            <p>Le parcours en largeur consiste à explorer tous les voisins d’un nœud avant de passer aux voisins des voisins.</p>
            <p>BFS fonctionne en utilisant une file d’attente (queue) pour gérer les nœuds à explorer. À chaque étape, on explore tous les nœuds voisins du nœud actuel avant de passer aux nœuds de niveau supérieur.</p>
        
            <h4>Exemple Visuel avec BFS :</h4>
            <p>Dans le labyrinthe, un parcours BFS à partir du nœud 1 pourrait suivre cette séquence : 1 → 2 → 4 → 3 → 5 → 6 (exploration niveau par niveau).</p>
        
            <h4>Pseudo-code de BFS :</h4>
            <pre><code>
    from collections import deque

    def bfs(graphe, noeud):
        visites = set()  # Ensemble des nœuds visités
        queue = deque([noeud])  # File d'attente pour gérer les nœuds à explorer
        
        while queue:
            courant = queue.popleft()  # Récupérer le nœud à explorer
            if courant not in visites:
                print(f"Visite du nœud {courant}")
                visites.add(courant)  # Marquer comme visité
                for voisin dans graphe[courant]:
                    if voisin not in visites:
                        queue.append(voisin)  # Ajouter les voisins à la file d'attente
            </code></pre>
        
            <h4>Explication Étape par Étape :</h4>
            <ul>
                <li><strong>Initialisation :</strong> On commence au premier nœud (la salle de départ).</li>
                <li><strong>Exploration des voisins :</strong> On explore tous les voisins directs du nœud actuel.</li>
                <li><strong>Nœuds de niveau supérieur :</strong> Une fois les voisins directs explorés, on passe aux voisins des voisins, et ainsi de suite, jusqu’à ce que tous les nœuds soient visités.</li>
            </ul>
        
            <h4>Implémentation BFS dans le Contexte du Jeu (Exemple en Python) :</h4>
            <pre><code>
    from collections import deque
        
    graphe = {
        1: [2, 4],
        2: [1, 3, 5],
        3: [2, 6],
        4: [1, 5],
        5: [2, 4, 6],
        6: [3, 5]
    }
                
    def bfs(graphe, noeud):
        visites = set()  # Ensemble des nœuds visités
        queue = deque([noeud])  # File d'attente
        
        while queue:
            courant = queue.popleft()
            if courant not in visites:
                print(f"Visite de la salle {courant}")
                visites.add(courant)
                for voisin dans graphe[courant]:
                    if voisin not in visites:
                        queue.append(voisin)
    
    # Lancer le parcours BFS à partir de la salle 1
    bfs(graphe, 1)
            </code></pre>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Implémentez un système où le personnage doit explorer toutes les salles du labyrinthe à l'aide du parcours en largeur.</li>
                <li><strong>Étape 2 :</strong> Ajoutez un obstacle dans certaines salles et modifiez le BFS pour que le personnage ignore les salles avec des obstacles.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Comparaison des Algorithmes</h3>
        
            <h4>Comparaison DFS vs BFS :</h4>
            <ul>
                <li><strong>DFS (Depth-First Search) :</strong> L'algorithme explore profondément dans un chemin avant de revenir en arrière. Il est utile pour explorer des labyrinthes où l’on veut atteindre des chemins très éloignés. DFS utilise souvent la récursivité.</li>
                <li><strong>BFS (Breadth-First Search) :</strong> L'algorithme explore tous les voisins directs avant de passer aux nœuds suivants. Il est très efficace pour trouver le chemin le plus court dans un graphe. BFS utilise une file d’attente.</li>
            </ul>
        
            <h4>Complexité Temporelle :</h4>
            <p>Les deux algorithmes ont une complexité en temps de <code>O(V + E)</code>, où <code>V</code> est le nombre de nœuds (salles) et <code>E</code> est le nombre d’arêtes (chemins).</p>
        
            <h4>Discussion :</h4>
            <ul>
                <li>DFS est particulièrement utile pour les problèmes de parcours de labyrinthe où il est important d’explorer un chemin complet avant de revenir en arrière.</li>
                <li>BFS est idéal pour trouver des chemins plus courts ou explorer des environnements "niveau par niveau", comme dans un jeu où l’on veut explorer toutes les salles d'un étage avant de monter à l'étage supérieur.</li>
            </ul>
        </section>

        <section id="session16" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 16 : Approfondissement sur l’algorithme DFS (Depth-First Search)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves approfondiront leur compréhension de l’algorithme DFS (Depth-First Search) en explorant ses différentes applications, en particulier dans les graphes, dans un contexte de jeu vidéo où le joueur doit explorer un réseau complexe de salles interconnectées. L'objectif est de renforcer leur capacité à appliquer la récursivité dans la recherche en profondeur.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction à DFS dans un Contexte de Jeu Vidéo</h3>
        
            <h4>Contexte du Jeu Vidéo :</h4>
            <p>Imaginons un jeu d’aventure où le joueur incarne un explorateur qui doit naviguer à travers un réseau complexe de grottes interconnectées. Chaque grotte est une salle, et chaque connexion entre deux salles représente un chemin possible. L’objectif est de visiter toutes les grottes pour trouver un artefact caché. L’algorithme DFS est un moyen efficace pour parcourir toutes les salles en suivant un chemin en profondeur avant de revenir en arrière.</p>
        
            <h4>Concept de DFS :</h4>
            <p>DFS (Depth-First Search) est un algorithme qui explore un graphe en allant aussi loin que possible dans une direction avant de revenir en arrière pour explorer les autres chemins. C’est un algorithme récursif qui suit une stratégie de <strong>diviser pour régner</strong>, en explorant un chemin complet jusqu’à ce qu’il ne puisse plus avancer.</p>
        
            <h4>Représentation en Graphe :</h4>
            <p>Dans ce jeu vidéo, chaque salle est un nœud du graphe, et chaque connexion entre deux salles est une arête. Voici un exemple de graphe représentant un réseau de grottes :</p>
        
            <pre><code>
    1 --- 2 --- 3
    |     |     |
    4 --- 5 --- 6
            </code></pre>
        
            <p>Dans cet exemple, le joueur commence à la salle 1 et doit visiter toutes les autres salles en utilisant l’algorithme DFS pour explorer les salles dans un ordre efficace.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Explication de l’Algorithme DFS (30 min)</h3>
            <h4>1. Fonctionnement de DFS :</h4>
            <p>DFS utilise une approche récursive pour explorer les nœuds d’un graphe :</p>
            <ul>
                <li>On commence par un nœud initial (par exemple, la salle de départ).</li>
                <li>On explore un des voisins de ce nœud.</li>
                <li>À chaque fois qu’un nœud est visité, on le marque comme visité pour éviter de le revisiter.</li>
                <li>Si tous les voisins d’un nœud sont visités, l’algorithme revient en arrière et explore les autres chemins restants.</li>
            </ul>
        
            <h4>2. Récursivité dans DFS :</h4>
            <p>DFS est naturellement récursif. Chaque appel de fonction DFS explore un chemin jusqu’à ce qu’il n’y ait plus de voisins à visiter. L'algorithme revient ensuite à la fonction appelante pour explorer d’autres chemins.</p>
        
            <p>Le pseudo-code de DFS est le suivant :</p>
            <pre><code>
    def dfs(graphe, noeud, visites):
        if noeud not in visites:
            print(f"Visite de la salle {noeud}")
            visites.add(noeud)  # Marquer la salle comme visitée
            for voisin dans graphe[noeud]:  # Explorer les voisins non visités
                dfs(graphe, voisin, visites)
            </code></pre>
        
            <h4>3. Exemple Visuel :</h4>
            <p>Partant du nœud 1, DFS visitera les salles dans l’ordre suivant (dans ce cas particulier) :</p>
            <pre><code>
    1 → 2 → 3 → 6 → 5 → 4
            </code></pre>
            <p>DFS explore en profondeur jusqu’à la salle 6 avant de revenir en arrière pour explorer les autres chemins.</p>
        
            <h4>4. Cas d’Utilisation :</h4>
            <p>DFS est particulièrement utile lorsque l’on veut explorer un graphe complet ou lorsqu’on veut trouver un chemin à travers un labyrinthe, où les chemins peuvent être très profonds avant d’atteindre une solution.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation DFS dans un Contexte de Jeu Vidéo (40 min)</h3>
            
            <h4>1. Représentation du Graphe en Python :</h4>
            <p>Le graphe est représenté en Python sous la forme d’un dictionnaire, où chaque clé représente une salle, et la valeur associée est une liste de salles adjacentes (les voisins).</p>
        
            <pre><code>
    graphe = {
        1: [2, 4],
        2: [1, 3, 5],
        3: [2, 6],
        4: [1, 5],
        5: [2, 4, 6],
        6: [3, 5]
    }
            </code></pre>
        
            <h4>2. Implémentation de DFS en Python :</h4>
            <p>Voici une implémentation simple de l'algorithme DFS pour explorer les salles d’un réseau de grottes :</p>
        
            <pre><code>
    def dfs(graphe, noeud, visites):
        if noeud not in visites:
            print(f"Visite de la salle {noeud}")
            visites.add(noeud)  # Marquer la salle comme visitée
            for voisin dans graphe[noeud]:  # Explorer les voisins non visités
                dfs(graphe, voisin, visites)
    
    # Ensemble des nœuds visités
    visites = set()
    
    # Démarrer le parcours DFS à partir de la salle 1
    dfs(graphe, 1, visites)
            </code></pre>
        
            <h4>3. Explication du Code :</h4>
            <ul>
                <li>La fonction <code>dfs()</code> est appelée avec trois arguments : le graphe, le nœud actuel (la salle où le joueur se trouve), et l’ensemble des salles déjà visitées.</li>
                <li>Si la salle n’a pas encore été visitée, elle est marquée comme visitée et l'algorithme explore tous ses voisins de manière récursive.</li>
                <li>Une fois que tous les voisins ont été explorés, l’algorithme revient en arrière et continue avec les autres chemins possibles.</li>
            </ul>
        
            <h4>Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez le graphe pour ajouter des objets ou des trésors dans certaines salles.</li>
                <li><strong>Étape 2 :</strong> Implémentez une version de DFS qui affiche un message lorsque le joueur trouve un trésor dans une salle.</li>
                <li><strong>Étape 3 :</strong> Ajoutez une fonctionnalité qui limite le nombre de visites dans une salle, comme un nombre maximum de tentatives avant que le joueur échoue.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Comparaison (10 min)</h3>
            <p>À la fin de cette séance, les élèves auront approfondi leur compréhension de l’algorithme DFS et auront appris à l’appliquer dans un contexte de jeu vidéo, en modélisant un labyrinthe ou un réseau de salles. Ils auront également renforcé leurs compétences en <strong>récursivité</strong>, en suivant un chemin en profondeur et en revenant en arrière pour explorer d’autres chemins.</p>
        
            <p>Enfin, nous comparerons DFS avec d’autres algorithmes de parcours comme BFS, en soulignant que DFS est particulièrement efficace dans des contextes où les chemins sont profonds, tandis que BFS est souvent préféré pour trouver les chemins les plus courts.</p>
        </section>

        <section id="session17" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 17 : Pratique - Exploration d’un Monde Ouvert (Jeu Vidéo) avec DFS</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Dans cette séance pratique, les élèves appliqueront l’algorithme DFS (Depth-First Search) pour permettre à un personnage d’explorer un monde ouvert dans un jeu vidéo. L’objectif est de simuler une exploration où le personnage doit visiter différents lieux en profondeur, en suivant des chemins prédéfinis avant de revenir en arrière et explorer d’autres zones.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte de l'Exploration d’un Monde Ouvert dans un Jeu Vidéo</h3>
            
            <h4>1. Le Monde Ouvert :</h4>
            <p>Un <strong>monde ouvert</strong> dans un jeu vidéo est un environnement vaste et interconnecté où le joueur peut se déplacer librement entre différentes zones (comme des villes, des forêts, des montagnes, etc.). Chaque zone est modélisée comme un nœud d’un graphe, et les connexions entre ces zones sont représentées par des chemins.</p>
        
            <p>Dans cette simulation, nous allons modéliser le monde ouvert comme un graphe et utiliser DFS pour simuler l’exploration de ce monde.</p>
        
            <h4>2. Objectif de l’Exploration :</h4>
            <p>Le joueur contrôle un personnage qui doit explorer toutes les zones du monde ouvert. L’objectif est de visiter chaque zone au moins une fois, tout en cherchant des trésors cachés ou des objets dans certaines zones.</p>
        
            <p>Par exemple :</p>
            <ul>
                <li>Le joueur peut commencer dans la <strong>ville principale</strong> (nœud 1).</li>
                <li>Le joueur doit explorer des lieux comme des <strong>forêts</strong>, des <strong>cavernes</strong> ou des <strong>montagnes</strong> interconnectées.</li>
            </ul>
        
            <p>DFS est idéal dans ce contexte, car il explore profondément dans une direction avant de revenir pour visiter d’autres zones.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 1 : Représentation du Monde Ouvert avec un Graphe (30 min)</h3>
            
            <h4>1. Définition du Monde Ouvert sous forme de Graphe :</h4>
            <p>Chaque zone du jeu est représentée comme un nœud du graphe, et les chemins entre les zones sont les arêtes du graphe. Voici un exemple de structure de graphe pour un monde ouvert :</p>
        
            <pre><code>
    Ville Principale --- Forêt --- Caverne
    |                    |        |
    Montagne --- Plage    Lac     Temple
            </code></pre>
        
            <p>Dans ce graphe, le joueur peut explorer des lieux différents en passant par des chemins qui relient les zones. L’algorithme DFS permet de déterminer l’ordre dans lequel ces zones seront explorées.</p>
        
            <h4>2. Représentation en Python :</h4>
            <p>Nous pouvons modéliser ce monde ouvert comme un dictionnaire en Python, où chaque zone est un nœud, et la liste de ses voisins contient les zones adjacentes :</p>
        
            <pre><code>
    monde_ouvert = {
        'Ville Principale': ['Forêt', 'Montagne'],
        'Forêt': ['Ville Principale', 'Caverne', 'Lac'],
        'Caverne': ['Forêt', 'Temple'],
        'Montagne': ['Ville Principale', 'Plage'],
        'Plage': ['Montagne'],
        'Lac': ['Forêt'],
        'Temple': ['Caverne']
    }
            </code></pre>
        
            <h4>3. Objectifs du joueur :</h4>
            <ul>
                <li>Explorer toutes les zones du monde ouvert.</li>
                <li>Trouver des objets ou trésors cachés dans certaines zones.</li>
                <li>Explorer le monde de manière exhaustive en suivant un parcours en profondeur (DFS).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 2 : Implémentation de DFS pour l’Exploration (40 min)</h3>
        
            <h4>1. Implémentation de DFS en Python pour Explorer le Monde Ouvert :</h4>
            <p>Nous allons implémenter DFS pour que le personnage explore chaque zone une par une, en suivant un parcours en profondeur. Voici comment cela peut être fait en Python :</p>
        
            <pre><code>
    def explorer_monde(monde, zone, visites):
        if zone not in visites:
            print(f"Vous explorez {zone}")
            visites.add(zone)  # Marquer la zone comme visitée
            for voisin in monde[zone]:  # Explorer les zones voisines non visitées
                explorer_monde(monde, voisin, visites)
        
    # Ensemble des zones visitées
    zones_visitees = set()
    
    # Lancer l'exploration à partir de la Ville Principale
    explorer_monde(monde_ouvert, 'Ville Principale', zones_visitees)
            </code></pre>
        
            <h4>2. Explication du Code :</h4>
            <ul>
                <li>La fonction <code>explorer_monde()</code> est appelée avec trois arguments : le monde ouvert (le graphe), la zone actuelle, et l’ensemble des zones déjà visitées.</li>
                <li>Si la zone n’a pas encore été visitée, elle est marquée comme visitée, et l’algorithme explore récursivement tous ses voisins (autres zones connectées).</li>
                <li>DFS explore d’abord les zones en profondeur avant de revenir en arrière pour explorer d’autres chemins.</li>
            </ul>
        
            <h4>3. Simulation de l’Exploration :</h4>
            <p>Lorsque vous exécutez le code ci-dessus, le personnage explorera toutes les zones du monde ouvert dans un ordre déterminé par DFS. Par exemple :</p>
            <pre><code>
    Vous explorez Ville Principale
    Vous explorez Forêt
    Vous explorez Caverne
    Vous explorez Temple
    Vous explorez Lac
    Vous explorez Montagne
    Vous explorez Plage
            </code></pre>
            <p>DFS commence à la "Ville Principale", puis explore en profondeur la "Forêt", la "Caverne", et le "Temple" avant de revenir pour explorer d’autres zones.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 3 : Défis Pratiques pour les Élèves (30 min)</h3>
            
            <h4>1. Ajout d’Objets Cachés :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez le monde ouvert pour que certaines zones contiennent des objets ou des trésors cachés.</li>
                <li><strong>Étape 2 :</strong> Modifiez le code pour que l'algorithme affiche un message lorsqu'un objet ou trésor est trouvé dans une zone spécifique.</li>
            </ul>
        
            <h4>2. Limitation du Temps d’Exploration :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Ajoutez une contrainte de temps ou un nombre maximum d'explorations que le joueur peut effectuer avant que le temps ne s’écoule.</li>
                <li><strong>Étape 2 :</strong> Implémentez cette limite dans le code. Si le joueur dépasse la limite, un message s’affiche pour indiquer que l’exploration est terminée.</li>
            </ul>
        
            <h4>3. Exploration Sélective :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Créez un système où certaines zones du monde ouvert sont bloquées jusqu'à ce que le joueur trouve une clé ou un objet spécial dans une autre zone.</li>
                <li><strong>Étape 2 :</strong> Modifiez l'algorithme pour permettre au joueur d'explorer uniquement après avoir trouvé cet objet.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Réflexion sur DFS dans les Jeux Vidéo (10 min)</h3>
        
            <h4>Analyse de DFS dans un Monde Ouvert :</h4>
            <p>DFS est une méthode efficace pour explorer des mondes ouverts en profondeur, permettant au joueur de suivre des chemins jusqu’à ce qu’il atteigne une impasse ou un objectif. Une fois qu’un chemin est épuisé, l’algorithme revient en arrière pour explorer d’autres options.</p>
        
            <h4>Avantages et Inconvénients :</h4>
            <ul>
                <li><strong>Avantage :</strong> DFS est excellent pour explorer les mondes où l’objectif est situé à une grande profondeur (par exemple, dans une grotte éloignée ou dans un temple caché).</li>
                <li><strong>Inconvénient :</strong> DFS peut parfois suivre un chemin non optimal avant de revenir en arrière pour explorer d’autres options.</li>
            </ul>
        
            <h4>Discussion :</h4>
            <ul>
                <li>Comparez DFS avec d’autres algorithmes d’exploration, comme BFS (Breadth-First Search), pour discuter des avantages et inconvénients dans des mondes ouverts.</li>
                <li>Comment pourriez-vous modifier cet algorithme pour permettre une exploration plus "intelligente" dans un monde ouvert ? Par exemple, ajouter une stratégie d’évitement des zones dangereuses ou moins intéressantes.</li>
            </ul>
        </section>

        <section id="session18" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 18 : Applications Réelles des Graphes (Réseaux Sociaux, Chemins dans les Transports)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Dans cette séance, les élèves vont découvrir des applications concrètes de l’utilisation des graphes dans des domaines comme les réseaux sociaux et les systèmes de transport. Ils apprendront à modéliser des situations réelles sous forme de graphes, puis à appliquer des algorithmes de parcours pour résoudre des problèmes spécifiques. Le but est de renforcer la compréhension des graphes à travers des cas pratiques.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Graphes dans le Monde Réel</h3>
            <h4>1. Qu’est-ce qu’un Graphe ?</h4>
            <p>Un graphe est une structure composée de :</p>
            <ul>
                <li><strong>Nœuds (ou sommets) :</strong> représentant des entités (personnes, lieux, stations de transport).</li>
                <li><strong>Arêtes :</strong> les connexions entre les nœuds, représentant des relations (amitié dans les réseaux sociaux, lignes de métro dans un réseau de transport).</li>
            </ul>
            <p>Dans les applications réelles, les graphes peuvent modéliser une grande variété de systèmes complexes.</p>
        
            <h4>2. Applications Réelles des Graphes :</h4>
            <ul>
                <li><strong>Réseaux sociaux :</strong> Les utilisateurs sont les nœuds, et les connexions (amitié, abonnements) sont les arêtes. DFS et BFS peuvent être utilisés pour explorer des groupes d’amis ou des recommandations.</li>
                <li><strong>Réseaux de transport :</strong> Les stations ou arrêts sont des nœuds, et les lignes de transport (bus, métro) sont des arêtes. Les algorithmes de recherche permettent de trouver le chemin le plus court entre deux stations.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étude de Cas 1 : Réseaux Sociaux (40 min)</h3>
            
            <h4>1. Modélisation des Réseaux Sociaux :</h4>
            <p>Dans un réseau social, chaque utilisateur est un **nœud** et chaque relation (amitié, abonnement) est une **arête**. Les graphes permettent de modéliser ces connexions pour résoudre des problèmes comme :</p>
            <ul>
                <li><strong>Explorer des groupes d’amis :</strong> Utilisation de DFS ou BFS pour parcourir un réseau d'amis et suggérer de nouvelles connexions.</li>
                <li><strong>Recommandations :</strong> Utilisation d'algorithmes pour trouver les amis d'amis et recommander de nouveaux contacts.</li>
            </ul>
        
            <h4>2. Exemple Visuel d'un Réseau Social :</h4>
            <pre><code>
    Personne 1 --- Personne 2 --- Personne 3
       |               |               |
    Personne 4 --- Personne 5 --- Personne 6
            </code></pre>
            <p>Chaque personne est représentée comme un nœud, et les liens d’amitié comme des arêtes. L’algorithme peut explorer les connexions d’une personne pour proposer des recommandations.</p>
        
            <h4>3. Algorithme DFS pour Explorer les Amis :</h4>
            <p>On peut utiliser l’algorithme DFS pour explorer les groupes d’amis de manière récursive, à partir d’une personne donnée :</p>
        
            <pre><code>
    def explorer_reseau(graphe, personne, visites):
        if personne not in visites:
            print(f"Exploration de l’ami {personne}")
            visites.add(personne)
            for ami dans graphe[personne]:
                explorer_reseau(graphe, ami, visites)
            </code></pre>
        
            <p>Ce code permet d'explorer tous les amis directs et indirects d'une personne dans le réseau social.</p>
        
            <h4>4. Exemple d'Implémentation en Python :</h4>
            <pre><code>
    reseau_social = {
        "Personne 1": ["Personne 2", "Personne 4"],
        "Personne 2": ["Personne 1", "Personne 3", "Personne 5"],
        "Personne 3": ["Personne 2", "Personne 6"],
        "Personne 4": ["Personne 1", "Personne 5"],
        "Personne 5": ["Personne 2", "Personne 4", "Personne 6"],
        "Personne 6": ["Personne 3", "Personne 5"]
    }
    
    # Ensemble des personnes déjà visitées
    visites = set()
    
    # Lancer l'exploration à partir de "Personne 1"
    explorer_reseau(reseau_social, "Personne 1", visites)
            </code></pre>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez le réseau social pour ajouter des liens d’amitié supplémentaires.</li>
                <li><strong>Étape 2 :</strong> Utilisez DFS pour explorer les amis de "Personne 3" et proposer des amis potentiels (amis d’amis).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étude de Cas 2 : Réseau de Transport (40 min)</h3>
        
            <h4>1. Modélisation d’un Réseau de Transport :</h4>
            <p>Un réseau de transport, comme un réseau de métro ou de bus, peut être modélisé sous forme de graphe :</p>
            <ul>
                <li><strong>Nœuds :</strong> Les stations ou arrêts de bus.</li>
                <li><strong>Arêtes :</strong> Les lignes de transport entre les stations.</li>
            </ul>
        
            <h4>2. Rechercher le Chemin le Plus Court :</h4>
            <p>Dans un réseau de transport, un problème fréquent est de trouver le chemin le plus court entre deux stations. Pour cela, nous utilisons l’algorithme **BFS (Breadth-First Search)**, qui explore tous les voisins d'une station avant de passer aux voisins de niveau supérieur.</p>
        
            <h4>3. Exemple Visuel d’un Réseau de Transport :</h4>
            <pre><code>
    Station A --- Station B --- Station C
        |           |               |
    Station D --- Station E --- Station F
            </code></pre>
            <p>Chaque station est représentée par un nœud, et chaque ligne de transport entre deux stations est une arête.</p>
        
            <h4>Algorithme BFS pour Trouver le Chemin le Plus Court :</h4>
            <p>Nous allons utiliser l’algorithme BFS pour trouver le chemin le plus court entre deux stations :</p>
        
            <pre><code>
    from collections import deque
        
    def bfs_chemin_court(graphe, debut, fin):
        visites = set()  # Ensemble des stations visitées
        queue = deque([(debut, [debut])])  # File d'attente avec le chemin actuel
        
        while queue:
            (station, chemin) = queue.popleft()
            if station == fin:
                return chemin  # Retourner le chemin trouvé
            
            for voisin dans graphe[station]:
                if voisin not in visites:
                    visites.add(voisin)
                    queue.append((voisin, chemin + [voisin]))  # Ajouter le voisin et le chemin parcouru
        return None  # Aucun chemin trouvé
            </code></pre>
        
            <h4>4. Implémentation en Python :</h4>
            <pre><code>
    reseau_transport = {
        "Station A": ["Station B", "Station D"],
        "Station B": ["Station A", "Station C", "Station E"],
        "Station C": ["Station B", "Station F"],
        "Station D": ["Station A", "Station E"],
        "Station E": ["Station B", "Station D", "Station F"],
        "Station F": ["Station C", "Station E"]
    }
    
    chemin = bfs_chemin_court(reseau_transport, "Station A", "Station F")
    print(f"Le chemin le plus court est : {chemin}")
            </code></pre>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Ajoutez de nouvelles lignes de transport dans le réseau.</li>
                <li><strong>Étape 2 :</strong> Utilisez BFS pour trouver le chemin le plus court entre deux stations définies par l’utilisateur.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Comparaison des Applications (10 min)</h3>
            
            <h4>Discussion :</h4>
            <ul>
                <li>Les graphes sont une structure extrêmement polyvalente utilisée dans des domaines très variés, des réseaux sociaux aux transports en passant par la biologie.</li>
                <li>Les algorithmes de parcours comme DFS et BFS permettent de résoudre efficacement des problèmes complexes tels que l’exploration de réseaux ou la recherche de chemins.</li>
                <li>Dans les réseaux sociaux, DFS peut être utilisé pour explorer des relations profondes, tandis que BFS est souvent utilisé pour explorer des connexions plus directes, comme dans les réseaux de transport.</li>
            </ul>
        
            <h4>Problèmes Avancés :</h4>
            <ul>
                <li>Comment optimiser le parcours dans un graphe de grande taille, où chaque nœud peut avoir de nombreux voisins ?</li>
                <li>Comment adapter ces algorithmes pour des applications plus spécifiques, comme la recommandation de contenu ou la gestion du trafic dans un réseau urbain ?</li>
            </ul>
        </section>
        
        <section id="session19" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 19 : Introduction aux Arbres Binaires et leurs Applications</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves découvriront les arbres binaires, leurs propriétés, et leurs applications dans un contexte de jeu vidéo. Ils apprendront à modéliser et à manipuler des arbres binaires, en mettant l'accent sur des applications concrètes comme la gestion d'inventaires dans un jeu ou la recherche rapide d'objets.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Arbres Binaires</h3>
        
            <h4>1. Qu’est-ce qu’un Arbre Binaire ?</h4>
            <p>Un arbre binaire est une structure de données hiérarchique dans laquelle chaque nœud a au maximum deux enfants, appelés <strong>enfant gauche</strong> et <strong>enfant droit</strong>.</p>
            
            <h4>Exemple Visuel :</h4>
            <pre><code>
          8
         / \
        3   10
       / \    \
      1   6   14
         / \   /
        4   7 13
            </code></pre>
            <p>Dans cet exemple, chaque nœud contient une valeur, et chaque nœud peut avoir deux enfants. Le nœud racine est 8, les enfants de 8 sont 3 (à gauche) et 10 (à droite).</p>
        
            <h4>Propriétés des Arbres Binaires :</h4>
            <ul>
                <li>Chaque nœud a au plus deux enfants.</li>
                <li>Les sous-arbres peuvent eux-mêmes être des arbres binaires.</li>
                <li>Un arbre binaire peut être utilisé pour stocker des données ordonnées de manière à permettre des recherches, des insertions et des suppressions rapides.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Applications des Arbres Binaires dans un Jeu Vidéo</h3>
        
            <h4>Contexte du Jeu Vidéo :</h4>
            <p>Dans un jeu vidéo de gestion d'inventaire, chaque objet ramassé par le joueur peut être stocké dans un arbre binaire de recherche (binary search tree, ou BST). Cet arbre permet de rechercher un objet spécifique rapidement, ou de trier les objets par ordre de puissance ou de rareté.</p>
        
            <h4>Exemple d'Application : Gestion d'Inventaire</h4>
            <p>Dans un RPG (jeu de rôle), les objets ramassés par le joueur peuvent être organisés dans un arbre binaire selon leur valeur (par exemple, un objet plus puissant sera placé à droite d'un objet moins puissant). Cela permet de rechercher un objet de manière efficace, ou de lister tous les objets dans l'ordre de leur valeur.</p>
        
            <h4>Modélisation d’un Inventaire avec un Arbre Binaire :</h4>
            <p>Chaque objet dans l’inventaire est un nœud de l’arbre, où :</p>
            <ul>
                <li>La racine de l'arbre est le premier objet ramassé.</li>
                <li>Les objets plus puissants sont placés à droite de l’arbre.</li>
                <li>Les objets moins puissants sont placés à gauche.</li>
            </ul>
        
            <h4>Exemple Visuel avec des Objets :</h4>
            <pre><code>
        Épée de fer (puissance 8)
         /         \
    Bouclier (3)  Arc (10)
                \
             Flèche (14)
            </code></pre>
        
            <p>Dans cet exemple, l'épée de fer est la racine, car elle a été ramassée en premier. Le bouclier, moins puissant, est placé à gauche. L’arc, plus puissant, est placé à droite.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation d’un Arbre Binaire en Python (40 min)</h3>
        
            <h4>1. Représentation d’un Nœud d’Arbre Binaire :</h4>
            <p>Nous allons d’abord définir une classe <code>ArbreBinaire</code> pour représenter chaque nœud de l’arbre binaire.</p>
        
            <pre><code>
    class ArbreBinaire:
        def __init__(self, valeur):
            self.valeur = valeur
            self.gauche = None
            self.droite = None
            </code></pre>
        
            <p>Chaque nœud a une <code>valeur</code> et peut avoir deux enfants : <code>gauche</code> et <code>droite</code>.</p>
        
            <h4>2. Insertion dans un Arbre Binaire :</h4>
            <p>Pour insérer un nouvel objet dans l’arbre binaire, nous allons comparer la valeur de l’objet avec la valeur du nœud courant. Si l’objet est moins puissant (ou de valeur inférieure), il sera inséré à gauche. Sinon, il sera inséré à droite.</p>
        
            <pre><code>
    def inserer(noeud, valeur):
        if noeud is None:
            return ArbreBinaire(valeur)
        
        if valeur < noeud.valeur:
            noeud.gauche = inserer(noeud.gauche, valeur)
        else:
            noeud.droite = inserer(noeud.droite, valeur)
        
        return noeud
            </code></pre>
        
            <h4>3. Exemple d’Insertion dans l’Arbre :</h4>
            <p>Supposons que le joueur ramasse un bouclier avec une puissance de 5 et qu’il l’insère dans l’inventaire :</p>
        
            <pre><code>
    # Créer la racine de l'arbre
    racine = ArbreBinaire(8)
    
    # Insérer d'autres objets dans l'inventaire
    inserer(racine, 3)  # Bouclier
    inserer(racine, 10) # Arc
    inserer(racine, 1)  # Casque
            </code></pre>
        
            <h4>4. Parcours Infixe (In-order Traversal) :</h4>
            <p>Pour lister les objets dans l’ordre de leur puissance, nous utilisons un parcours infixe. Ce parcours visite d’abord le sous-arbre gauche, puis le nœud courant, et enfin le sous-arbre droit.</p>
        
            <pre><code>
    def parcours_infixe(noeud):
        if noeud:
            parcours_infixe(noeud.gauche)
            print(noeud.valeur, end=" ")
            parcours_infixe(noeud.droite)
    
    # Lancer le parcours infixe
    parcours_infixe(racine)
            </code></pre>
        
            <h4>Résultat attendu :</h4>
            <p>Si le joueur a ramassé des objets avec des puissances de 1, 3, 8, et 10, le parcours infixe affichera : <code>1 3 8 10</code>.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Défi Pratique pour les Élèves (30 min)</h3>
        
            <h4>Étape 1 :</h4>
            <p>Modifiez le programme pour que chaque objet ait un nom (par exemple, “Épée de fer”) en plus de sa valeur de puissance. Vous pouvez créer une classe <code>Objet</code> pour représenter chaque objet, et la valeur de puissance sera utilisée pour ordonner les objets dans l’arbre binaire.</p>
        
            <h4>Étape 2 :</h4>
            <p>Ajoutez une fonctionnalité permettant de chercher un objet dans l’arbre par son nom ou sa puissance. Si l’objet est trouvé, affichez ses caractéristiques. Si l’objet n’est pas trouvé, affichez un message indiquant qu’il n’est pas dans l’inventaire.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion (10 min)</h3>
            <p>À la fin de cette séance, les élèves auront appris les concepts fondamentaux des arbres binaires et auront appliqué ces connaissances à un exemple concret de gestion d’inventaire dans un jeu vidéo. Ils auront également renforcé leur compréhension des parcours d’arbres (parcours infixe) et de l’insertion dans un arbre binaire.</p>
            <p>Les élèves pourront utiliser cette structure de données pour d’autres applications dans leurs futurs projets, comme la gestion de données hiérarchiques ou la recherche efficace d’informations.</p>
        </section>

        <section id="session20" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 20 : Pratique - Utilisation d’arbres pour organiser une base de données de personnages de manga</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront à utiliser une structure de données en <strong>arbre binaire de recherche (BST)</strong> pour organiser une base de données de personnages de manga. Ils exploreront comment stocker et rechercher efficacement des informations sur les personnages en fonction de caractéristiques spécifiques (nom, puissance, affiliation).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Arbres Binaires et à leur Utilisation (30 min)</h3>
        
            <h4>Contexte de la Séance :</h4>
            <p>Dans l’univers des mangas, chaque personnage a des caractéristiques uniques (nom, puissance, affiliation, etc.). Nous allons organiser une base de données de personnages en utilisant un <strong>arbre binaire de recherche</strong> pour permettre des opérations de recherche rapide, d’ajout et de suppression de personnages.</p>
        
            <h4>Qu'est-ce qu'un Arbre Binaire de Recherche (BST) ?</h4>
            <p>Un <strong>arbre binaire de recherche (BST)</strong> est une structure de données récursive qui permet de stocker des données de manière ordonnée, facilitant ainsi les opérations de recherche, d'insertion et de suppression.</p>
            <ul>
                <li><strong>Nœud :</strong> Chaque nœud de l'arbre contient un élément (par exemple, un personnage de manga).</li>
                <li><strong>Clé :</strong> Chaque nœud a une clé (par exemple, le nom du personnage ou un autre attribut) qui est utilisée pour organiser l’arbre.</li>
                <li><strong>Arbre binaire :</strong> Chaque nœud a au plus deux enfants : un enfant à gauche (plus petit) et un enfant à droite (plus grand).</li>
            </ul>
        
            <h4>Principe du BST :</h4>
            <p>Dans un BST :</p>
            <ul>
                <li>Pour chaque nœud, tous les éléments dans le sous-arbre gauche sont plus petits que l’élément du nœud.</li>
                <li>Tous les éléments dans le sous-arbre droit sont plus grands que l’élément du nœud.</li>
            </ul>
        
            <h4>Exemple Visuel d’un Arbre Binaire de Recherche :</h4>
            <pre><code>
            Luffy
            /    \
         Goku    Naruto
         /  \       /   \
    Zoro Vegeta   Sasuke  Saitama
            </code></pre>
            <p>Dans cet arbre :</p>
            <ul>
                <li>Le personnage Luffy est la racine.</li>
                <li>Les personnages situés à gauche de Luffy (Goku, Zoro) ont des noms plus petits (ordre alphabétique), tandis que ceux situés à droite (Naruto, Saitama) ont des noms plus grands.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation Pratique d’un Arbre Binaire de Recherche (BST) (45 min)</h3>
        
            <h4>1. Créer une Classe pour Représenter un Personnage de Manga :</h4>
            <p>Chaque personnage sera représenté par un objet contenant des informations telles que son nom, sa puissance et son affiliation.</p>
        
            <pre><code>
    class PersonnageManga:
        def __init__(self, nom, puissance, affiliation):
            self.nom = nom
            self.puissance = puissance
            self.affiliation = affiliation
            self.gauche = None  # Sous-arbre gauche
            self.droite = None  # Sous-arbre droit
    
        def __str__(self):
            return f"{self.nom} - Puissance : {self.puissance}, Affiliation : {self.affiliation}"
            </code></pre>
        
            <p>Chaque instance de <code>PersonnageManga</code> représente un personnage avec un nom, une puissance et une affiliation.</p>
        
            <h4>2. Créer un Arbre Binaire de Recherche :</h4>
            <p>L’arbre binaire de recherche sera utilisé pour organiser les personnages en fonction de leur nom. Chaque nœud de l’arbre contiendra un personnage de manga.</p>
        
            <pre><code>
    class ArbreBinaireRecherche:
        def __init__(self):
            self.racine = None  # La racine de l'arbre est initialement vide
    
        # Fonction pour insérer un nouveau personnage dans l'arbre
        def inserer(self, personnage):
            if self.racine is None:
                self.racine = personnage  # Si l'arbre est vide, le personnage devient la racine
            else:
                self._inserer_recur(self.racine, personnage)
    
        # Fonction récursive pour insérer dans le bon sous-arbre
        def _inserer_recur(self, courant, personnage):
            if personnage.nom < courant.nom:
                if courant.gauche is None:
                    courant.gauche = personnage  # Insertion à gauche
                else:
                    self._inserer_recur(courant.gauche, personnage)  # Récursion vers la gauche
            else:
                if courant.droite is None:
                    courant.droite = personnage  # Insertion à droite
                else:
                    self._inserer_recur(courant.droite, personnage)  # Récursion vers la droite
    
        # Fonction pour afficher l'arbre en parcours infixe (ordre alphabétique)
        def afficher_infixe(self):
            self._afficher_infixe_recur(self.racine)
    
        def _afficher_infixe_recur(self, courant):
            if courant is not None:
                self._afficher_infixe_recur(courant.gauche)
                print(courant)
                self._afficher_infixe_recur(courant.droite)
            </code></pre>
        
            <p>Cette classe permet d’ajouter des personnages dans l’arbre et de les afficher dans l’ordre alphabétique grâce à un parcours en infixe.</p>
        
            <h4>3. Insérer des Personnages dans l’Arbre :</h4>
            <p>Ajoutons des personnages célèbres de mangas dans notre arbre :</p>
        
            <pre><code>
    # Création de l'arbre
    arbre = ArbreBinaireRecherche()
    
    # Création des personnages
    luffy = PersonnageManga("Luffy", 9000, "Pirate")
    goku = PersonnageManga("Goku", 9500, "Guerrier Saiyan")
    naruto = PersonnageManga("Naruto", 8800, "Ninja")
    saitama = PersonnageManga("Saitama", 10000, "Héros")
    zoro = PersonnageManga("Zoro", 8500, "Pirate")
    vegeta = PersonnageManga("Vegeta", 9400, "Guerrier Saiyan")
    
    # Insertion dans l'arbre
    arbre.inserer(luffy)
    arbre.inserer(goku)
    arbre.inserer(naruto)
    arbre.inserer(saitama)
    arbre.inserer(zoro)
    arbre.inserer(vegeta)
    
    # Affichage des personnages dans l'ordre alphabétique
    arbre.afficher_infixe()
            </code></pre>
        
            <p>La sortie du programme affichera les personnages par ordre alphabétique de nom :</p>
        
            <pre><code>
    Goku - Puissance : 9500, Affiliation : Guerrier Saiyan
    Luffy - Puissance : 9000, Affiliation : Pirate
    Naruto - Puissance : 8800, Affiliation : Ninja
    Saitama - Puissance : 10000, Affiliation : Héros
    Vegeta - Puissance : 9400, Affiliation : Guerrier Saiyan
    Zoro - Puissance : 8500, Affiliation : Pirate
            </code></pre>
        
            <h4>4. Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez le programme pour que l’arbre soit organisé en fonction de la puissance des personnages au lieu de leur nom.</li>
                <li><strong>Étape 2 :</strong> Ajoutez une fonction pour rechercher un personnage par nom dans l’arbre et renvoyer ses caractéristiques.</li>
                <li><strong>Étape 3 :</strong> Ajoutez une fonctionnalité pour supprimer un personnage de l’arbre (utilisation d’un algorithme de suppression dans un arbre binaire).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Applications (10 min)</h3>
        
            <p>À la fin de cette séance, les élèves auront appris à :</p>
            <ul>
                <li>Utiliser un <strong>arbre binaire de recherche</strong> pour organiser et gérer des données de manière structurée et efficace.</li>
                <li>Implémenter les opérations de base d’un arbre (insertion, parcours, recherche) dans un contexte de gestion de base de données de personnages de manga.</li>
            </ul>
        
            <p>Cette approche leur permettra de comprendre comment les structures de données avancées sont utilisées pour organiser de grandes quantités de données dans des applications réelles, telles que les bases de données et les systèmes de recherche d’information.</p>
        </section>
        
        <section id="session21" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 21 : Algorithmes de Parcours d’Arbres (Pré-ordre, En-ordre, Post-ordre)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront et mettront en pratique les trois principales méthodes de parcours d’arbres binaires : pré-ordre, en-ordre, et post-ordre. Ils exploreront ces algorithmes dans le contexte d'un jeu vidéo où un personnage doit explorer des niveaux structurés sous forme d'arbres (arborescence de décisions, exploration d’environnements hiérarchiques).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Arbres Binaires et Parcours</h3>
            <h4>Le Contexte du Jeu Vidéo :</h4>
            <p>Dans un jeu vidéo d'exploration, un personnage évolue dans une série de niveaux ou d’environnements reliés entre eux de manière hiérarchique. Chaque environnement peut être modélisé sous forme d’arbre binaire :</p>
            <ul>
                <li><strong>Nœuds :</strong> représentent des zones ou des objectifs dans le jeu (par exemple, des salles, des missions, ou des ennemis).</li>
                <li><strong>Branches (arêtes) :</strong> relient deux nœuds et représentent les chemins ou les transitions possibles entre les différentes zones ou objectifs.</li>
            </ul>
            <p>Le joueur doit explorer l’arbre en visitant chaque nœud en suivant un parcours spécifique. Nous allons explorer trois types de parcours : pré-ordre, en-ordre, et post-ordre.</p>
        
            <h4>Définition d’un Arbre Binaire :</h4>
            <ul>
                <li><strong>Nœud Racine :</strong> Le point de départ de l’arbre.</li>
                <li><strong>Nœuds Fils :</strong> Deux sous-arbres, le fils gauche et le fils droit.</li>
                <li><strong>Feuille :</strong> Un nœud sans fils.</li>
            </ul>
        
            <h4>Exemple d’Arbre Binaire :</h4>
            <pre><code>
                A
               / \
              B   C
             / \   \
            D   E   F
            </code></pre>
            <p>Dans cet arbre, A est la racine, B et C sont ses enfants, et D, E, F sont des feuilles.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Algorithmes de Parcours d’Arbres (30 min)</h3>
            
            <h4>1. Parcours en Pré-ordre (Prefix Traversal) :</h4>
            <p>Le parcours en pré-ordre explore un arbre en visitant d’abord le nœud racine, puis le sous-arbre gauche, puis le sous-arbre droit. Il suit l’ordre suivant :</p>
            <ul>
                <li>Visiter la racine</li>
                <li>Explorer le sous-arbre gauche</li>
                <li>Explorer le sous-arbre droit</li>
            </ul>
            
            <h4>Exemple Visuel du Parcours en Pré-ordre :</h4>
            <pre><code>
                A
               / \
              B   C
             / \   \
            D   E   F
            
            Parcours pré-ordre : A → B → D → E → C → F
            </code></pre>
            
            <h4>Pseudo-code du Parcours en Pré-ordre :</h4>
            <pre><code>
        def parcours_preordre(noeud):
            if noeud:
                print(noeud.valeur)  # Visiter la racine
                parcours_preordre(noeud.gauche)  # Explorer le sous-arbre gauche
                parcours_preordre(noeud.droite)  # Explorer le sous-arbre droit
            </code></pre>
        
            <h4>Explication :</h4>
            <ul>
                <li>La racine est visitée en premier.</li>
                <li>Le sous-arbre gauche est entièrement exploré avant de passer au sous-arbre droit.</li>
            </ul>
        
            <h4>2. Parcours en En-ordre (Infix Traversal) :</h4>
            <p>Le parcours en en-ordre explore l’arbre en visitant d’abord le sous-arbre gauche, puis la racine, puis le sous-arbre droit. Il suit l’ordre suivant :</p>
            <ul>
                <li>Explorer le sous-arbre gauche</li>
                <li>Visiter la racine</li>
                <li>Explorer le sous-arbre droit</li>
            </ul>
        
            <h4>Exemple Visuel du Parcours en En-ordre :</h4>
            <pre><code>
                A
               / \
              B   C
             / \   \
            D   E   F
            
            Parcours en-ordre : D → B → E → A → C → F
            </code></pre>
        
            <h4>Pseudo-code du Parcours en En-ordre :</h4>
            <pre><code>
        def parcours_enordre(noeud):
            if noeud:
                parcours_enordre(noeud.gauche)  # Explorer le sous-arbre gauche
                print(noeud.valeur)  # Visiter la racine
                parcours_enordre(noeud.droite)  # Explorer le sous-arbre droit
            </code></pre>
        
            <h4>Explication :</h4>
            <ul>
                <li>Le sous-arbre gauche est entièrement exploré avant de visiter la racine.</li>
                <li>Le sous-arbre droit est visité en dernier.</li>
            </ul>
        
            <h4>3. Parcours en Post-ordre (Postfix Traversal) :</h4>
            <p>Le parcours en post-ordre explore l’arbre en visitant d’abord le sous-arbre gauche, puis le sous-arbre droit, et enfin la racine. Il suit l’ordre suivant :</p>
            <ul>
                <li>Explorer le sous-arbre gauche</li>
                <li>Explorer le sous-arbre droit</li>
                <li>Visiter la racine</li>
            </ul>
        
            <h4>Exemple Visuel du Parcours en Post-ordre :</h4>
            <pre><code>
                A
               / \
              B   C
             / \   \
            D   E   F
            
            Parcours post-ordre : D → E → B → F → C → A
            </code></pre>
        
            <h4>Pseudo-code du Parcours en Post-ordre :</h4>
            <pre><code>
        def parcours_postordre(noeud):
            if noeud:
                parcours_postordre(noeud.gauche)  # Explorer le sous-arbre gauche
                parcours_postordre(noeud.droite)  # Explorer le sous-arbre droit
                print(noeud.valeur)  # Visiter la racine
            </code></pre>
        
            <h4>Explication :</h4>
            <ul>
                <li>Les deux sous-arbres sont explorés avant de visiter la racine.</li>
                <li>Le parcours en post-ordre est souvent utilisé dans les contextes où des sous-arbres doivent être traités avant leur racine.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique dans le Contexte du Jeu Vidéo (40 min)</h3>
        
            <h4>1. Représentation d’un Arbre en Python :</h4>
            <p>Dans ce jeu vidéo, nous allons modéliser une série de niveaux interconnectés sous forme d’arbre binaire. Voici une classe Python pour représenter un nœud dans l’arbre :</p>
        
            <pre><code>
        class Noeud:
            def __init__(self, valeur):
                self.valeur = valeur
                self.gauche = None
                self.droite = None
        
        # Créer un exemple d'arbre
        racine = Noeud('A')
        racine.gauche = Noeud('B')
        racine.droite = Noeud('C')
        racine.gauche.gauche = Noeud('D')
        racine.gauche.droite = Noeud('E')
        racine.droite.droite = Noeud('F')
            </code></pre>
        
            <h4>2. Implémentation des Trois Parcours :</h4>
            <p>Les élèves implémenteront les trois types de parcours (pré-ordre, en-ordre, post-ordre) en Python, à partir de la structure d'arbre ci-dessus.</p>
        
            <pre><code>
        def parcours_preordre(noeud):
            if noeud:
                print(noeud.valeur)
                parcours_preordre(noeud.gauche)
                parcours_preordre(noeud.droite)
        
        def parcours_enordre(noeud):
            if noeud:
                parcours_enordre(noeud.gauche)
                print(noeud.valeur)
                parcours_enordre(noeud.droite)
        
        def parcours_postordre(noeud):
            if noeud:
                parcours_postordre(noeud.gauche)
                parcours_postordre(noeud.droite)
                print(noeud.valeur)
            </code></pre>
        
            <h4>Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Implémentez les trois parcours et testez-les sur l’arbre fourni.</li>
                <li><strong>Étape 2 :</strong> Modifiez l’arbre pour ajouter plus de niveaux et des valeurs différentes.</li>
                <li><strong>Étape 3 :</strong> Modélisez un système de progression dans un jeu vidéo où chaque nœud représente une mission ou un niveau, et le joueur suit un parcours spécifique (par exemple, post-ordre pour accomplir toutes les missions avant de rencontrer le boss final).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Comparaison (10 min)</h3>
            <p>À la fin de cette séance, les élèves auront appris à appliquer les trois parcours d’arbres dans différents contextes, et auront compris comment chaque type de parcours peut être utile selon le problème à résoudre. Ils auront également renforcé leur compréhension de la récursivité et de la structure des arbres binaires.</p>
        </section>

        <section id="session22" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 22 : Approfondissement sur les Algorithmes de Parcours d’Arbres</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront les différentes méthodes de parcours d’arbres, incluant les parcours en profondeur (pré-ordre, en ordre, post-ordre) et en largeur. Ces parcours seront appliqués dans un contexte pratique de jeu vidéo, où les structures d’arbres peuvent représenter des niveaux de jeu, des décisions ou des quêtes à accomplir.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Arbres et Parcours d'Arbres</h3>
            
            <h4>Contexte du Jeu Vidéo :</h4>
            <p>Dans un jeu vidéo, un arbre peut représenter différentes structures de jeu. Par exemple :</p>
            <ul>
                <li>Un arbre de quêtes, où chaque nœud représente une quête que le joueur doit accomplir avant de passer à la suivante.</li>
                <li>Un arbre de niveaux, où chaque nœud est un niveau, et le joueur doit explorer les niveaux dans un ordre spécifique.</li>
                <li>Un arbre de décision, où chaque nœud est une action possible, et chaque branche représente une conséquence ou un choix.</li>
            </ul>
            <p>Nous allons étudier comment parcourir ces arbres de manière systématique en utilisant plusieurs algorithmes de parcours.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Types de Parcours d'Arbres</h3>
            
            <p>Il existe deux grandes catégories de parcours d'arbres :</p>
            <ul>
                <li><strong>Parcours en profondeur</strong> (Depth-First Search) :</li>
                <ul>
                    <li><strong>Pré-ordre (Préfixe)</strong> : Visite du nœud courant, puis des sous-arbres gauche et droit.</li>
                    <li><strong>En ordre (Infixe)</strong> : Visite du sous-arbre gauche, du nœud courant, puis du sous-arbre droit.</li>
                    <li><strong>Post-ordre (Suffixe)</strong> : Visite des sous-arbres gauche et droit, puis du nœud courant.</li>
                </ul>
                <li><strong>Parcours en largeur</strong> (Breadth-First Search) :</li>
                <ul>
                    <li>Parcours de chaque niveau de l’arbre un par un, en commençant par la racine, puis les nœuds enfants de gauche à droite.</li>
                </ul>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Explications et Pseudo-code pour chaque Type de Parcours</h3>
        
            <h4>Parcours en Profondeur – Pré-ordre, En Ordre, Post-ordre</h4>
        
            <h5>Pré-ordre</h5>
            <p>Le parcours pré-ordre commence par le nœud courant, puis explore le sous-arbre gauche et enfin le sous-arbre droit. C'est utile dans des jeux où l’on doit visiter une action ou une quête principale avant de passer aux étapes suivantes.</p>
            <pre><code>def parcours_pre_ordre(noeud):
            if noeud is not None:
                print(noeud.valeur)  # Visiter le nœud courant
                parcours_pre_ordre(noeud.gauche)
                parcours_pre_ordre(noeud.droit)
            </code></pre>
        
            <h5>En Ordre</h5>
            <p>Le parcours en ordre explore d'abord le sous-arbre gauche, puis le nœud courant, et enfin le sous-arbre droit. C'est couramment utilisé pour obtenir les valeurs d’un arbre binaire dans un ordre trié.</p>
            <pre><code>def parcours_en_ordre(noeud):
            if noeud is not None:
                parcours_en_ordre(noeud.gauche)
                print(noeud.valeur)  # Visiter le nœud courant
                parcours_en_ordre(noeud.droit)
            </code></pre>
        
            <h5>Post-ordre</h5>
            <p>Le parcours post-ordre commence par explorer les sous-arbres gauche et droit, puis visite le nœud courant. Cela peut être utile pour des jeux où chaque action nécessite d'accomplir des sous-tâches avant de valider la tâche principale.</p>
            <pre><code>def parcours_post_ordre(noeud):
            if noeud is not None:
                parcours_post_ordre(noeud.gauche)
                parcours_post_ordre(noeud.droit)
                print(noeud.valeur)  # Visiter le nœud courant
            </code></pre>
        
            <h4>Parcours en Largeur (BFS)</h4>
            <p>Dans le parcours en largeur, l’algorithme explore les nœuds niveau par niveau, en commençant par la racine. Cela peut être utile pour explorer chaque niveau de décision ou de quête dans un ordre croissant.</p>
            <pre><code>from collections import deque
        
        def parcours_largeur(noeud):
            queue = deque([noeud])  # Utilisation d'une file d'attente
            while queue:
                courant = queue.popleft()
                print(courant.valeur)  # Visiter le nœud courant
                if courant.gauche:
                    queue.append(courant.gauche)
                if courant.droit:
                    queue.append(courant.droit)
            </code></pre>
        
            <h4>Exemple d’Arbre :</h4>
            <p>Considérons l’arbre suivant pour illustrer chaque type de parcours :</p>
            <pre><code>       A
             /     \
            B       C
           / \     / \
          D   E   F   G
            </code></pre>
            <p>Les résultats des parcours seraient :</p>
            <ul>
                <li><strong>Pré-ordre :</strong> A, B, D, E, C, F, G</li>
                <li><strong>En ordre :</strong> D, B, E, A, F, C, G</li>
                <li><strong>Post-ordre :</strong> D, E, B, F, G, C, A</li>
                <li><strong>Largeur :</strong> A, B, C, D, E, F, G</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Mise en Pratique : Application au Jeu Vidéo</h3>
            
            <h4>Exercice Pratique :</h4>
            <p>Imaginons que chaque nœud de cet arbre représente une <strong>quête</strong> dans un jeu. L’objectif est de parcourir toutes les quêtes dans un ordre spécifique :</p>
            <ul>
                <li><strong>Pré-ordre :</strong> Le joueur doit accomplir les quêtes principales avant d’entrer dans les sous-quêtes.</li>
                <li><strong>En ordre :</strong> Le joueur doit accomplir toutes les quêtes de gauche à droite dans un ordre séquentiel.</li>
                <li><strong>Post-ordre :</strong> Le joueur doit terminer toutes les sous-quêtes avant de terminer la quête principale.</li>
                <li><strong>Largeur :</strong> Le joueur explore chaque niveau de l’arbre (comme explorer tous les niveaux d’une tour étage par étage).</li>
            </ul>
        
            <h4>Implémentation en Python :</h4>
            <p>Pour cet exercice, créez un arbre de quêtes, où chaque nœud contient une quête spécifique. Implémentez chaque type de parcours pour que le joueur puisse explorer les quêtes dans un ordre défini.</p>
            
            <pre><code>class Noeud:
            def __init__(self, valeur):
                self.valeur = valeur
                self.gauche = None
                self.droit = None
        
        # Créer l'arbre de quêtes
        racine = Noeud("A")
        racine.gauche = Noeud("B")
        racine.droit = Noeud("C")
        racine.gauche.gauche = Noeud("D")
        racine.gauche.droit = Noeud("E")
        racine.droit.gauche = Noeud("F")
        racine.droit.droit = Noeud("G")
            </code></pre>
        
            <p>Implémentez ensuite chaque parcours :</p>
        
            <pre><code># Parcours pré-ordre
        parcours_pre_ordre(racine)
        
        # Parcours en ordre
        parcours_en_ordre(racine)
        
        # Parcours post-ordre
        parcours_post_ordre(racine)
        
        # Parcours en largeur
        parcours_largeur(racine)
            </code></pre>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Ajoutez des actions dans chaque quête et modifiez les parcours pour afficher l'action correspondante dans chaque nœud visité.</li>
                <li><strong>Étape 2 :</strong> Modifiez l’arbre pour que certaines quêtes aient plusieurs sous-quêtes, puis testez chaque type de parcours.</li>
                <li><strong>Étape 3 :</strong> Faites en sorte que le parcours en largeur (BFS) limite le joueur à explorer uniquement les quêtes d'un certain niveau avant de passer au niveau suivant.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Comparaison des Parcours d’Arbres</h3>
        
            <p>À la fin de cette séance, les élèves auront exploré plusieurs types de parcours d’arbres, chacun ayant ses propres applications et avantages. Ils comprendront comment appliquer ces parcours dans des contextes variés comme la gestion de quêtes et de niveaux dans les jeux vidéo.</p>
        
            <h4>Comparaison des Parcours :</h4>
            <ul>
                <li><strong>Pré-ordre :</strong> Visite immédiate des actions principales, suivi des sous-quêtes.</li>
                <li><strong>En ordre :</strong> Exploration naturelle pour afficher un arbre binaire dans un ordre trié.</li>
                <li><strong>Post-ordre :</strong> Exécution des sous-tâches avant de valider la tâche principale.</li>
                <li><strong>Largeur :</strong> Parcours niveau par niveau, idéal pour explorer toutes les options accessibles au joueur avant de descendre plus loin.</li>
            </ul>
        
            <h4>Discussion et Applications :</h4>
            <p>Ces algorithmes de parcours sont utilisés non seulement dans les jeux, mais aussi dans d’autres domaines comme les bases de données et l’intelligence artificielle pour l’exploration de structures de décision et la recherche.</p>
        </section>

        <section id="session23" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 23 : Pratique - Création d’un Arbre de Décision pour un Jeu de Rôle (Jeu Vidéo)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront à créer et utiliser un <strong>arbre de décision</strong> pour gérer les décisions d'un personnage non joueur (PNJ) dans un jeu de rôle. Un arbre de décision permet de modéliser les choix que le PNJ peut faire en fonction des actions du joueur et des situations rencontrées dans le jeu.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Arbres de Décision</h3>
        
            <h4>Contexte du Jeu de Rôle :</h4>
            <p>Dans un jeu de rôle, un PNJ peut être programmé pour réagir de différentes manières aux actions du joueur. Par exemple, un PNJ garde pourrait décider de laisser passer le joueur, de le combattre, ou de lui poser une question, en fonction de certains critères (comme le niveau du joueur, son arme, ou son alignement).</p>
            <p>Pour modéliser ces comportements, nous allons utiliser un <strong>arbre de décision</strong> qui permet de structurer les choix possibles et d'orienter les décisions du PNJ en fonction de plusieurs conditions.</p>
        
            <h4>Qu'est-ce qu'un Arbre de Décision ?</h4>
            <p>Un arbre de décision est une structure en forme d’arbre où :</p>
            <ul>
                <li>Chaque <strong>nœud</strong> représente une question ou un test conditionnel.</li>
                <li>Chaque <strong>branche</strong> représente le résultat possible de la question (oui/non, vrai/faux, etc.).</li>
                <li>Chaque <strong>feuille</strong> (nœud terminal) représente une action ou une décision.</li>
            </ul>
            <p>Les arbres de décision permettent de diviser un problème complexe en une série de choix simples.</p>
        
            <h4>Exemple Visuel d'un Arbre de Décision :</h4>
            <pre><code>
                                Est-ce que le joueur est armé ?
                               /                       \
                           Oui                           Non
                          /                                \
            Le joueur a une arme puissante ?           Saluer le joueur
                 /              \
               Oui               Non
         Combattre le joueur   Poser une question
            </code></pre>
            <p>Dans cet exemple, le PNJ prend des décisions en fonction de l'état du joueur (armé ou non) et du type d'arme qu'il possède.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Construction d'un Arbre de Décision en Python (30 min)</h3>
            <h4>1. Modéliser l'Arbre de Décision avec des Classes :</h4>
            <p>Pour construire un arbre de décision, nous allons utiliser des <strong>classes</strong> pour représenter les nœuds de décision et les actions. Chaque nœud posera une question, et en fonction de la réponse, il pointera vers un autre nœud ou une action.</p>
        
            <pre><code>class NoeudDecision:
            def __init__(self, question, oui=None, non=None):
                self.question = question  # Question posée dans ce nœud
                self.oui = oui            # Branche oui
                self.non = non            # Branche non
        
        class Action:
            def __init__(self, description):
                self.description = description  # Description de l'action
        
        def executer_arbre(noeud):
            if isinstance(noeud, Action):
                print(noeud.description)
            else:
                reponse = input(noeud.question + " (oui/non) : ")
                if reponse == "oui":
                    executer_arbre(noeud.oui)
                else:
                    executer_arbre(noeud.non)
            </code></pre>
        
            <h4>2. Création de l'Arbre de Décision :</h4>
            <p>À présent, construisons un arbre de décision simple pour un PNJ gardien dans un jeu. Le gardien décidera d'agir en fonction de plusieurs conditions : si le joueur est armé, et si son arme est puissante ou non.</p>
        
            <pre><code># Feuilles de l'arbre de décision (actions)
        saluer = Action("Le PNJ vous salue.")
        poser_question = Action("Le PNJ vous pose une question.")
        combattre = Action("Le PNJ engage le combat.")
        
        # Nœuds de décision
        arme_puissante = NoeudDecision("Le joueur a-t-il une arme puissante ?", oui=combattre, non=poser_question)
        joueur_arme = NoeudDecision("Le joueur est-il armé ?", oui=arme_puissante, non=saluer)
        
        # Exécution de l'arbre de décision
        print("Interaction avec le PNJ :")
        executer_arbre(joueur_arme)
            </code></pre>
        
            <h4>Explication du Code :</h4>
            <ul>
                <li>Les classes <code>NoeudDecision</code> et <code>Action</code> permettent de construire l'arbre de décision.</li>
                <li>Les feuilles (actions) comme <code>saluer</code>, <code>poser_question</code>, et <code>combattre</code> définissent ce que le PNJ fera en fonction de la situation.</li>
                <li>Les nœuds de décision, comme <code>joueur_arme</code>, posent des questions pour déterminer l'action finale.</li>
            </ul>
        
            <h4>Test de l’Arbre de Décision :</h4>
            <p>Exécutez le code et répondez aux questions pour simuler une interaction avec le PNJ. Selon vos réponses, le PNJ prendra une décision appropriée.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Extension Pratique : Complexifier l'Arbre (20 min)</h3>
            <ul>
                <li><strong>Étape 1 :</strong> Ajoutez d’autres critères, par exemple, si le joueur possède un objet spécial ou s’il a une attitude pacifique.</li>
                <li><strong>Étape 2 :</strong> Complexifiez l'arbre pour introduire plus de décisions, par exemple :
                    <ul>
                        <li>Si le joueur est blessé, le PNJ peut offrir de l’aide.</li>
                        <li>Si le joueur a une réputation élevée, le PNJ le laisse passer sans poser de questions.</li>
                    </ul>
                </li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion (10 min)</h3>
            <p>À la fin de cette séance, les élèves auront appris à créer et à utiliser un arbre de décision pour gérer les comportements d’un PNJ dans un jeu vidéo. Ils comprendront comment utiliser des conditions imbriquées pour modéliser des choix complexes et permettront ainsi aux PNJ d'avoir des réactions variées selon les actions du joueur.</p>
        
            <p>Les arbres de décision sont un outil puissant en intelligence artificielle, notamment dans le développement de jeux vidéo, où les personnages doivent réagir de manière crédible à de nombreux scénarios possibles.</p>
        </section>
        
        <section id="session24" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 24 : Analyse des performances et avantages des arbres dans la recherche et le tri</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves vont explorer les avantages des arbres binaires, en particulier des <strong>arbres binaires de recherche</strong> (BST -> Binary Search Tree) et des <strong>arbres équilibrés</strong>, pour les opérations de recherche et de tri. Ils apprendront pourquoi et comment les arbres optimisent ces opérations en termes de complexité, et compareront les performances de l'arbre binaire avec d’autres structures de données comme les listes.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Arbres Binaires</h3>
        
            <h4>Définition d'un Arbre Binaire :</h4>
            <p>Un arbre binaire est une structure de données hiérarchique composée de <strong>nœuds</strong>. Chaque nœud possède au maximum deux <strong>enfants</strong>, généralement appelés enfant gauche et enfant droit.</p>
            
            <p>Les arbres binaires sont utilisés dans de nombreux algorithmes de recherche et de tri, car ils permettent de stocker les données de manière structurée et de faciliter la recherche.</p>
        
            <h4>Arbre Binaire de Recherche (BST) :</h4>
            <p>Un arbre binaire de recherche (BST) est un type spécifique d’arbre binaire où chaque nœud suit une règle importante :</p>
            <ul>
                <li>Les nœuds de l’arbre à gauche d’un nœud contiennent des valeurs plus petites.</li>
                <li>Les nœuds de l’arbre à droite d’un nœud contiennent des valeurs plus grandes.</li>
            </ul>
        
            <p>Cette structure permet d’accélérer les opérations de recherche en réduisant l’espace de recherche de moitié à chaque étape.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Avantages des Arbres Binaires dans la Recherche et le Tri (20 min)</h3>
            
            <h4>1. Recherche dans un BST :</h4>
            <p>Dans un arbre binaire de recherche, les opérations de recherche sont efficaces grâce à la structure organisée des nœuds. Pour rechercher un élément, on commence à la racine et on compare :</p>
            <ul>
                <li>Si la valeur recherchée est plus petite que le nœud courant, on se dirige vers le sous-arbre gauche.</li>
                <li>Si la valeur recherchée est plus grande, on se dirige vers le sous-arbre droit.</li>
            </ul>
        
            <p>Cette approche permet de réduire le nombre de comparaisons et rend la recherche rapide.</p>
        
            <h4>2. Complexité de la Recherche dans un BST :</h4>
            <p>Pour un arbre équilibré, la recherche dans un BST a une complexité moyenne de <code>O(log n)</code>. Cependant, dans le pire des cas (un arbre non équilibré où tous les nœuds sont dans une seule direction), la complexité peut atteindre <code>O(n)</code>.</p>
        
            <h4>3. Tri à l’aide d’un BST :</h4>
            <p>Les arbres binaires de recherche peuvent également être utilisés pour trier des données :</p>
            <ul>
                <li>On insère chaque élément dans le BST.</li>
                <li>En effectuant un parcours en ordre (in-order traversal), on obtient les éléments triés dans l'ordre croissant.</li>
            </ul>
            
            <p>Ce tri est efficace pour les petites structures ou lorsque les données sont progressivement ajoutées.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation d’un Arbre Binaire de Recherche (30 min)</h3>
        
            <h4>1. Structure de l’Arbre Binaire de Recherche :</h4>
            <p>Voici une représentation simple d'un nœud dans un arbre binaire de recherche :</p>
            
            <pre><code>class Noeud:
            def __init__(self, valeur):
                self.valeur = valeur
                self.gauche = None
                self.droite = None
        </code></pre>
        
            <h4>2. Insertion dans un BST :</h4>
            <p>L'insertion d'une valeur dans un arbre binaire de recherche suit la règle du BST :</p>
            <ul>
                <li>Si la valeur est inférieure au nœud courant, on l'insère dans le sous-arbre gauche.</li>
                <li>Si la valeur est supérieure, on l'insère dans le sous-arbre droit.</li>
            </ul>
            
            <pre><code>def inserer(noeud, valeur):
            if noeud is None:
                return Noeud(valeur)
            if valeur < noeud.valeur:
                noeud.gauche = inserer(noeud.gauche, valeur)
            else:
                noeud.droite = inserer(noeud.droite, valeur)
            return noeud
        </code></pre>
        
            <h4>3. Recherche dans un BST :</h4>
            <p>La fonction de recherche parcourt l’arbre de manière récursive pour trouver la valeur cible :</p>
        
            <pre><code>def rechercher(noeud, valeur):
            if noeud is None or noeud.valeur == valeur:
                return noeud
            if valeur < noeud.valeur:
                return rechercher(noeud.gauche, valeur)
            return rechercher(noeud.droite, valeur)
        </code></pre>
        
            <h4>4. Parcours en Ordre (In-order Traversal) :</h4>
            <p>Un parcours en ordre permet de récupérer les éléments dans l'ordre croissant :</p>
        
            <pre><code>def parcours_en_ordre(noeud):
            if noeud is not None:
                parcours_en_ordre(noeud.gauche)
                print(noeud.valeur, end=" ")
                parcours_en_ordre(noeud.droite)
        </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Applications Pratiques et Comparaisons (30 min)</h3>
        
            <h4>Exercice Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Créer un arbre binaire de recherche en insérant une liste de valeurs.</li>
                <li><strong>Étape 2 :</strong> Effectuer une recherche pour vérifier si des valeurs spécifiques sont présentes.</li>
                <li><strong>Étape 3 :</strong> Effectuer un parcours en ordre pour afficher les valeurs triées.</li>
            </ul>
        
            <h4>Comparaison avec d'autres Structures :</h4>
            <p>Les arbres binaires de recherche (BST) sont souvent plus efficaces que les listes pour les opérations de recherche et de tri, car :</p>
            <ul>
                <li><strong>Recherche :</strong> Une recherche dans une liste non triée a une complexité de <code>O(n)</code>, tandis que la recherche dans un BST équilibré est en <code>O(log n)</code>.</li>
                <li><strong>Tri :</strong> Les BST permettent de trier des données dynamiquement lors de leur insertion, sans avoir besoin d’un tri supplémentaire.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Points Clés</h3>
            <ul>
                <li>Les arbres binaires de recherche sont des structures efficaces pour la recherche et le tri.</li>
                <li>Pour maintenir les performances en <code>O(log n)</code>, un arbre binaire doit rester équilibré. Dans le cas contraire, l’arbre peut se transformer en une liste chaînée et perdre son efficacité.</li>
                <li>Les arbres équilibrés (comme les arbres AVL ou Red-Black) sont souvent utilisés en pratique pour garantir des performances optimales.</li>
            </ul>
        </section>

        <section id="session25" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 25 : Introduction au Tri Rapide (Quicksort)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Dans cette séance, les élèves vont découvrir et implémenter l'algorithme de tri rapide, ou Quicksort, un des algorithmes de tri les plus rapides et efficaces. L’objectif est de comprendre comment Quicksort divise une liste de nombres en sous-parties pour organiser ces éléments de manière ordonnée.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction au Tri Rapide (Quicksort)</h3>
            <h4>Le Contexte du Tri :</h4>
            <p>Imaginez un jeu vidéo dans lequel le joueur doit organiser rapidement un inventaire d’objets selon leur valeur ou leur poids pour accéder plus facilement aux objets les plus précieux. Un algorithme de tri comme Quicksort permet d’organiser cet inventaire de manière très efficace, même si le nombre d’objets est élevé.</p>
        
            <h4>Concept du Tri Rapide :</h4>
            <p>Quicksort est un algorithme de tri basé sur le principe de <strong>diviser pour régner</strong> :</p>
            <ul>
                <li>Il sélectionne un élément de la liste appelé <strong>pivot</strong>.</li>
                <li>Ensuite, il réorganise la liste de manière à ce que tous les éléments plus petits que le pivot se trouvent à gauche et tous les éléments plus grands se trouvent à droite.</li>
                <li>Le processus est ensuite appliqué récursivement aux sous-listes de gauche et de droite.</li>
            </ul>
        
            <p>Ce procédé divise la liste en sous-parties jusqu'à ce que chaque sous-liste contienne un seul élément, moment où tous les éléments sont triés.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étapes de Quicksort (20 min)</h3>
            <h4>1. Choix du Pivot :</h4>
            <p>Un pivot est un élément de la liste choisi pour diviser la liste en deux sous-listes. Le choix du pivot peut être fait de différentes manières :</p>
            <ul>
                <li>Le premier élément.</li>
                <li>Le dernier élément.</li>
                <li>Un élément aléatoire.</li>
                <li>Le milieu de la liste (option courante pour éviter les déséquilibres).</li>
            </ul>
            
            <h4>2. Réarrangement des Éléments autour du Pivot :</h4>
            <p>Après avoir choisi le pivot, Quicksort place tous les éléments inférieurs au pivot à gauche et tous les éléments supérieurs à droite. Cela divise la liste en deux parties indépendantes.</p>
        
            <h4>3. Récursivité dans Quicksort :</h4>
            <p>Le tri rapide utilise la récursivité pour trier les sous-listes de gauche et de droite autour du pivot, jusqu'à ce que toutes les sous-listes soient triées.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Pseudo-code de Quicksort</h3>
            <pre><code>def quicksort(liste):
            if len(liste) <= 1:  # Cas de base : si la liste contient 1 ou 0 élément
                return liste
            pivot = liste[len(liste) // 2]  # Choisir le pivot
            gauche = [x for x in liste if x < pivot]  # Éléments plus petits que le pivot
            milieu = [x for x in liste if x == pivot]  # Éléments égaux au pivot
            droite = [x for x in liste if x > pivot]  # Éléments plus grands que le pivot
            return quicksort(gauche) + milieu + quicksort(droite)  # Appels récursifs
            </code></pre>
        
            <p>Ce pseudo-code utilise la récursivité pour trier les sous-listes gauche et droite jusqu'à ce que toutes les sous-listes soient réduites à un ou zéro élément.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation de Quicksort en Python (30 min)</h3>
            <p>Nous allons maintenant implémenter l’algorithme de tri rapide en Python et l'appliquer à une liste de valeurs pour trier les objets d'un inventaire de jeu en fonction de leur poids.</p>
        
            <pre><code>def quicksort(liste):
            # Cas de base : si la liste est vide ou contient un seul élément, elle est déjà triée
            if len(liste) <= 1:
                return liste
        
            # Choix du pivot (élément central pour éviter le déséquilibre)
            pivot = liste[len(liste) // 2]
        
            # Créer des sous-listes pour les éléments inférieurs, égaux et supérieurs au pivot
            gauche = [x for x in liste if x < pivot]
            milieu = [x for x in liste if x == pivot]
            droite = [x for x in liste if x > pivot]
        
            # Appels récursifs sur les sous-listes
            return quicksort(gauche) + milieu + quicksort(droite)
        
        # Liste d'exemple pour tester le tri rapide
        inventaire = [5, 3, 8, 6, 2, 7, 4, 1]
        print("Inventaire trié :", quicksort(inventaire))
            </code></pre>
        
            <h4>Explication de l’Implémentation :</h4>
            <ul>
                <li><strong>Cas de base :</strong> Si la liste est vide ou contient un seul élément, elle est déjà triée.</li>
                <li><strong>Choix du pivot :</strong> L'élément central de la liste est choisi comme pivot.</li>
                <li><strong>Création de sous-listes :</strong> La liste est divisée en trois parties : éléments plus petits que le pivot, éléments égaux au pivot et éléments plus grands.</li>
                <li><strong>Appels récursifs :</strong> Les sous-listes gauche et droite sont triées de manière récursive, puis combinées pour obtenir la liste triée.</li>
            </ul>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez la liste pour qu'elle représente un inventaire avec des poids de différents objets.</li>
                <li><strong>Étape 2 :</strong> Utilisez Quicksort pour organiser les objets de l'inventaire par ordre de poids croissant.</li>
                <li><strong>Étape 3 :</strong> Ajoutez une fonctionnalité pour trier par ordre décroissant (en inversant la logique de comparaison).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Analyse de la Complexité de Quicksort (10 min)</h3>
            <p>Quicksort est un algorithme très efficace pour trier de grandes listes. Cependant, son efficacité dépend de la manière dont les pivots sont choisis.</p>
        
            <h4>1. Complexité Temporelle :</h4>
            <ul>
                <li><strong>Meilleur et cas moyen :</strong> <code>O(n log n)</code> lorsque les pivots divisent la liste de manière équilibrée.</li>
                <li><strong>Pire cas :</strong> <code>O(n^2)</code> si les pivots choisis divisent la liste de manière très déséquilibrée (par exemple, si le pivot est toujours le plus grand ou le plus petit élément).</li>
            </ul>
        
            <h4>2. Efficacité Pratique :</h4>
            <p>En moyenne, Quicksort est très rapide et est préféré pour de nombreux problèmes de tri, car il utilise peu de mémoire supplémentaire et est souvent plus rapide que d’autres algorithmes de tri comme le tri par fusion dans les applications pratiques.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion</h3>
            <p>À la fin de cette séance, les élèves comprendront comment Quicksort utilise la division pour organiser efficacement une liste d'éléments. Ils auront appris à choisir un pivot, diviser une liste autour de ce pivot, et appliquer la récursivité pour trier les sous-listes. Ce tri est particulièrement utile dans les jeux vidéo pour organiser des inventaires, classer des scores, et bien plus encore.</p>
        </section>

        <section id="session26" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 26 : Pratique - Implémentation du Quicksort pour trier des scores de jeu vidéo</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves vont apprendre à implémenter l’algorithme de tri Quicksort et à l'utiliser dans un contexte de jeu vidéo pour trier les scores des joueurs. Ils découvriront comment cet algorithme de tri rapide fonctionne en divisant et triant des sous-parties de la liste de scores, ce qui en fait une méthode efficace pour organiser des données en temps réel.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte de Jeu Vidéo :</h3>
            <p>Dans un jeu vidéo, les scores des joueurs sont souvent affichés sur un tableau de classement. Ce tableau doit être trié pour montrer les meilleurs scores en haut de la liste. L'algorithme Quicksort est un excellent choix pour organiser efficacement une liste de scores, car il est rapide et divise la liste en parties plus petites pour les trier indépendamment.</p>
        
            <h4>Scénario :</h4>
            <p>Les scores des joueurs dans notre jeu vidéo sont stockés dans une liste. Chaque fois qu'un joueur termine une partie, son score est ajouté à la liste. Pour afficher le classement des meilleurs joueurs, nous devons trier cette liste du score le plus élevé au plus bas.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Principe de Quicksort</h3>
            <p>Quicksort est un algorithme de tri qui utilise la méthode de "diviser pour régner" (divide and conquer) :</p>
            <ul>
                <li>Il sélectionne un élément appelé <strong>pivot</strong> dans la liste.</li>
                <li>Il divise la liste en deux parties : les éléments inférieurs au pivot et ceux supérieurs au pivot.</li>
                <li>Quicksort est ensuite appliqué récursivement aux sous-listes de chaque côté du pivot.</li>
            </ul>
            <p>Grâce à cette méthode, Quicksort peut trier une liste de manière très efficace, même pour de grandes quantités de données.</p>
        
            <h4>Exemple de Tri avec Quicksort :</h4>
            <pre><code>Scores initiaux : [35, 50, 20, 60, 10, 90]
        Pivot choisi : 35
        Scores inférieurs au pivot (35) : [20, 10]
        Scores supérieurs au pivot (35) : [50, 60, 90]
        Liste triée : [10, 20, 35, 50, 60, 90]
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Pseudo-code de Quicksort</h3>
            <p>Voici le pseudo-code pour une implémentation simple de Quicksort :</p>
            <pre><code>def quicksort(liste):
            if len(liste) <= 1:
                return liste  # Liste déjà triée ou vide
        
            pivot = liste[0]  # Choisir le premier élément comme pivot
            inferieurs = [x for x in liste[1:] if x <= pivot]  # Obtenir les éléments inférieurs au pivot
            superieurs = [x for x in liste[1:] if x > pivot]   # Obtenir les éléments supérieurs au pivot
        
            return quicksort(superieurs) + [pivot] + quicksort(inferieurs)  # Tri des parties et recombinaison
            </code></pre>
        
            <p>Dans cet exemple, on choisit le premier élément de la liste comme pivot et on utilise des compréhensions de liste pour diviser les éléments en deux groupes : ceux inférieurs ou égaux au pivot et ceux supérieurs au pivot.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation de Quicksort en Python (45 min)</h3>
        
            <h4>1. Initialisation de la Liste de Scores :</h4>
            <p>Pour notre jeu vidéo, nous initialisons une liste de scores de joueurs :</p>
            <pre><code>scores = [50, 85, 40, 95, 70, 10, 65, 100, 25, 80]
            </code></pre>
        
            <h4>2. Implémentation de Quicksort :</h4>
            <p>Nous allons maintenant implémenter Quicksort en Python pour trier cette liste de scores :</p>
            <pre><code>def quicksort(liste):
            # Condition d'arrêt : si la liste a un seul élément ou est vide, elle est déjà triée
            if len(liste) <= 1:
                return liste
        
            # Choix du pivot (le premier élément)
            pivot = liste[0]
        
            # Diviser les éléments autour du pivot
            inferieurs = [x for x in liste[1:] if x <= pivot]
            superieurs = [x for x in liste[1:] if x > pivot]
        
            # Récursivité : appliquer Quicksort aux sous-listes
            return quicksort(superieurs) + [pivot] + quicksort(inferieurs)
        
        # Utiliser Quicksort pour trier la liste des scores
        scores_tries = quicksort(scores)
        print("Scores triés du plus grand au plus petit :", scores_tries)
            </code></pre>
        
            <h4>3. Explication de l'implémentation :</h4>
            <ul>
                <li>La fonction <code>quicksort()</code> prend en paramètre une liste de scores.</li>
                <li>Si la liste est vide ou comporte un seul élément, elle est déjà triée et la fonction la retourne telle quelle.</li>
                <li>On choisit un pivot (ici, le premier élément de la liste) pour diviser la liste en deux groupes : <strong>inférieurs</strong> et <strong>supérieurs</strong>.</li>
                <li>La fonction appelle ensuite <code>quicksort()</code> récursivement sur les sous-listes, puis combine les résultats pour obtenir la liste triée.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exercice Pratique (30 min)</h3>
            <h4>Objectif :</h4>
            <p>Dans cet exercice pratique, les élèves devront modifier le code pour trier les scores du plus bas au plus haut, ou pour ajouter de nouveaux scores à la liste, simuler l'ajout de nouveaux joueurs et afficher un classement mis à jour.</p>
        
            <h4>Étapes :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Implémenter la fonction de tri Quicksort de manière à afficher les scores du plus bas au plus haut.</li>
                <li><strong>Étape 2 :</strong> Simuler l’ajout d’un score aléatoire à la liste des scores et afficher le classement mis à jour.</li>
                <li><strong>Étape 3 :</strong> Modifier l’algorithme pour trier en ordre croissant ou décroissant en fonction d’un paramètre.</li>
            </ul>
        
            <h4>Exemple d'ajout de score et affichage de classement :</h4>
            <pre><code>import random
        
        # Ajouter un nouveau score et trier la liste
        nouveau_score = random.randint(0, 100)
        scores.append(nouveau_score)
        print(f"Nouveau score ajouté : {nouveau_score}")
        scores_tries = quicksort(scores)
        print("Classement mis à jour :", scores_tries)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion (15 min)</h3>
            <p>À la fin de cette séance, les élèves auront appris comment implémenter et utiliser l’algorithme Quicksort pour organiser une liste de scores de jeu vidéo. Ils auront vu comment cet algorithme, en divisant la liste en parties plus petites, permet d'obtenir une solution très efficace pour trier des données dans un contexte interactif.</p>
        
            <p><strong>Points clés :</strong></p>
            <ul>
                <li><strong>Récursivité :</strong> Quicksort utilise la récursivité pour traiter chaque sous-liste individuellement.</li>
                <li><strong>Pivot :</strong> Le choix du pivot est crucial pour diviser la liste efficacement.</li>
                <li><strong>Applications pratiques :</strong> Utiliser Quicksort dans un contexte de jeu vidéo pour organiser un classement de scores.</li>
            </ul>
        
            <p>Pour la prochaine séance, les élèves appliqueront Quicksort dans un contexte de tri dynamique, où de nouveaux scores s’ajoutent régulièrement.</p>
        </section>

        <section id="session27" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 27 : Comparaison de la complexité des différents algorithmes de tri</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves vont étudier et comparer différents algorithmes de tri en Python en analysant leurs performances (complexité temporelle) dans des scénarios variés. Ils comprendront comment choisir l'algorithme de tri le plus adapté en fonction du contexte.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Algorithmes de Tri</h3>
            <p>Les algorithmes de tri permettent d’organiser les données dans un certain ordre (par exemple, croissant ou décroissant). Certains sont efficaces pour des petits ensembles de données, tandis que d'autres sont optimisés pour de grands ensembles. Les trois algorithmes de tri les plus courants que nous allons étudier sont :</p>
        
            <ul>
                <li><strong>Tri par sélection</strong> – Simple, mais peu efficace pour de grands ensembles de données.</li>
                <li><strong>Tri par insertion</strong> – Adapté aux petits ensembles ou aux listes presque triées.</li>
                <li><strong>Tri rapide (QuickSort)</strong> – Très performant pour de grands ensembles, mais peut être inefficace dans certains cas.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étude et Implémentation des Algorithmes de Tri</h3>
        
            <h4>1. Tri par Sélection</h4>
            <p>Le tri par sélection trouve l’élément le plus petit dans la liste et le place au début. Il répète ce processus pour chaque position dans la liste jusqu'à ce que tous les éléments soient triés.</p>
        
            <h4>Pseudo-code du Tri par Sélection :</h4>
            <pre><code>def tri_selection(liste):
            for i in range(len(liste)):
                min_index = i
                for j in range(i + 1, len(liste)):
                    if liste[j] < liste[min_index]:
                        min_index = j
                liste[i], liste[min_index] = liste[min_index], liste[i]
            </code></pre>
        
            <p>**Complexité temporelle** : O(n²) (peu efficace pour les grands ensembles)</p>
        
            <h4>Exercice pratique :</h4>
            <p>Implémentez le tri par sélection et testez-le sur une liste de nombres aléatoires. Notez le temps d’exécution pour des listes de 10, 100 et 1000 éléments.</p>
        
            <h4>2. Tri par Insertion</h4>
            <p>Le tri par insertion fonctionne en prenant chaque élément et en l'insérant à la bonne place dans une sous-liste triée. Ce tri est efficace pour les petites listes ou les listes presque triées.</p>
        
            <h4>Pseudo-code du Tri par Insertion :</h4>
            <pre><code>def tri_insertion(liste):
            for i in range(1, len(liste)):
                current = liste[i]
                j = i - 1
                while j >= 0 and liste[j] > current:
                    liste[j + 1] = liste[j]
                    j -= 1
                liste[j + 1] = current
            </code></pre>
        
            <p>**Complexité temporelle** : O(n²) (efficace pour les petites listes ou les listes presque triées)</p>
        
            <h4>Exercice pratique :</h4>
            <p>Implémentez le tri par insertion et mesurez son temps d’exécution pour des listes de tailles variées.</p>
        
            <h4>3. Tri Rapide (QuickSort)</h4>
            <p>Le tri rapide (QuickSort) est un algorithme de tri très rapide qui utilise le principe de <strong>diviser pour régner</strong>. Il choisit un élément pivot et partitionne la liste autour de ce pivot, de sorte que les éléments plus petits que le pivot se trouvent d'un côté et les éléments plus grands de l'autre. L'algorithme est ensuite appliqué récursivement sur chaque sous-liste.</p>
        
            <h4>Pseudo-code du Tri Rapide :</h4>
            <pre><code>def quicksort(liste):
            if len(liste) <= 1:
                return liste
            pivot = liste[len(liste) // 2]
            gauche = [x for x in liste if x < pivot]
            milieu = [x for x in liste if x == pivot]
            droite = [x for x in liste if x > pivot]
            return quicksort(gauche) + milieu + quicksort(droite)
            </code></pre>
        
            <p>**Complexité temporelle** : O(n log n) en moyenne (très efficace pour les grands ensembles de données)</p>
        
            <h4>Exercice pratique :</h4>
            <p>Implémentez QuickSort et comparez son temps d’exécution avec les autres algorithmes de tri pour des listes de 10, 100 et 1000 éléments.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Comparaison de la Complexité Temporelle des Algorithmes (45 min)</h3>
        
            <h4>1. Explication de la Complexité Temporelle</h4>
            <p>La complexité temporelle mesure le temps d'exécution d'un algorithme en fonction de la taille de la liste :</p>
            <ul>
                <li><strong>O(n²)</strong> : La complexité des algorithmes de tri par sélection et par insertion. Ils ne sont pas performants pour les grandes listes car le temps d'exécution augmente rapidement.</li>
                <li><strong>O(n log n)</strong> : La complexité moyenne du tri rapide. C'est le meilleur choix pour trier de grandes listes.</li>
            </ul>
        
            <h4>2. Comparaison en Situation Réelle</h4>
            <p>Demandez aux élèves d’écrire un programme pour mesurer le temps d'exécution des trois algorithmes sur des listes de différentes tailles (10, 100, 1000, et 10 000 éléments).</p>
        
            <pre><code>import random
        import time
        
        def mesurer_temps(algorithme, liste):
            debut = time.time()
            algorithme(liste)
            fin = time.time()
            return fin - debut
        
        # Créer des listes de différentes tailles
        tailles = [10, 100, 1000, 10000]
        algorithmes = [tri_selection, tri_insertion, quicksort]
        
        # Tester chaque algorithme pour chaque taille
        for taille in tailles:
            print(f"Taille de la liste : {taille}")
            liste = [random.randint(0, 100) for _ in range(taille)]
            for algorithme in algorithmes:
                liste_copie = liste[:]
                temps = mesurer_temps(algorithme, liste_copie)
                print(f"{algorithme.__name__} - Temps d'exécution : {temps:.5f} secondes")
            print("-" * 40)
            </code></pre>
        
            <h4>3. Analyse des Résultats :</h4>
            <p>Les élèves doivent observer et analyser les résultats obtenus. Le tri rapide devrait être le plus performant pour les grandes listes, tandis que les tris par sélection et par insertion deviendront rapidement très lents.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion (15 min)</h3>
        
            <h4>Comparaison des Algorithmes de Tri :</h4>
            <ul>
                <li><strong>Tri par sélection :</strong> Simple mais inefficace pour les grandes listes. Complexité : O(n²).</li>
                <li><strong>Tri par insertion :</strong> Utile pour les petites listes ou les listes presque triées. Complexité : O(n²).</li>
                <li><strong>QuickSort :</strong> Très performant pour les grandes listes grâce à sa complexité moyenne de O(n log n).</li>
            </ul>
        
            <h4>Discussion Finale :</h4>
            <p>En fonction des résultats, discutez avec les élèves de la meilleure approche à adopter pour trier des listes de différentes tailles. Soulignez que certains algorithmes conviennent mieux aux petits ensembles de données, tandis que d'autres sont plus adaptés aux grands ensembles.</p>
        </section>

        <section id="session28" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 28 : Introduction au tri par tas (Heapsort)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves vont découvrir l’algorithme de tri par tas (Heapsort), un algorithme de tri efficace utilisant une structure de données appelée tas (heap). Ils apprendront à construire un tas, à extraire les éléments dans un ordre trié, et à utiliser cette approche pour trier une liste de nombres.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction au Tri par Tas</h3>
            
            <h4>1. Qu'est-ce qu'un Tas (Heap) ?</h4>
            <p>Un <strong>tas</strong> (heap) est une structure de données basée sur un arbre binaire. Dans un tas binaire :</p>
            <ul>
                <li>Chaque nœud parent a une valeur supérieure ou égale à celle de ses enfants dans un <strong>max-heap</strong>.</li>
                <li>Chaque nœud parent a une valeur inférieure ou égale à celle de ses enfants dans un <strong>min-heap</strong>.</li>
            </ul>
            <p>Le tri par tas utilise un max-heap (ou min-heap) pour organiser les éléments de manière à pouvoir les extraire dans un ordre trié.</p>
        
            <h4>2. Principe de Fonctionnement du Heapsort</h4>
            <p>L’algorithme Heapsort fonctionne en deux étapes principales :</p>
            <ul>
                <li><strong>Étape 1 :</strong> Construire un tas (max-heap) à partir de la liste de nombres.</li>
                <li><strong>Étape 2 :</strong> Extraire le maximum du tas et le placer à la fin de la liste, puis ajuster le tas pour maintenir sa structure. Cette opération est répétée jusqu’à ce que tous les éléments soient extraits.</li>
            </ul>
        
            <p>En fin de compte, la liste est triée en ordre croissant (ou décroissant) en fonction de la structure de tas utilisée.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étapes de Construction du Tas (30 min)</h3>
        
            <h4>1. Transformation d'une Liste en Max-Heap</h4>
            <p>Pour convertir une liste de nombres en max-heap, on applique une opération appelée <strong>heapification</strong> :</p>
            <ul>
                <li>On commence par le dernier nœud non-feuille de l'arbre et on vérifie si sa valeur est supérieure à celle de ses enfants.</li>
                <li>Si ce nœud est plus petit que l'un de ses enfants, on échange leurs valeurs et on continue l'opération de heapification sur le sous-arbre affecté.</li>
            </ul>
        
            <p>Voici un exemple de liste que nous allons transformer en max-heap : [4, 10, 3, 5, 1]</p>
        
            <pre><code>Avant heapification :  4, 10, 3, 5, 1
        Après heapification : 10, 5, 3, 4, 1
            </code></pre>
        
            <h4>2. Implémentation de la Fonction de Heapification en Python</h4>
            <p>Voici un exemple de code Python pour appliquer la fonction de heapification sur un tableau :</p>
        
            <pre><code>def heapify(liste, n, i):
            plus_grand = i  # initialiser le plus grand élément comme racine
            gauche = 2 * i + 1  # fils gauche
            droite = 2 * i + 2  # fils droit
        
            # Vérifier si le fils gauche est plus grand que la racine
            if gauche < n and liste[gauche] > liste[plus_grand]:
                plus_grand = gauche
        
            # Vérifier si le fils droit est plus grand que le plus grand actuel
            if droite < n and liste[droite] > liste[plus_grand]:
                plus_grand = droite
        
            # Si le plus grand n'est pas la racine
            if plus_grand != i:
                liste[i], liste[plus_grand] = liste[plus_grand], liste[i]  # échanger
                heapify(liste, n, plus_grand)  # continuer la heapification
            </code></pre>
        
            <p>La fonction <code>heapify</code> prend en paramètres la liste, sa taille <code>n</code>, et l’indice <code>i</code> du nœud à heapifier. Elle vérifie si le nœud actuel est le plus grand, et si ce n’est pas le cas, elle échange les valeurs et appelle récursivement la fonction.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Algorithme Complet du Heapsort (45 min)</h3>
        
            <h4>1. Étape 1 : Construire le Max-Heap</h4>
            <p>Nous allons construire un max-heap à partir de la liste en appliquant la fonction <code>heapify</code> sur chaque nœud, en commençant par le dernier nœud non-feuille jusqu'à la racine.</p>
        
            <pre><code>def construire_tas(liste):
            n = len(liste)
            for i in range(n // 2 - 1, -1, -1):
                heapify(liste, n, i)
            </code></pre>
        
            <h4>2. Étape 2 : Tri par Extraction</h4>
            <p>Une fois le tas construit, nous procédons au tri. Nous échangeons la racine (plus grand élément) avec le dernier élément de la liste, puis réduisons la taille du tas et réappliquons <code>heapify</code> pour maintenir la structure du tas.</p>
        
            <pre><code>def heapsort(liste):
            n = len(liste)
            construire_tas(liste)
            
            # Extraire un à un les éléments du tas
            for i in range(n - 1, 0, -1):
                liste[i], liste[0] = liste[0], liste[i]  # échanger
                heapify(liste, i, 0)  # réappliquer heapify pour maintenir le tas
            </code></pre>
        
            <h4>3. Code Complet de l’Algorithme Heapsort</h4>
            <p>Voici le code complet pour trier une liste de nombres en utilisant Heapsort :</p>
        
            <pre><code>def heapify(liste, n, i):
            plus_grand = i
            gauche = 2 * i + 1
            droite = 2 * i + 2
        
            if gauche < n and liste[gauche] > liste[plus_grand]:
                plus_grand = gauche
            if droite < n and liste[droite] > liste[plus_grand]:
                plus_grand = droite
        
            if plus_grand != i:
                liste[i], liste[plus_grand] = liste[plus_grand], liste[i]
                heapify(liste, n, plus_grand)
        
        def construire_tas(liste):
            n = len(liste)
            for i in range(n // 2 - 1, -1, -1):
                heapify(liste, n, i)
        
        def heapsort(liste):
            n = len(liste)
            construire_tas(liste)
            for i in range(n - 1, 0, -1):
                liste[i], liste[0] = liste[0], liste[i]
                heapify(liste, i, 0)
        
        # Exemple d'utilisation
        liste = [4, 10, 3, 5, 1]
        heapsort(liste)
        print("Liste triée :", liste)
            </code></pre>
        
            <h4>Explication Étape par Étape du Code :</h4>
            <ul>
                <li><code>heapify</code> organise une partie du tableau pour en faire un tas valide.</li>
                <li><code>construire_tas</code> crée un max-heap sur l’ensemble de la liste.</li>
                <li><code>heapsort</code> utilise le max-heap pour extraire les éléments dans un ordre décroissant et les organiser de manière triée.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Défi Pratique pour les Élèves (20 min)</h3>
            <ul>
                <li><strong>Étape 1 :</strong> Utiliser Heapsort pour trier une liste de scores de joueurs dans un jeu, du plus haut au plus bas.</li>
                <li><strong>Étape 2 :</strong> Modifier l'algorithme pour qu'il trie les scores du plus bas au plus haut (utiliser un min-heap).</li>
                <li><strong>Étape 3 :</strong> Mesurer le temps d'exécution de Heapsort par rapport à d'autres algorithmes de tri comme le tri par sélection ou le tri par insertion.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Analyse de la Complexité (10 min)</h3>
        
            <h4>Complexité de Heapsort :</h4>
            <ul>
                <li><strong>Complexité en temps :</strong> Heapsort a une complexité temporelle de <code>O(n log n)</code> dans tous les cas, car la construction du tas prend <code>O(n)</code> et chaque extraction prend <code>O(log n)</code>.</li>
                <li><strong>Complexité en espace :</strong> Heapsort est un tri <strong>en place</strong>, ce qui signifie qu’il ne nécessite pas de mémoire supplémentaire.</li>
            </ul>
        
            <h4>Discussion Finale :</h4>
            <p>Heapsort est un algorithme de tri efficace et stable qui utilise un tas pour organiser les éléments de manière ordonnée. Contrairement au tri rapide (Quicksort), Heapsort a une complexité temporelle garantie de <code>O(n log n)</code> dans le pire des cas, ce qui le rend particulièrement adapté pour des jeux ou des applications où le tri des scores ou des objets est requis de manière fiable.</p>
        </section>

        <section id="session29" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 29 : Pratique - Utilisation du Heapsort pour organiser un inventaire dans un jeu vidéo</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront à utiliser l'algorithme de tri Heapsort pour organiser un inventaire dans un jeu vidéo. L'objectif est de comprendre l'algorithme Heapsort et de l'appliquer à un cas pratique en classant les objets d'inventaire par ordre de priorité, comme le poids ou la valeur.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction au Contexte du Jeu Vidéo</h3>
        
            <h4>Contexte de l'Inventaire dans un Jeu Vidéo :</h4>
            <p>Dans de nombreux jeux vidéo, les joueurs possèdent un inventaire contenant divers objets (armes, potions, ressources) qu’ils peuvent trier par ordre de priorité pour faciliter la gestion. Par exemple :</p>
            <ul>
                <li>Les objets peuvent être triés par <strong>poids</strong> (les objets les plus lourds en premier) pour gérer l'espace d'inventaire.</li>
                <li>Les objets peuvent être triés par <strong>valeur</strong> (les objets les plus précieux en premier) pour optimiser les gains lorsqu'on vend des objets.</li>
            </ul>
            <p>Pour effectuer ce tri efficacement, nous utiliserons l'algorithme de tri Heapsort.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Explication de Heapsort (20 min)</h3>
        
            <h4>1. Principe de Heapsort :</h4>
            <p>Heapsort est un algorithme de tri basé sur la structure de données appelée <strong>tas (heap)</strong>, qui est un type de <em>file de priorité</em>. L’algorithme Heapsort suit ces étapes :</p>
            <ul>
                <li>Créer un tas à partir de la liste d'éléments (objets d'inventaire).</li>
                <li>Extraire les éléments du tas un par un pour obtenir une liste triée.</li>
            </ul>
        
            <h4>2. Types de Tas :</h4>
            <ul>
                <li><strong>Max-Heap :</strong> Le plus grand élément est toujours en haut. Utilisé pour trier par ordre décroissant.</li>
                <li><strong>Min-Heap :</strong> Le plus petit élément est toujours en haut. Utilisé pour trier par ordre croissant.</li>
            </ul>
        
            <h4>3. Utilisation de Heapsort :</h4>
            <p>En utilisant Heapsort, nous pouvons trier les objets d'inventaire dans l'ordre souhaité (par exemple, du plus lourd au plus léger ou du plus précieux au moins précieux).</p>
        
            <h4>Pseudo-code de Heapsort :</h4>
            <pre><code>def heapsort(liste):
            # Construire le Max-Heap
            for i in range(len(liste) // 2 - 1, -1, -1):
                entasser(liste, len(liste), i)
            
            # Extraire les éléments un par un
            for i in range(len(liste) - 1, 0, -1):
                liste[i], liste[0] = liste[0], liste[i]  # Échanger
                entasser(liste, i, 0)
            
        def entasser(liste, taille, i):
            plus_grand = i  # Initialiser le plus grand comme racine
            gauche = 2 * i + 1
            droite = 2 * i + 2
            
            # Vérifier si le fils gauche est plus grand que la racine
            if gauche < taille and liste[gauche] > liste[plus_grand]:
                plus_grand = gauche
            
            # Vérifier si le fils droit est plus grand que le plus grand actuel
            if droite < taille and liste[droite] > liste[plus_grand]:
                plus_grand = droite
            
            # Changer la racine si nécessaire
            if plus_grand != i:
                liste[i], liste[plus_grand] = liste[plus_grand], liste[i]
                entasser(liste, taille, plus_grand)
            </code></pre>
        
            <h4>Explication Étape par Étape :</h4>
            <ul>
                <li><strong>Construction du tas :</strong> L'algorithme commence par transformer la liste en un tas maximal (Max-Heap).</li>
                <li><strong>Extraction des éléments :</strong> À chaque étape, l’élément le plus grand est extrait du tas et placé à la fin de la liste.</li>
                <li><strong>Réorganisation :</strong> Le tas est réorganisé après chaque extraction pour maintenir sa structure.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique : Organisation de l'Inventaire d’un Jeu (45 min)</h3>
        
            <h4>1. Initialiser l'Inventaire :</h4>
            <p>Dans cet exemple, nous allons créer un inventaire de jeu contenant plusieurs objets avec des attributs tels que le <strong>nom</strong>, le <strong>poids</strong> et la <strong>valeur</strong>.</p>
            <pre><code>inventaire = [
            {"nom": "épée", "poids": 5, "valeur": 150},
            {"nom": "potion", "poids": 1, "valeur": 50},
            {"nom": "bouclier", "poids": 7, "valeur": 100},
            {"nom": "pierre précieuse", "poids": 2, "valeur": 500},
            {"nom": "herbes", "poids": 1, "valeur": 20}
        ]
            </code></pre>
        
            <h4>2. Fonction Heapsort pour Trier l’Inventaire :</h4>
            <p>Nous allons maintenant adapter l'algorithme Heapsort pour trier l'inventaire en fonction d'un attribut, comme le poids ou la valeur.</p>
        
            <pre><code>def trier_inventaire_par_valeur(inventaire):
            def entasser(liste, taille, i):
                plus_grand = i
                gauche = 2 * i + 1
                droite = 2 * i + 2
                
                if gauche < taille and liste[gauche]["valeur"] > liste[plus_grand]["valeur"]:
                    plus_grand = gauche
                if droite < taille and liste[droite]["valeur"] > liste[plus_grand]["valeur"]:
                    plus_grand = droite
                
                if plus_grand != i:
                    liste[i], liste[plus_grand] = liste[plus_grand], liste[i]
                    entasser(liste, taille, plus_grand)
            
            # Construire le Max-Heap
            for i in range(len(inventaire) // 2 - 1, -1, -1):
                entasser(inventaire, len(inventaire), i)
            
            # Trier
            for i in range(len(inventaire) - 1, 0, -1):
                inventaire[i], inventaire[0] = inventaire[0], inventaire[i]
                entasser(inventaire, i, 0)
        
        # Trier l'inventaire par valeur
        trier_inventaire_par_valeur(inventaire)
        print("Inventaire trié par valeur décroissante :", inventaire)
            </code></pre>
        
            <h4>3. Explication du Code :</h4>
            <ul>
                <li>La fonction <code>trier_inventaire_par_valeur()</code> crée un Max-Heap en fonction de la valeur de chaque objet.</li>
                <li>Chaque objet est extrait et placé en fin de liste, garantissant ainsi un tri par ordre décroissant de valeur.</li>
                <li>On peut facilement adapter le code pour trier l’inventaire en fonction d’autres attributs, comme le poids.</li>
            </ul>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez la fonction pour trier l’inventaire en fonction du <code>poids</code> plutôt que de la <code>valeur</code>.</li>
                <li><strong>Étape 2 :</strong> Ajoutez une option pour trier l’inventaire en ordre croissant ou décroissant, en utilisant un Min-Heap ou un Max-Heap.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion (15 min)</h3>
            <p>À la fin de cette séance, les élèves auront appris à utiliser Heapsort pour organiser un inventaire dans un jeu vidéo. Ils comprendront l'importance d'un tri efficace dans un jeu où l’organisation de l’inventaire joue un rôle clé.</p>
        
            <h4>Comparaison avec d'autres Algorithmes de Tri :</h4>
            <ul>
                <li><strong>Heapsort :</strong> Complexité en temps <code>O(n log n)</code>, utile pour des tri en place et pour gérer les priorités.</li>
                <li><strong>Quicksort :</strong> Bien que performant, il est moins adapté pour des structures de file de priorité comme celles d’un inventaire.</li>
            </ul>
        
            <h4>Applications Pratiques :</h4>
            <ul>
                <li>Organisation de l’inventaire dans les jeux RPG pour prioriser les objets en fonction de leur importance.</li>
                <li>Gestion des ressources dans des jeux de stratégie, en triant les ressources par quantité ou valeur.</li>
            </ul>
        </section>

        <section id="session30" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 30 : Analyse de la Complexité du Heapsort et de ses Applications</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves vont explorer le tri par tas (Heapsort) en analysant sa complexité et en comprenant son fonctionnement en pratique. Ils découvriront comment cet algorithme s’applique efficacement dans différents contextes, en particulier dans la gestion de files prioritaires et la sélection des éléments de plus grande valeur.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction au Heapsort (20 min)</h3>
            <p>Heapsort est un algorithme de tri qui utilise une structure de données appelée <strong>tas binaire</strong> (ou heap). Il fonctionne en construisant un tas, puis en retirant l’élément de plus grande (ou de plus petite) valeur de ce tas pour le placer en fin de liste.</p>
        
            <h4>1. Notions de Base sur le Tas Binaire :</h4>
            <ul>
                <li><strong>Tas binaire (Heap) :</strong> Une structure d'arbre binaire où chaque nœud est supérieur (max-heap) ou inférieur (min-heap) à ses enfants.</li>
                <li><strong>Max-heap :</strong> Le plus grand élément est situé à la racine de l’arbre.</li>
                <li><strong>Min-heap :</strong> Le plus petit élément est situé à la racine de l’arbre.</li>
            </ul>
            <p>Pour implémenter Heapsort, nous allons utiliser un max-heap, ce qui signifie que l'élément de plus grande valeur est toujours à la racine.</p>
        
            <h4>2. Principe de Fonctionnement du Heapsort :</h4>
            <p>Heapsort fonctionne en deux étapes :</p>
            <ul>
                <li><strong>Étape 1 :</strong> Construire un max-heap à partir des éléments de la liste.</li>
                <li><strong>Étape 2 :</strong> Extraire successivement le maximum du tas, puis replacer le dernier élément à la racine et ajuster la structure pour maintenir la propriété de tas.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Analyse de la Complexité de Heapsort (30 min)</h3>
        
            <h4>1. Complexité de la Construction du Tas :</h4>
            <p>Pour construire un max-heap, on utilise un processus d’<strong>ajustement</strong> (appelé "heapify") qui assure que chaque sous-arbre respecte la propriété de tas. Construire un tas à partir d'une liste de <em>n</em> éléments a une complexité en <strong>O(n)</strong>.</p>
        
            <h4>2. Complexité de l'Extraction et du Tri :</h4>
            <p>Après la construction du tas, chaque extraction de l’élément maximal a une complexité de <strong>O(log n)</strong>, car elle nécessite de réajuster le tas. Pour trier <em>n</em> éléments, on effectue <em>n</em> extractions, chacune prenant <em>O(log n)</em> temps.</p>
            <p><strong>Complexité totale du tri Heapsort :</strong> <code>O(n log n)</code>.</p>
        
            <h4>3. Comparaison avec d’autres Algorithmes de Tri :</h4>
            <p>Heapsort est souvent comparé avec d'autres algorithmes de tri :</p>
            <ul>
                <li><strong>Quicksort :</strong> Généralement plus rapide en pratique avec une complexité moyenne de <code>O(n log n)</code>, mais sa complexité dans le pire des cas est <code>O(n²)</code>.</li>
                <li><strong>Mergesort :</strong> Stable et de complexité <code>O(n log n)</code>, mais nécessite de l'espace supplémentaire, contrairement à Heapsort.</li>
            </ul>
        
            <h4>Applications Pratiques de Heapsort :</h4>
            <ul>
                <li><strong>Files prioritaires :</strong> Heapsort est utilisé pour organiser des files où les éléments les plus prioritaires doivent être traités en premier.</li>
                <li><strong>Tri de grands ensembles de données :</strong> Heapsort est utile dans les systèmes embarqués, car il ne nécessite pas d’espace supplémentaire pour le tri.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation de Heapsort (30 min)</h3>
        
            <h4>1. Fonction de Réajustement (Heapify) :</h4>
            <p>La fonction <code>heapify</code> assure que chaque nœud d’un sous-arbre est supérieur à ses enfants. Cette fonction est essentielle pour maintenir la propriété de tas après chaque extraction.</p>
            <pre><code>def heapify(arr, n, i):
            largest = i  # Initialise le plus grand comme racine
            left = 2 * i + 1  # Enfant gauche
            right = 2 * i + 2  # Enfant droit
        
            # Si l'enfant gauche est plus grand que la racine
            if left < n and arr[left] > arr[largest]:
                largest = left
        
            # Si l'enfant droit est plus grand que le plus grand actuel
            if right < n and arr[right] > arr[largest]:
                largest = right
        
            # Si le plus grand n'est pas la racine
            if largest != i:
                arr[i], arr[largest] = arr[largest], arr[i]  # Échange
                heapify(arr, n, largest)  # Réajuster récursivement
            </code></pre>
        
            <h4>2. Fonction de Tri (Heapsort) :</h4>
            <p>La fonction <code>heapsort</code> construit d'abord un max-heap, puis extrait successivement le plus grand élément en l’ajoutant à la fin de la liste triée.</p>
            <pre><code>def heapsort(arr):
            n = len(arr)
        
            # Construire un max-heap
            for i in range(n // 2 - 1, -1, -1):
                heapify(arr, n, i)
        
            # Extraire les éléments du tas
            for i in range(n - 1, 0, -1):
                arr[i], arr[0] = arr[0], arr[i]  # Déplacer la racine à la fin
                heapify(arr, i, 0)  # Réajuster le tas
            </code></pre>
        
            <h4>3. Exemple d’Utilisation :</h4>
            <p>Testons Heapsort avec une liste d’entiers :</p>
            <pre><code># Liste à trier
        arr = [12, 11, 13, 5, 6, 7]
        print("Liste initiale :", arr)
        
        # Tri avec Heapsort
        heapsort(arr)
        print("Liste triée :", arr)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Défis Pratiques pour les Élèves (30 min)</h3>
            <ul>
                <li><strong>Défi 1 :</strong> Modifiez la fonction <code>heapify</code> pour que le tas devienne un <strong>min-heap</strong>, où le plus petit élément est toujours à la racine.</li>
                <li><strong>Défi 2 :</strong> Utilisez Heapsort pour trier une liste de tuples, où chaque tuple représente un joueur avec son score. L'objectif est de trier les joueurs par ordre décroissant de score.</li>
                <li><strong>Défi 3 :</strong> Dans une file de priorité, certains éléments doivent être traités avant d’autres. Utilisez Heapsort pour implémenter une file de priorité simple et trier les éléments en fonction de leur importance.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Réflexion (10 min)</h3>
            <p>En conclusion, Heapsort est un algorithme de tri efficace avec une complexité de <code>O(n log n)</code>, similaire à d'autres algorithmes de tri comme Quicksort et Mergesort, mais avec ses propres avantages. Sa structure en tas le rend particulièrement adapté pour des applications comme les files prioritaires, où les éléments doivent être traités par priorité.</p>
            
            <p>Les élèves auront appris à construire et manipuler un tas, à utiliser Heapsort pour trier des listes, et à comprendre son efficacité dans divers contextes.</p>
        </section>

        <section id="session31" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 31 : Introduction au Tri Fusion (Merge Sort)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves découvriront le fonctionnement de l'algorithme de tri fusion, un algorithme de tri efficace basé sur le principe de "diviser pour régner". Cette séance leur permettra d'implémenter l'algorithme en utilisant la récursivité et de comprendre pourquoi il est plus performant que des méthodes de tri plus simples, comme le tri par sélection ou par insertion.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction au Tri Fusion (20 min)</h3>
        
            <h4>Principe du Tri Fusion :</h4>
            <p>Le tri fusion (ou Merge Sort) est un algorithme de tri basé sur une stratégie de <strong>diviser pour régner</strong>. L'idée est de diviser le tableau en deux sous-tableaux, de trier chaque sous-tableau de manière récursive, puis de fusionner les deux sous-tableaux triés pour obtenir un tableau final trié.</p>
        
            <h4>Étapes de l'algorithme :</h4>
            <ol>
                <li><strong>Diviser :</strong> Si le tableau a plus d'un élément, le diviser en deux sous-tableaux de tailles à peu près égales.</li>
                <li><strong>Trier :</strong> Appliquer récursivement le tri fusion sur chaque sous-tableau.</li>
                <li><strong>Fusionner :</strong> Fusionner les deux sous-tableaux triés pour obtenir un tableau trié.</li>
            </ol>
        
            <h4>Illustration Visuelle :</h4>
            <p>Pour illustrer, imaginons un tableau initial : <code>[38, 27, 43, 3, 9, 82, 10]</code>. Le tri fusion fonctionnerait de la manière suivante :</p>
            <pre><code>
        [38, 27, 43, 3, 9, 82, 10]
                  |
            -----------------
            |               |
        [38, 27, 43]     [3, 9, 82, 10]
               |              |
            ------         ------
            |    |         |    |
        [38] [27, 43] [3, 9] [82, 10]
        ...
            </code></pre>
        
            <p>Chaque sous-tableau est divisé jusqu’à obtenir des éléments individuels, puis ils sont fusionnés pour reconstituer le tableau trié.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Décomposition de l'Algorithme (30 min)</h3>
        
            <h4>1. Cas de Base et Cas Récursif :</h4>
            <p>L'algorithme utilise la récursivité pour diviser le tableau :</p>
            <ul>
                <li><strong>Cas de base :</strong> Si le tableau contient 1 ou 0 élément, il est déjà trié.</li>
                <li><strong>Cas récursif :</strong> Diviser le tableau en deux, appliquer le tri fusion sur chaque sous-tableau, puis fusionner.</li>
            </ul>
        
            <h4>Fonction de Fusion :</h4>
            <p>La fonction de fusion combine deux sous-tableaux triés en un seul tableau trié :</p>
            <ul>
                <li>On compare les premiers éléments des deux sous-tableaux.</li>
                <li>L'élément le plus petit est ajouté au tableau de fusion.</li>
                <li>On répète jusqu'à ce que tous les éléments soient fusionnés.</li>
            </ul>
        
            <h4>Pseudo-code du Tri Fusion :</h4>
            <pre><code>def tri_fusion(tableau):
            if len(tableau) <= 1:  # Cas de base
                return tableau
            
            milieu = len(tableau) // 2  # Trouver le milieu
            gauche = tri_fusion(tableau[:milieu])  # Trier le sous-tableau gauche
            droite = tri_fusion(tableau[milieu:])  # Trier le sous-tableau droit
            
            return fusion(gauche, droite)
        
        def fusion(gauche, droite):
            resultat = []
            while gauche and droite:
                if gauche[0] < droite[0]:
                    resultat.append(gauche.pop(0))
                else:
                    resultat.append(droite.pop(0))
            resultat.extend(gauche or droite)  # Ajouter les éléments restants
            return resultat
            </code></pre>
        
            <h4>Explication du Pseudo-code :</h4>
            <ul>
                <li><code>tri_fusion</code> est une fonction récursive qui divise le tableau en deux parties égales.</li>
                <li>La fonction <code>fusion</code> fusionne les deux sous-tableaux triés en comparant les éléments un par un.</li>
                <li>Si le tableau ne contient qu'un seul élément ou est vide, il est retourné tel quel (cas de base).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation du Tri Fusion (40 min)</h3>
        
            <h4>Étape 1 : Diviser et Fusionner le Tableau</h4>
            <p>Voici une implémentation complète de l'algorithme de tri fusion en Python :</p>
            <pre><code>def tri_fusion(tableau):
            if len(tableau) <= 1:
                return tableau
            
            milieu = len(tableau) // 2
            gauche = tri_fusion(tableau[:milieu])
            droite = tri_fusion(tableau[milieu:])
            
            return fusion(gauche, droite)
        
        def fusion(gauche, droite):
            resultat = []
            while gauche and droite:
                if gauche[0] < droite[0]:
                    resultat.append(gauche.pop(0))
                else:
                    resultat.append(droite.pop(0))
            resultat.extend(gauche or droite)
            return resultat
        
        # Exemple d'utilisation
        tableau = [38, 27, 43, 3, 9, 82, 10]
        print("Tableau trié :", tri_fusion(tableau))
            </code></pre>
        
            <h4>Étape 2 : Tester le Tri Fusion avec des Exemples</h4>
            <p>Encouragez les élèves à tester la fonction <code>tri_fusion</code> avec plusieurs exemples pour vérifier qu'elle fonctionne correctement et comprendre le processus de fusion en pratique.</p>
        
            <h4>Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez la fonction <code>fusion</code> pour afficher chaque étape de fusion.</li>
                <li><strong>Étape 2 :</strong> Testez l'algorithme avec des tableaux plus grands et analysez le temps de traitement.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Complexité et Avantages du Tri Fusion (20 min)</h3>
        
            <h4>Complexité Temporelle :</h4>
            <p>Le tri fusion a une complexité en temps de <code>O(n log n)</code>, ce qui en fait un algorithme de tri plus efficace que les méthodes de tri simples (comme le tri par sélection) dans la plupart des cas.</p>
        
            <h4>Avantages du Tri Fusion :</h4>
            <ul>
                <li><strong>Efficace :</strong> La complexité de <code>O(n log n)</code> rend le tri fusion rapide même pour des tableaux relativement grands.</li>
                <li><strong>Stable :</strong> Il conserve l’ordre relatif des éléments égaux, ce qui est important dans certaines applications.</li>
            </ul>
        
            <h4>Inconvénients du Tri Fusion :</h4>
            <ul>
                <li><strong>Utilisation de mémoire :</strong> Le tri fusion nécessite de la mémoire supplémentaire pour stocker les sous-tableaux temporaires, ce qui peut être un inconvénient dans des environnements à mémoire limitée.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Réflexion</h3>
            <p>À la fin de cette séance, les élèves devraient comprendre le fonctionnement de l’algorithme de tri fusion, ses avantages en termes d’efficacité et sa complexité temporelle. Ils auront appris à utiliser la récursivité pour diviser un problème en sous-problèmes et à les fusionner pour obtenir une solution complète.</p>
            <p>Le tri fusion est un exemple parfait d’algorithme diviseur qui montre comment la récursivité peut simplifier la résolution de problèmes complexes.</p>
        </section>

        <section id="session32" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 32 : Pratique - Implémentation du Tri Fusion pour Classer des Mangas par Popularité</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront et implémenteront l’algorithme de tri fusion (Merge Sort) pour organiser une liste de mangas selon leur popularité. Ce tri permettra de comprendre la récursivité dans les algorithmes de tri et d'explorer une méthode de tri efficace pour de grandes quantités de données.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte du Projet : Classement des Mangas par Popularité</h3>
        
            <h4>Contexte :</h4>
            <p>Imaginez que vous êtes responsable d'un site de mangas et que vous devez classer ces mangas en fonction de leur popularité (nombre de lecteurs ou notes moyennes). Pour cette tâche, nous allons implémenter un tri fusion qui organisera les mangas du plus populaire au moins populaire.</p>
        
            <h4>Définition de l’Algorithme de Tri Fusion :</h4>
            <p>Le tri fusion est un algorithme de tri basé sur le principe de "diviser pour régner". Cet algorithme est efficace pour trier de grandes listes car il divise la liste en sous-listes, trie chaque sous-liste, puis fusionne les sous-listes triées.</p>
        
            <h4>Concepts Clés :</h4>
            <ul>
                <li><strong>Diviser :</strong> Diviser la liste de mangas en deux moitiés jusqu’à obtenir des sous-listes d'un seul élément.</li>
                <li><strong>Fusionner :</strong> Fusionner les sous-listes en une seule liste triée en comparant les éléments.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Explication de l'Algorithme de Tri Fusion (20 min)</h3>
        
            <h4>Étapes du Tri Fusion :</h4>
            <p>L'algorithme de tri fusion suit trois étapes principales :</p>
            <ol>
                <li><strong>Diviser :</strong> La liste est divisée en deux sous-listes égales (ou presque égales) jusqu’à ce qu’il ne reste plus qu’un seul élément par sous-liste.</li>
                <li><strong>Trier :</strong> Les sous-listes sont considérées comme triées si elles contiennent un seul élément.</li>
                <li><strong>Fusionner :</strong> Fusionner les sous-listes triées pour obtenir une seule liste triée.</li>
            </ol>
        
            <h4>Exemple Visuel :</h4>
            <p>Imaginons une liste de popularité de mangas, où chaque nombre représente le nombre de lecteurs :</p>
            <pre><code>[1200, 4500, 3000, 2500, 3900]</code></pre>
            <p>L'algorithme divise cette liste en sous-listes, trie chaque sous-liste, puis les fusionne de manière triée :</p>
            <pre><code>[1200, 4500, 3000, 2500, 3900]
        => [1200, 4500, 3000]  et  [2500, 3900]
        => [1200, 4500] et [3000] et [2500, 3900]
        => [1200] et [4500] et [3000] et [2500] et [3900]
        => [1200, 4500] et [3000] et [2500, 3900]
        => [1200, 3000, 4500] et [2500, 3900]
        => [1200, 2500, 3000, 3900, 4500]
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation de l'Algorithme de Tri Fusion (30 min)</h3>
        
            <h4>Code de l'Algorithme de Tri Fusion en Python :</h4>
            <p>Nous allons maintenant implémenter le tri fusion en Python pour trier une liste de mangas en fonction de leur popularité.</p>
        
            <pre><code>def tri_fusion(liste):
            # Cas de base : si la liste est vide ou ne contient qu'un seul élément
            if len(liste) &lt;= 1:
                return liste
            
            # Diviser la liste en deux moitiés
            milieu = len(liste) // 2
            gauche = liste[:milieu]
            droite = liste[milieu:]
            
            # Appliquer le tri fusion récursivement sur chaque moitié
            gauche = tri_fusion(gauche)
            droite = tri_fusion(droite)
            
            # Fusionner les deux moitiés triées
            return fusion(gauche, droite)
        
        def fusion(gauche, droite):
            resultat = []
            i = j = 0
            
            # Comparer les éléments des deux sous-listes et les fusionner dans la liste résultat
            while i &lt; len(gauche) and j &lt; len(droite):
                if gauche[i] &lt;= droite[j]:
                    resultat.append(gauche[i])
                    i += 1
                else:
                    resultat.append(droite[j])
                    j += 1
            
            # Ajouter les éléments restants
            resultat.extend(gauche[i:])
            resultat.extend(droite[j:])
            
            return resultat
            </code></pre>
        
            <h4>Étape par Étape :</h4>
            <ul>
                <li>La fonction <code>tri_fusion()</code> divise la liste en deux parties et appelle récursivement le tri fusion sur chacune d’elles.</li>
                <li>La fonction <code>fusion()</code> prend deux sous-listes triées et les fusionne en une seule liste triée.</li>
                <li>Lorsque toutes les sous-listes sont fusionnées, la liste complète est triée.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique : Classement des Mangas par Popularité (30 min)</h3>
        
            <h4>1. Préparer la Liste des Mangas :</h4>
            <p>Créez une liste de mangas, chacun ayant une popularité exprimée par un nombre. Voici un exemple :</p>
            <pre><code>mangas = [
            {"titre": "One Piece", "popularite": 4500},
            {"titre": "Naruto", "popularite": 3900},
            {"titre": "Bleach", "popularite": 2500},
            {"titre": "Dragon Ball", "popularite": 3000},
            {"titre": "Attack on Titan", "popularite": 1200}
        ]
            </code></pre>
        
            <h4>2. Adapter le Tri Fusion pour Trier les Mangas :</h4>
            <p>Modifiez l’algorithme pour trier les mangas en fonction de la clé <code>popularite</code>.</p>
        
            <pre><code>def tri_fusion_mangas(liste):
            if len(liste) &lt;= 1:
                return liste
            
            milieu = len(liste) // 2
            gauche = liste[:milieu]
            droite = liste[milieu:]
            
            gauche = tri_fusion_mangas(gauche)
            droite = tri_fusion_mangas(droite)
            
            return fusion_mangas(gauche, droite)
        
        def fusion_mangas(gauche, droite):
            resultat = []
            i = j = 0
            
            while i &lt; len(gauche) and j &lt; len(droite):
                if gauche[i]["popularite"] &gt;= droite[j]["popularite"]:
                    resultat.append(gauche[i])
                    i += 1
                else:
                    resultat.append(droite[j])
                    j += 1
            
            resultat.extend(gauche[i:])
            resultat.extend(droite[j:])
            
            return resultat
        
        # Trier les mangas par popularité
        mangas_tries = tri_fusion_mangas(mangas)
        for manga in mangas_tries:
            print(f"{manga['titre']} - Popularité : {manga['popularite']}")
            </code></pre>
        
            <h4>Explication :</h4>
            <ul>
                <li>La fonction <code>tri_fusion_mangas()</code> applique le tri fusion sur une liste de mangas.</li>
                <li>La fonction <code>fusion_mangas()</code> fusionne deux sous-listes de mangas en fonction de leur popularité.</li>
            </ul>
        
            <h4>Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Ajoutez des mangas supplémentaires avec des valeurs de popularité aléatoires.</li>
                <li><strong>Étape 2 :</strong> Modifiez l’algorithme pour trier les mangas en ordre croissant de popularité.</li>
                <li><strong>Étape 3 :</strong> Testez l’efficacité du tri fusion pour des listes de 1000 mangas ou plus (générées aléatoirement).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion (10 min)</h3>
            <p>À la fin de cette séance, les élèves comprendront comment utiliser le tri fusion pour trier une liste complexe. Ils auront également appris à adapter l’algorithme pour trier selon une clé spécifique, ici la popularité des mangas. Nous terminerons par une discussion sur l’efficacité du tri fusion, particulièrement utile pour des listes de grandes tailles en raison de sa complexité en temps <code>O(n log n)</code>.</p>
        </section>

        <section id="session33" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 33 : Étude comparative des algorithmes de tri avancés (Quicksort, Heapsort, Merge Sort)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves vont explorer et comparer trois algorithmes de tri avancés : Quicksort, Heapsort et Merge Sort. L'objectif est de comprendre leurs différences en termes de performances, d'implémentation et de cas d'utilisation. Les élèves vont également mettre en pratique ces algorithmes et observer leurs comportements sur différents jeux de données.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Algorithmes de Tri Avancés</h3>
        
            <p>Dans cette séance, nous allons comparer trois algorithmes de tri populaires et efficaces pour trier de grandes quantités de données. Ces algorithmes sont souvent utilisés en programmation en raison de leur efficacité et de leurs caractéristiques différentes :</p>
            <ul>
                <li><strong>Quicksort :</strong> algorithme de tri rapide basé sur un pivot et une partition des données.</li>
                <li><strong>Heapsort :</strong> utilise une structure de tas (heap) pour organiser les éléments et trier le tableau.</li>
                <li><strong>Merge Sort :</strong> utilise une approche de division et fusion (merge) pour trier les données.</li>
            </ul>
        
            <h4>Cas d'utilisation :</h4>
            <p>Ces algorithmes sont utilisés dans différents contextes en fonction des données et des contraintes de performance :</p>
            <ul>
                <li>Quicksort est souvent choisi pour sa rapidité en moyenne, mais il peut être moins performant dans le pire des cas.</li>
                <li>Heapsort offre des performances garanties grâce à sa complexité stable.</li>
                <li>Merge Sort est particulièrement adapté aux grandes listes et est stable dans sa performance.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étude et Implémentation des Algorithmes (1 heure)</h3>
        
            <h4>1. Quicksort</h4>
            <p>Quicksort est un algorithme de tri en place (ne nécessitant pas d'espace supplémentaire) basé sur le choix d'un pivot. Il partitionne les données en deux parties autour du pivot :</p>
        
            <p><strong>Pseudo-code de Quicksort :</strong></p>
            <pre><code>def quicksort(tableau, debut, fin):
            if debut < fin:
                pivot = partition(tableau, debut, fin)
                quicksort(tableau, debut, pivot - 1)
                quicksort(tableau, pivot + 1, fin)
                
        def partition(tableau, debut, fin):
            pivot = tableau[fin]
            i = debut - 1
            for j in range(debut, fin):
                if tableau[j] <= pivot:
                    i += 1
                    tableau[i], tableau[j] = tableau[j], tableau[i]
            tableau[i + 1], tableau[fin] = tableau[fin], tableau[i + 1]
            return i + 1
            </code></pre>
        
            <p>Quicksort fonctionne bien en moyenne, mais il peut être moins efficace si le pivot est mal choisi. Sa complexité est en moyenne <code>O(n log n)</code>, mais dans le pire des cas, elle peut atteindre <code>O(n²)</code>.</p>
        
            <h4>Exercice Pratique avec Quicksort :</h4>
            <ul>
                <li>Implémentez l’algorithme Quicksort sur une liste de nombres aléatoires.</li>
                <li>Mesurez le temps de tri en utilisant différents choix de pivots pour observer les variations de performance.</li>
            </ul>
        
            <h4>2. Heapsort</h4>
            <p>Heapsort utilise une structure de tas binaire (heap) pour trier les éléments. Le tas est une structure en forme d’arbre où chaque nœud est plus grand ou plus petit que ses enfants, ce qui permet de construire un tableau trié :</p>
        
            <p><strong>Pseudo-code de Heapsort :</strong></p>
            <pre><code>def heapsort(tableau):
            n = len(tableau)
            for i in range(n // 2 - 1, -1, -1):
                entasser(tableau, n, i)
            
            for i in range(n - 1, 0, -1):
                tableau[i], tableau[0] = tableau[0], tableau[i]
                entasser(tableau, i, 0)
                
        def entasser(tableau, n, i):
            plus_grand = i
            gauche = 2 * i + 1
            droite = 2 * i + 2
        
            if gauche < n and tableau[gauche] > tableau[plus_grand]:
                plus_grand = gauche
        
            if droite < n and tableau[droite] > tableau[plus_grand]:
                plus_grand = droite
        
            if plus_grand != i:
                tableau[i], tableau[plus_grand] = tableau[plus_grand], tableau[i]
                entasser(tableau, n, plus_grand)
            </code></pre>
        
            <p>Heapsort a une complexité stable de <code>O(n log n)</code>, ce qui en fait un choix sûr pour des tri nécessitant une garantie de performance, indépendamment de l'ordre initial des éléments.</p>
        
            <h4>Exercice Pratique avec Heapsort :</h4>
            <ul>
                <li>Implémentez Heapsort sur une liste de nombres aléatoires et mesurez le temps d'exécution.</li>
                <li>Comparez les résultats avec ceux de Quicksort sur les mêmes données.</li>
            </ul>
        
            <h4>3. Merge Sort</h4>
            <p>Merge Sort suit une approche de division-fusion. Il divise récursivement le tableau en deux moitiés, trie chaque moitié, puis fusionne les moitiés triées :</p>
        
            <p><strong>Pseudo-code de Merge Sort :</strong></p>
            <pre><code>def merge_sort(tableau):
            if len(tableau) > 1:
                milieu = len(tableau) // 2
                gauche = tableau[:milieu]
                droite = tableau[milieu:]
        
                merge_sort(gauche)
                merge_sort(droite)
        
                i = j = k = 0
        
                while i < len(gauche) and j < len(droite):
                    if gauche[i] < droite[j]:
                        tableau[k] = gauche[i]
                        i += 1
                    else:
                        tableau[k] = droite[j]
                        j += 1
                    k += 1
        
                while i < len(gauche):
                    tableau[k] = gauche[i]
                    i += 1
                    k += 1
        
                while j < len(droite):
                    tableau[k] = droite[j]
                    j += 1
                    k += 1
            </code></pre>
        
            <p>Merge Sort est stable et a une complexité garantie de <code>O(n log n)</code>, ce qui le rend particulièrement adapté pour trier de grands ensembles de données, même si cela peut nécessiter plus de mémoire.</p>
        
            <h4>Exercice Pratique avec Merge Sort :</h4>
            <ul>
                <li>Implémentez Merge Sort sur une liste de nombres et observez les temps d'exécution pour de grandes listes.</li>
                <li>Comparez les résultats de Merge Sort avec ceux de Quicksort et Heapsort.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Comparaison des Algorithmes (45 min)</h3>
        
            <h4>1. Complexité Temporelle et Efficacité</h4>
            <p>Voici un récapitulatif des complexités des trois algorithmes étudiés :</p>
            <ul>
                <li><strong>Quicksort :</strong> <code>O(n log n)</code> en moyenne, mais <code>O(n²)</code> dans le pire des cas.</li>
                <li><strong>Heapsort :</strong> <code>O(n log n)</code> dans tous les cas.</li>
                <li><strong>Merge Sort :</strong> <code>O(n log n)</code> dans tous les cas, mais nécessite plus de mémoire.</li>
            </ul>
        
            <h4>2. Observation des Performances en Pratique</h4>
            <ul>
                <li>Utilisez de grands ensembles de données pour observer les temps d'exécution et la consommation mémoire de chaque algorithme.</li>
                <li>Documentez les résultats dans un tableau pour comparer l’efficacité de chaque algorithme sur différentes tailles de listes.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion (15 min)</h3>
            <p>À la fin de cette séance, les élèves doivent être capables de :</p>
            <ul>
                <li>Expliquer les principes et les différences entre Quicksort, Heapsort et Merge Sort.</li>
                <li>Comparer ces algorithmes en fonction de leur complexité et de leurs performances en pratique.</li>
                <li>Choisir l’algorithme le plus adapté selon les caractéristiques de l’ensemble de données et les contraintes de mémoire ou de temps.</li>
            </ul>
        
            <h4>Discussion :</h4>
            <ul>
                <li>Dans quels cas choisir chaque algorithme de tri ?</li>
                <li>Comment les optimisations de mémoire influencent-elles le choix de l'algorithme ?</li>
            </ul>
        </section>

        <section id="session34" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 34 : Optimisation des Algorithmes de Tri dans des Contextes Réels</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves vont explorer et optimiser différents algorithmes de tri (tri à bulles, tri par sélection, tri rapide) dans des contextes réels. L'objectif est de comprendre les limites et les avantages de chaque algorithme selon les données à trier. Les élèves apprendront à choisir le tri le plus efficace en fonction des situations et à comparer les performances de chaque algorithme.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Algorithmes de Tri</h3>
            <p>Les algorithmes de tri sont essentiels en informatique, car ils permettent d’organiser les données pour rendre leur traitement plus efficace. Voici quelques exemples d’utilisation des algorithmes de tri dans des contextes réels :</p>
            <ul>
                <li><strong>Jeux vidéo :</strong> tri des scores des joueurs pour afficher le classement.</li>
                <li><strong>Sites de commerce électronique :</strong> tri des produits par prix, note ou popularité.</li>
                <li><strong>Banques de données :</strong> tri des transactions financières par date pour faciliter la recherche.</li>
            </ul>
            <p>Dans cette séance, nous allons explorer différents algorithmes de tri et apprendre à choisir celui qui convient le mieux selon la taille et la nature des données.</p>
        
            <h4>Les Algorithmes de Tri Principaux :</h4>
            <ul>
                <li><strong>Tri à bulles (Bubble Sort) :</strong> un algorithme simple mais peu efficace sur de grands ensembles de données.</li>
                <li><strong>Tri par sélection (Selection Sort) :</strong> un algorithme efficace sur de petits ensembles, mais moins performant sur de grands ensembles.</li>
                <li><strong>Tri rapide (Quick Sort) :</strong> un algorithme très performant pour la plupart des tailles de données.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étude et Implémentation des Algorithmes de Tri (40 min)</h3>
            <h4>1. Tri à Bulles (Bubble Sort)</h4>
            <p>Le tri à bulles consiste à comparer chaque paire d’éléments adjacents dans une liste et à échanger leur position si l'ordre est incorrect. Ce processus est répété jusqu'à ce que la liste soit triée.</p>
            
            <pre><code>def tri_a_bulles(liste):
            n = len(liste)
            for i in range(n):
                for j in range(0, n-i-1):
                    if liste[j] > liste[j+1]:
                        liste[j], liste[j+1] = liste[j+1], liste[j]
            </code></pre>
        
            <h4>2. Tri par Sélection (Selection Sort)</h4>
            <p>Le tri par sélection trouve le plus petit élément de la liste et l’échange avec le premier élément non trié. Ce processus est répété en ignorant la partie déjà triée de la liste.</p>
        
            <pre><code>def tri_par_selection(liste):
            n = len(liste)
            for i in range(n):
                min_index = i
                for j in range(i+1, n):
                    if liste[j] < liste[min_index]:
                        min_index = j
                liste[i], liste[min_index] = liste[min_index], liste[i]
            </code></pre>
        
            <h4>3. Tri Rapide (Quick Sort)</h4>
            <p>Le tri rapide est un algorithme efficace qui utilise la récursivité. Il choisit un élément "pivot" et réorganise la liste de sorte que tous les éléments inférieurs au pivot soient à gauche et tous les éléments supérieurs soient à droite. Ensuite, il trie récursivement les sous-listes de chaque côté du pivot.</p>
        
            <pre><code>def tri_rapide(liste):
            if len(liste) <= 1:
                return liste
            pivot = liste[len(liste) // 2]
            gauche = [x for x in liste if x < pivot]
            milieu = [x for x in liste if x == pivot]
            droite = [x for x in liste if x > pivot]
            return tri_rapide(gauche) + milieu + tri_rapide(droite)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Comparaison des Algorithmes dans un Contexte Réel (45 min)</h3>
            
            <h4>1. Contexte : Tri des Scores dans un Jeu Vidéo</h4>
            <p>Imaginez que nous avons une liste de scores de joueurs dans un jeu vidéo, et que nous devons afficher un classement du meilleur au moins bon. Nous allons comparer l'efficacité des trois algorithmes de tri pour ordonner cette liste.</p>
        
            <p>Liste des scores aléatoires :</p>
            <pre><code>scores = [42, 17, 88, 61, 53, 92, 74, 38, 20, 5]
            </code></pre>
        
            <h4>2. Expérience Pratique : Mesurer les Temps de Calcul</h4>
            <p>Pour chaque algorithme, les élèves doivent mesurer le temps de calcul nécessaire pour trier la liste de scores. Cela permettra de voir l'efficacité de chaque méthode sur une liste de taille moyenne.</p>
        
            <pre><code>import time
        
        # Tri à bulles
        debut = time.time()
        tri_a_bulles(scores)
        print("Temps pour le tri à bulles :", time.time() - debut)
        
        # Tri par sélection
        debut = time.time()
        tri_par_selection(scores)
        print("Temps pour le tri par sélection :", time.time() - debut)
        
        # Tri rapide
        debut = time.time()
        tri_rapide(scores)
        print("Temps pour le tri rapide :", time.time() - debut)
            </code></pre>
        
            <p>Les élèves pourront noter les temps d'exécution et constater que le tri rapide est généralement le plus performant.</p>
        
            <h4>3. Choix de l’Algorithme en Fonction du Contexte</h4>
            <p>En fonction de la taille et de la nature des données, chaque algorithme a ses avantages et inconvénients :</p>
            <ul>
                <li><strong>Tri à Bulles :</strong> adapté aux listes de petite taille ou partiellement triées, mais inefficace pour de grandes listes.</li>
                <li><strong>Tri par Sélection :</strong> fonctionne bien sur des listes de petite taille, mais est lent pour les grandes listes.</li>
                <li><strong>Tri Rapide :</strong> très efficace pour les grandes listes de données, mais peut être moins performant si les données sont déjà presque triées.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Défi Pratique (20 min)</h3>
            <ul>
                <li><strong>Étape 1 :</strong> Créez une liste de 1 000 scores aléatoires et mesurez le temps de calcul pour chaque algorithme. Quelle est la méthode la plus rapide ?</li>
                <li><strong>Étape 2 :</strong> Modifiez la liste pour qu’elle soit presque triée et comparez à nouveau les temps de calcul. Qu’observez-vous ?</li>
                <li><strong>Étape 3 :</strong> Écrivez un programme qui choisit automatiquement l’algorithme de tri optimal en fonction de la taille et de l’ordre initial de la liste.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Réflexion (15 min)</h3>
            <p>À la fin de cette séance, les élèves comprendront que le choix de l'algorithme de tri dépend du contexte : taille de la liste, ordre initial des éléments, et besoin en performance. En analysant les avantages et limitations de chaque algorithme, ils sauront comment adapter leur choix aux exigences réelles d'un programme.</p>
        
            <h4>Points de Réflexion :</h4>
            <ul>
                <li>Pourquoi certains algorithmes sont-ils plus efficaces sur des listes déjà triées ou presque triées ?</li>
                <li>Quel serait le meilleur choix d'algorithme si les données sont triées dans l'ordre inverse ?</li>
                <li>Comment pourriez-vous appliquer ces connaissances dans d'autres contextes de tri, comme la gestion de grandes bases de données ?</li>
            </ul>
        </section>

        <section id="session35" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 35 : Pratique - Choisir et implémenter l’algorithme de tri le plus efficace pour différentes situations</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre comment sélectionner et implémenter l’algorithme de tri le plus adapté en fonction de différents contextes, en utilisant des exemples pratiques issus des jeux vidéo et de l’actualité. Ils analyseront la complexité de différents algorithmes de tri (comme le tri rapide, le tri par insertion et le tri fusion) et choisiront celui qui convient le mieux selon la taille et les spécificités des données à trier.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Algorithmes de Tri (15 min)</h3>
            
            <h4>Pourquoi Utiliser des Algorithmes de Tri dans des Contextes Concrets ?</h4>
            <p>Le tri est une opération fondamentale dans de nombreuses applications. Dans un jeu vidéo, par exemple, il est souvent nécessaire de trier les scores des joueurs pour afficher un classement, ou de trier les objets dans l’inventaire d’un personnage. Dans le contexte de l’actualité, il peut être important de trier les nouvelles en fonction de leur popularité ou de leur date de publication.</p>
            
            <h4>Présentation des Algorithmes de Tri à Connaître :</h4>
            <ul>
                <li><strong>Tri par Insertion</strong> : efficace pour les petites listes ou les listes presque triées.</li>
                <li><strong>Tri Fusion</strong> : performant pour de grands ensembles de données grâce à sa complexité en <code>O(n log n)</code>.</li>
                <li><strong>Tri Rapide (Quicksort)</strong> : souvent rapide dans la pratique, mais peut être inefficace dans certains cas particuliers.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Études de Cas - Choix des Algorithmes de Tri (25 min)</h3>
            
            <h4>1. Exemple de Jeu Vidéo - Classement des Joueurs</h4>
            <p>Dans un jeu vidéo de course, chaque joueur obtient un score. Pour afficher le classement des joueurs à la fin de chaque partie, il est nécessaire de trier les scores du plus élevé au plus bas.</p>
            
            <h5>Choix de l’algorithme :</h5>
            <ul>
                <li>Le nombre de scores à trier est souvent limité, car il n’y a généralement pas des milliers de joueurs par partie.</li>
                <li>Un <strong>tri rapide</strong> ou un <strong>tri par insertion</strong> pourrait être un bon choix pour une liste de scores limitée.</li>
            </ul>
        
            <h4>2. Exemple d’Actualité - Trier les Articles par Popularité</h4>
            <p>Dans une application de nouvelles, les articles doivent être affichés par ordre de popularité (nombre de vues). Cette liste est mise à jour en temps réel.</p>
            
            <h5>Choix de l’algorithme :</h5>
            <ul>
                <li>Le nombre d’articles peut être important, mais comme les nouvelles populaires sont mises en avant, la liste pourrait être partiellement triée.</li>
                <li>Le <strong>tri fusion</strong> est souvent préféré pour sa stabilité et son efficacité sur de grands ensembles de données.</li>
            </ul>
        
            <h4>3. Autres Situations - Tri de l'Inventaire dans un Jeu Vidéo</h4>
            <p>Un personnage de jeu peut avoir de nombreux objets dans son inventaire. Ces objets peuvent être triés par type (armes, potions) ou par valeur.</p>
            
            <h5>Choix de l’algorithme :</h5>
            <ul>
                <li>Pour un inventaire de taille moyenne, le <strong>tri par insertion</strong> est efficace, car il est simple et rapide pour des listes petites à moyennes.</li>
                <li>Si l’inventaire est volumineux, un <strong>tri rapide</strong> pourrait être plus adapté.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation des Algorithmes de Tri (50 min)</h3>
        
            <h4>1. Implémentation du Tri par Insertion :</h4>
            <pre><code>def tri_insertion(liste):
            for i in range(1, len(liste)):
                cle = liste[i]
                j = i - 1
                while j >= 0 and liste[j] > cle:
                    liste[j + 1] = liste[j]
                    j -= 1
                liste[j + 1] = cle
            return liste
            </code></pre>
            <p><strong>Exercice :</strong> Utilisez cet algorithme pour trier une liste de scores de joueurs dans un jeu vidéo.</p>
        
            <h4>2. Implémentation du Tri Fusion :</h4>
            <pre><code>def tri_fusion(liste):
            if len(liste) <= 1:
                return liste
            milieu = len(liste) // 2
            gauche = tri_fusion(liste[:milieu])
            droite = tri_fusion(liste[milieu:])
            return fusion(gauche, droite)
        
        def fusion(gauche, droite):
            resultat = []
            i = j = 0
            while i < len(gauche) and j < len(droite):
                if gauche[i] < droite[j]:
                    resultat.append(gauche[i])
                    i += 1
                else:
                    resultat.append(droite[j])
                    j += 1
            resultat.extend(gauche[i:])
            resultat.extend(droite[j:])
            return resultat
            </code></pre>
            <p><strong>Exercice :</strong> Utilisez cet algorithme pour trier une liste d'articles de presse en fonction de leur popularité.</p>
        
            <h4>3. Implémentation du Tri Rapide (Quicksort) :</h4>
            <pre><code>def tri_rapide(liste):
            if len(liste) <= 1:
                return liste
            pivot = liste[len(liste) // 2]
            gauche = [x for x in liste if x < pivot]
            milieu = [x for x in liste if x == pivot]
            droite = [x for x in liste if x > pivot]
            return tri_rapide(gauche) + milieu + tri_rapide(droite)
            </code></pre>
            <p><strong>Exercice :</strong> Utilisez cet algorithme pour trier une liste de noms d’objets dans un inventaire de jeu vidéo.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Comparaison des Algorithmes (10 min)</h3>
            
            <h4>Comparaison des Algorithmes de Tri :</h4>
            <ul>
                <li><strong>Tri par Insertion :</strong> efficace pour des petites listes ou des listes presque triées. Complexité moyenne : <code>O(n^2)</code>.</li>
                <li><strong>Tri Fusion :</strong> stable et performant pour des grandes listes, mais utilise de la mémoire supplémentaire. Complexité : <code>O(n log n)</code>.</li>
                <li><strong>Tri Rapide :</strong> très rapide dans la pratique, mais instable dans le pire des cas. Complexité moyenne : <code>O(n log n)</code>, pire des cas : <code>O(n^2)</code>.</li>
            </ul>
        
            <h4>Résumé :</h4>
            <p>Les élèves ont appris à identifier l’algorithme de tri le plus adapté selon la taille et l’état initial des données. En choisissant un algorithme en fonction du contexte (comme un jeu vidéo ou une application d'actualités), ils comprennent mieux l'importance de l’efficacité dans le développement d'applications.</p>
        </section>

        <section id="session36" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 36 : Révision et consolidation des concepts d'algorithmes de tri</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves réviseront les principaux algorithmes de tri, comprendront leur fonctionnement, et analyseront leurs différences en termes de complexité. L’objectif est de renforcer leur maîtrise des algorithmes de tri et de les rendre capables de choisir l'algorithme le plus adapté selon le contexte.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Algorithmes de Tri (15 min)</h3>
            <p>Les algorithmes de tri sont des méthodes pour organiser les données dans un ordre particulier, comme l’ordre croissant ou décroissant. Ils sont essentiels en informatique, car de nombreux autres algorithmes s'appuient sur des données triées pour améliorer leurs performances.</p>
        
            <h4>Algorithmes de Tri à Étudier :</h4>
            <ul>
                <li><strong>Tri par Insertion :</strong> méthode simple et intuitive, efficace pour des listes presque triées.</li>
                <li><strong>Tri par Sélection :</strong> recherche de l'élément le plus petit à chaque itération pour le placer dans l'ordre.</li>
                <li><strong>Tri à Bulles (Bubble Sort) :</strong> échange les éléments adjacents pour faire « remonter » les plus grands éléments.</li>
                <li><strong>Tri Rapide (Quick Sort) :</strong> méthode de tri par division et conquête, efficace pour les grandes listes.</li>
                <li><strong>Tri Fusion (Merge Sort) :</strong> méthode basée sur la fusion de listes triées, adaptée aux grandes listes.</li>
            </ul>
        
            <h4>Complexité des Algorithmes :</h4>
            <p>Nous allons examiner la <strong>complexité en temps</strong> de chaque algorithme pour comparer leur efficacité :</p>
            <ul>
                <li>Tri par Insertion, Sélection, et Bulles : <code>O(n²)</code> dans le pire des cas.</li>
                <li>Tri Rapide : <code>O(n log n)</code> en moyenne, mais peut aller jusqu’à <code>O(n²)</code> dans le pire des cas.</li>
                <li>Tri Fusion : <code>O(n log n)</code> dans le pire des cas.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Révision et Implémentation des Algorithmes (50 min)</h3>
            
            <h4>1. Tri par Insertion :</h4>
            <p>Le tri par insertion parcourt la liste et insère chaque élément à sa place dans la partie déjà triée de la liste.</p>
            <pre><code>def tri_insertion(liste):
            for i in range(1, len(liste)):
                valeur = liste[i]
                j = i - 1
                while j >= 0 and liste[j] > valeur:
                    liste[j + 1] = liste[j]
                    j -= 1
                liste[j + 1] = valeur
            </code></pre>
        
            <h4>Exercice pratique :</h4>
            <ul>
                <li>Écrire une liste de nombres aléatoires.</li>
                <li>Utiliser le tri par insertion pour les trier.</li>
                <li>Observer la complexité du tri en comptant les comparaisons.</li>
            </ul>
        
            <h4>2. Tri par Sélection :</h4>
            <p>Le tri par sélection parcourt la liste pour trouver l’élément le plus petit et le place au début.</p>
            <pre><code>def tri_selection(liste):
            for i in range(len(liste)):
                min_index = i
                for j in range(i + 1, len(liste)):
                    if liste[j] < liste[min_index]:
                        min_index = j
                liste[i], liste[min_index] = liste[min_index], liste[i]
            </code></pre>
        
            <h4>Exercice pratique :</h4>
            <ul>
                <li>Utiliser le tri par sélection sur une liste aléatoire et observer la façon dont chaque élément est placé dans l’ordre.</li>
                <li>Noter la complexité pour des listes de différentes tailles.</li>
            </ul>
        
            <h4>3. Tri à Bulles (Bubble Sort) :</h4>
            <p>Le tri à bulles fait passer les éléments les plus grands vers la fin de la liste en effectuant des échanges successifs entre éléments adjacents.</p>
            <pre><code>def tri_bulles(liste):
            n = len(liste)
            for i in range(n):
                for j in range(0, n-i-1):
                    if liste[j] > liste[j+1]:
                        liste[j], liste[j+1] = liste[j+1], liste[j]
            </code></pre>
        
            <h4>Exercice pratique :</h4>
            <ul>
                <li>Utiliser le tri à bulles pour trier une liste et observer les changements à chaque passage.</li>
                <li>Comparer le nombre de comparaisons avec les autres méthodes.</li>
            </ul>
        
            <h4>4. Tri Rapide (Quick Sort) :</h4>
            <p>Le tri rapide choisit un élément pivot et divise la liste en deux parties pour les trier récursivement.</p>
            <pre><code>def tri_rapide(liste):
            if len(liste) <= 1:
                return liste
            else:
                pivot = liste[0]
                gauche = [x for x in liste[1:] if x <= pivot]
                droite = [x for x in liste[1:] if x > pivot]
                return tri_rapide(gauche) + [pivot] + tri_rapide(droite)
            </code></pre>
        
            <h4>Exercice pratique :</h4>
            <ul>
                <li>Choisir une liste d’éléments aléatoires et utiliser le tri rapide pour la trier.</li>
                <li>Observer le nombre de comparaisons et d’échanges, et comparer la vitesse avec les méthodes <code>O(n²)</code>.</li>
            </ul>
        
            <h4>5. Tri Fusion (Merge Sort) :</h4>
            <p>Le tri fusion divise la liste en sous-listes jusqu'à ce qu'elles ne contiennent qu'un élément, puis fusionne les sous-listes en ordre croissant.</p>
            <pre><code>def tri_fusion(liste):
            if len(liste) <= 1:
                return liste
            milieu = len(liste) // 2
            gauche = tri_fusion(liste[:milieu])
            droite = tri_fusion(liste[milieu:])
            return fusion(gauche, droite)
        
        def fusion(gauche, droite):
            resultat = []
            i = j = 0
            while i < len(gauche) and j < len(droite):
                if gauche[i] < droite[j]:
                    resultat.append(gauche[i])
                    i += 1
                else:
                    resultat.append(droite[j])
                    j += 1
            resultat.extend(gauche[i:])
            resultat.extend(droite[j:])
            return resultat
            </code></pre>
        
            <h4>Exercice pratique :</h4>
            <ul>
                <li>Utiliser le tri fusion pour trier une liste et observer les étapes de fusion des sous-listes.</li>
                <li>Comparer la complexité temporelle avec le tri rapide.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Comparaison des Algorithmes (15 min)</h3>
            <h4>Comparaison des Complexités :</h4>
            <p>Les élèves comparent chaque algorithme en termes de complexité, vitesse et nombre d’opérations, en utilisant des listes de différentes tailles.</p>
            <ul>
                <li>Tri Insertion, Sélection, Bulles : <code>O(n²)</code> – moins efficace pour les grandes listes.</li>
                <li>Tri Rapide : <code>O(n log n)</code> en moyenne – efficace pour les grandes listes.</li>
                <li>Tri Fusion : <code>O(n log n)</code> – stable et efficace.</li>
            </ul>
        
            <h4>Analyse Pratique :</h4>
            <ul>
                <li><strong>Stabilité :</strong> les tris fusion et insertion sont stables, ce qui est important dans certains contextes.</li>
                <li><strong>Cas d’utilisation :</strong> le tri rapide est souvent privilégié pour les grandes listes, alors que le tri insertion est adapté pour les petites listes déjà partiellement triées.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion (10 min)</h3>
            <p>À la fin de cette séance, les élèves devraient être capables de choisir le bon algorithme de tri en fonction du contexte et de la taille des données. Ils auront également acquis une bonne compréhension des différences de complexité entre chaque algorithme, ainsi que leurs avantages et inconvénients.</p>
        </section>

        <section id="session37" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 37 : Introduction à la Programmation Orientée Objet (POO) – Classes, Objets, Méthodes</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Dans cette séance, les élèves découvriront les concepts fondamentaux de la programmation orientée objet (POO) en Python. Ils apprendront à définir des classes, à créer des objets et à utiliser des méthodes pour manipuler les attributs des objets. Cette séance comporte des exercices pratiques pour illustrer chaque concept, en utilisant des exemples simples et concrets.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction à la Programmation Orientée Objet (15 min)</h3>
            
            <h4>Contexte :</h4>
            <p>La Programmation Orientée Objet (POO) est un paradigme de programmation qui permet de structurer le code en regroupant des données et des comportements dans des <strong>objets</strong>. Un objet est une instance d'une <strong>classe</strong>, qui est un modèle ou une "usine" pour créer des objets similaires.</p>
        
            <h4>Concepts Clés :</h4>
            <ul>
                <li><strong>Classe :</strong> Une classe est un modèle pour créer des objets. Elle définit les attributs (données) et les méthodes (fonctions) que chaque objet de cette classe possédera.</li>
                <li><strong>Objet :</strong> Un objet est une instance de classe. C’est une entité spécifique créée à partir d’une classe, avec ses propres valeurs d'attributs.</li>
                <li><strong>Méthode :</strong> Une méthode est une fonction définie dans une classe. Elle décrit les actions qu'un objet de cette classe peut effectuer.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Définition d’une Classe en Python (20 min)</h3>
            
            <h4>Exemple : Classe Personnage dans un Jeu Vidéo</h4>
            <p>Imaginons que nous créons un jeu vidéo. Nous avons besoin de définir un modèle pour les personnages du jeu, avec des attributs comme le <strong>nom</strong> du personnage et ses <strong>points de vie</strong>, et des méthodes pour qu'il puisse <strong>se déplacer</strong> ou <strong>attaquer</strong>.</p>
        
            <h4>Code Exemple :</h4>
            <p>Voici comment définir une classe <code>Personnage</code> avec deux attributs et une méthode :</p>
            <pre><code>class Personnage:
            def __init__(self, nom, points_de_vie):
                self.nom = nom                # Attribut 'nom'
                self.points_de_vie = points_de_vie  # Attribut 'points de vie'
            
            def se_presenter(self):
                print(f"Je suis {self.nom} et j'ai {self.points_de_vie} points de vie.")
            </code></pre>
        
            <p><strong>Explication :</strong></p>
            <ul>
                <li><code>__init__</code> : Cette méthode spéciale s’appelle le <strong>constructeur</strong>. Elle est appelée automatiquement quand un nouvel objet est créé. Elle initialise les attributs de l'objet.</li>
                <li><code>self</code> : Représente l'instance de l'objet actuel. Il est utilisé pour accéder aux attributs et méthodes de l'objet dans la classe.</li>
                <li><code>nom</code> et <code>points_de_vie</code> : Attributs de la classe <code>Personnage</code>, qui stockent le nom et les points de vie du personnage.</li>
                <li><code>se_presenter</code> : Méthode qui affiche une présentation du personnage.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Création et Utilisation d’Objets (25 min)</h3>
            
            <h4>1. Créer un Objet</h4>
            <p>Pour créer un objet de la classe <code>Personnage</code>, on utilise la syntaxe suivante :</p>
            <pre><code># Création d'un objet de la classe Personnage
        heros = Personnage("Arthur", 100)
            </code></pre>
        
            <h4>2. Utiliser les Attributs et Méthodes de l'Objet</h4>
            <p>Une fois l'objet <code>heros</code> créé, nous pouvons accéder à ses attributs et méthodes :</p>
            <pre><code># Accéder aux attributs
        print(heros.nom)           # Affiche "Arthur"
        print(heros.points_de_vie) # Affiche 100
        
        # Appeler une méthode
        heros.se_presenter()        # Affiche "Je suis Arthur et j'ai 100 points de vie."
            </code></pre>
        
            <p><strong>Explication :</strong> Ici, nous avons créé un personnage appelé "Arthur" avec 100 points de vie. En appelant <code>heros.se_presenter()</code>, nous demandons à l'objet de se présenter.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exercice Pratique (40 min)</h3>
            <h4>Contexte du Jeu :</h4>
            <p>Dans un jeu de rôle, chaque personnage peut avoir un nom, des points de vie et une action de présentation. Nous allons étendre cet exemple en ajoutant une méthode pour que le personnage puisse <strong>perdre des points de vie</strong> lorsqu'il prend des dégâts.</p>
        
            <h4>Étapes de l'Exercice :</h4>
            <ol>
                <li><strong>Étape 1 :</strong> Ajoutez une méthode <code>subir_degats</code> dans la classe <code>Personnage</code> qui réduit les points de vie du personnage.</li>
                <li><strong>Étape 2 :</strong> Utilisez cette méthode pour simuler un combat où le personnage prend des dégâts et affiche ses points de vie restants.</li>
            </ol>
        
            <h4>Code de Base :</h4>
            <pre><code>class Personnage:
            def __init__(self, nom, points_de_vie):
                self.nom = nom
                self.points_de_vie = points_de_vie
            
            def se_presenter(self):
                print(f"Je suis {self.nom} et j'ai {self.points_de_vie} points de vie.")
            
            def subir_degats(self, degats):
                self.points_de_vie -= degats
                print(f"{self.nom} subit {degats} points de dégâts. Points de vie restants : {self.points_de_vie}")
            </code></pre>
        
            <h4>Exemple d'Utilisation :</h4>
            <pre><code># Créer un personnage
        heros = Personnage("Arthur", 100)
        
        # Le personnage se présente
        heros.se_presenter()
        
        # Le personnage subit des dégâts
        heros.subir_degats(20)   # Réduit les points de vie de 20
        heros.subir_degats(10)   # Réduit les points de vie de 10
            </code></pre>
        
            <h4>Résultat Attendu :</h4>
            <p>Le programme doit afficher :</p>
            <pre><code>Je suis Arthur et j'ai 100 points de vie.
        Arthur subit 20 points de dégâts. Points de vie restants : 80
        Arthur subit 10 points de dégâts. Points de vie restants : 70
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Questions de Réflexion (20 min)</h3>
        
            <h4>Récapitulatif :</h4>
            <p>Dans cette séance, les élèves ont appris :</p>
            <ul>
                <li>À définir une <strong>classe</strong> avec des attributs et des méthodes.</li>
                <li>À créer des <strong>objets</strong> de cette classe et à manipuler leurs attributs et méthodes.</li>
                <li>À comprendre l'importance de la <strong>POO</strong> pour structurer le code de manière modulaire et réutilisable.</li>
            </ul>
        
            <h4>Questions pour Approfondir :</h4>
            <ul>
                <li>Comment pouvez-vous ajouter des <strong>types de personnages</strong> différents (par exemple, Guerrier, Mage) qui ont chacun des actions spécifiques ?</li>
                <li>Comment pourrait-on améliorer la méthode <code>subir_degats</code> pour éviter que les points de vie ne deviennent négatifs ?</li>
                <li>Que se passe-t-il si on ajoute de nouveaux attributs à la classe ? Comment cela affecte-t-il les objets existants ?</li>
            </ul>
        
            <h4>Défi supplémentaire :</h4>
            <p>Demandez aux élèves de créer une nouvelle méthode appelée <code>soigner</code> qui permet au personnage de regagner des points de vie lorsqu’il reçoit des soins. Cette méthode doit vérifier que les points de vie ne dépassent pas un maximum (par exemple, 100).</p>
        
        </section>

        <section id="session38" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 38 : Pratique - Modélisation d’un personnage de jeu vidéo en POO</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront à utiliser les concepts de Programmation Orientée Objet (POO) pour modéliser un personnage de jeu vidéo. Ils vont créer une classe <code>Personnage</code> avec différents attributs et méthodes pour simuler les actions et l’évolution du personnage dans le jeu.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction à la Modélisation d'un Personnage (15 min)</h3>
        
            <h4>Concept de Modélisation en POO :</h4>
            <p>Dans les jeux vidéo, chaque personnage possède des caractéristiques (comme la santé, la force, la vitesse) et peut accomplir des actions (comme se déplacer, attaquer, utiliser des objets). Nous allons utiliser la POO pour représenter ces caractéristiques et actions sous forme de <strong>classes</strong> et de <strong>méthodes</strong>.</p>
        
            <h4>Définition de la Classe <code>Personnage</code> :</h4>
            <p>La classe <code>Personnage</code> représentera un personnage de jeu vidéo. Cette classe inclura :</p>
            <ul>
                <li>Des <strong>attributs</strong> pour stocker les caractéristiques du personnage, comme son nom, ses points de vie, sa force, et sa position.</li>
                <li>Des <strong>méthodes</strong> pour effectuer des actions, comme se déplacer, attaquer, et récupérer des points de vie.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 1 : Création de la Classe Personnage et des Attributs (30 min)</h3>
        
            <h4>1. Définition des Attributs :</h4>
            <p>Chaque personnage aura les attributs suivants :</p>
            <ul>
                <li><strong>nom</strong> : le nom du personnage.</li>
                <li><strong>points_vie</strong> : le nombre de points de vie restants.</li>
                <li><strong>force</strong> : la force d’attaque du personnage.</li>
                <li><strong>position</strong> : la position du personnage dans le jeu (par exemple, représentée par des coordonnées x et y).</li>
            </ul>
        
            <h4>2. Implémentation de la Classe Personnage :</h4>
            <p>Voici le code de base pour la classe <code>Personnage</code> avec les attributs définis :</p>
        
            <pre><code>class Personnage:
            def __init__(self, nom, points_vie, force, position=(0, 0)):
                self.nom = nom  # Nom du personnage
                self.points_vie = points_vie  # Points de vie
                self.force = force  # Force d'attaque
                self.position = position  # Position (x, y)
        
            def afficher_informations(self):
                print(f"Nom : {self.nom}")
                print(f"Points de vie : {self.points_vie}")
                print(f"Force : {self.force}")
                print(f"Position : {self.position}")
            </code></pre>
        
            <h4>3. Explication du Code :</h4>
            <ul>
                <li>Le constructeur <code>__init__()</code> initialise les attributs du personnage.</li>
                <li>La méthode <code>afficher_informations()</code> permet d’afficher les informations du personnage, ce qui sera utile pour vérifier les attributs de chaque instance.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 2 : Ajouter des Méthodes d'Action (45 min)</h3>
        
            <h4>1. Méthode <code>se_deplacer()</code> :</h4>
            <p>Cette méthode permettra au personnage de se déplacer dans le jeu. Elle acceptera une direction (<code>haut</code>, <code>bas</code>, <code>gauche</code>, <code>droite</code>) et mettra à jour les coordonnées du personnage en conséquence.</p>
        
            <pre><code>def se_deplacer(self, direction):
            x, y = self.position
            if direction == "haut":
                self.position = (x, y + 1)
            elif direction == "bas":
                self.position = (x, y - 1)
            elif direction == "gauche":
                self.position = (x - 1, y)
            elif direction == "droite":
                self.position = (x + 1, y)
            print(f"{self.nom} s'est déplacé vers {direction}. Nouvelle position : {self.position}")
            </code></pre>
        
            <h4>2. Méthode <code>attaquer()</code> :</h4>
            <p>Cette méthode permet au personnage d’attaquer un autre personnage. Elle prend un objet <code>cible</code> comme paramètre et réduit les points de vie de la cible en fonction de la force du personnage attaquant.</p>
        
            <pre><code>def attaquer(self, cible):
            print(f"{self.nom} attaque {cible.nom} avec une force de {self.force}")
            cible.points_vie -= self.force
            print(f"{cible.nom} a maintenant {cible.points_vie} points de vie restants.")
            if cible.points_vie <= 0:
                print(f"{cible.nom} a été vaincu !")
            </code></pre>
        
            <h4>3. Méthode <code>soigner()</code> :</h4>
            <p>La méthode <code>soigner()</code> permet au personnage de regagner des points de vie.</p>
        
            <pre><code>def soigner(self, points):
            self.points_vie += points
            print(f"{self.nom} a récupéré {points} points de vie. Points de vie actuels : {self.points_vie}")
            </code></pre>
        
            <h4>4. Code Complet de la Classe <code>Personnage</code> :</h4>
            <pre><code>class Personnage:
            def __init__(self, nom, points_vie, force, position=(0, 0)):
                self.nom = nom
                self.points_vie = points_vie
                self.force = force
                self.position = position
        
            def afficher_informations(self):
                print(f"Nom : {self.nom}")
                print(f"Points de vie : {self.points_vie}")
                print(f"Force : {self.force}")
                print(f"Position : {self.position}")
        
            def se_deplacer(self, direction):
                x, y = self.position
                if direction == "haut":
                    self.position = (x, y + 1)
                elif direction == "bas":
                    self.position = (x, y - 1)
                elif direction == "gauche":
                    self.position = (x - 1, y)
                elif direction == "droite":
                    self.position = (x + 1, y)
                print(f"{self.nom} s'est déplacé vers {direction}. Nouvelle position : {self.position}")
        
            def attaquer(self, cible):
                print(f"{self.nom} attaque {cible.nom} avec une force de {self.force}")
                cible.points_vie -= self.force
                print(f"{cible.nom} a maintenant {cible.points_vie} points de vie restants.")
                if cible.points_vie <= 0:
                    print(f"{cible.nom} a été vaincu !")
        
            def soigner(self, points):
                self.points_vie += points
                print(f"{self.nom} a récupéré {points} points de vie. Points de vie actuels : {self.points_vie}")
            </code></pre>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Créez deux personnages avec des noms, des points de vie, et des forces différentes.</li>
                <li><strong>Étape 2 :</strong> Faites-les se déplacer sur une grille et simulez un combat où chaque personnage attaque l'autre.</li>
                <li><strong>Étape 3 :</strong> Utilisez la méthode <code>soigner()</code> pour régénérer les points de vie d’un personnage après une attaque.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Analyse (15 min)</h3>
            <p>Les élèves auront appris à modéliser un personnage de jeu vidéo en utilisant la POO. Ils auront mis en pratique les concepts de classe, d'attributs et de méthodes pour créer un modèle de personnage complet capable de se déplacer, d’attaquer et de se soigner. Cette structure de code pourra être réutilisée et étendue dans des projets futurs pour simuler des comportements plus complexes dans un jeu vidéo.</p>
        </section>

        <section id="session39" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 39 : Héritage et Polymorphisme (Théorie)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Cette séance a pour but de permettre aux élèves de comprendre les concepts d'héritage et de polymorphisme en programmation orientée objet (POO). Ils apprendront comment utiliser l'héritage pour structurer le code et comment le polymorphisme permet de gérer différentes méthodes de manière flexible et uniforme.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction à l'Héritage et au Polymorphisme</h3>
            
            <h4>Qu'est-ce que la Programmation Orientée Objet (POO) ?</h4>
            <p>La programmation orientée objet est un paradigme de programmation qui permet de structurer les programmes en utilisant des objets. Chaque objet est une instance d'une <strong>classe</strong>, et les classes permettent de regrouper des <strong>attributs</strong> (données) et des <strong>méthodes</strong> (fonctions) qui définissent le comportement des objets.</p>
            <p>Deux concepts clés en POO sont l'<strong>héritage</strong> et le <strong>polymorphisme</strong>, qui permettent de créer des structures de code réutilisables et flexibles.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Partie 1 : L'Héritage (50 min)</h3>
            
            <h4>1. Définition de l'Héritage</h4>
            <p>L'héritage permet de créer une nouvelle classe qui <strong>hérite</strong> des attributs et méthodes d'une classe existante. La classe existante est appelée <strong>classe parente</strong> (ou super-classe), et la nouvelle classe est appelée <strong>classe enfant</strong> (ou sous-classe).</p>
            <p>En utilisant l'héritage, la classe enfant peut :</p>
            <ul>
                <li>Accéder aux attributs et méthodes de la classe parente.</li>
                <li>Ajouter ses propres attributs et méthodes.</li>
                <li>Redéfinir (ou <em>surcharger</em>) certaines méthodes de la classe parente.</li>
            </ul>
        
            <h4>2. Avantages de l'Héritage</h4>
            <p>L'héritage permet de :</p>
            <ul>
                <li>Réutiliser le code existant, ce qui rend le programme plus efficace et facile à maintenir.</li>
                <li>Organiser les classes en hiérarchies, ce qui facilite la compréhension de la structure du programme.</li>
                <li>Éviter la duplication du code en centralisant les méthodes et attributs communs dans la classe parente.</li>
            </ul>
        
            <h4>3. Exemple d'Héritage dans un Jeu Vidéo</h4>
            <p>Imaginons un jeu où il y a plusieurs types de personnages : des guerriers, des mages et des archers. Tous les personnages partagent des caractéristiques communes, comme un nom et des points de vie, mais chaque type de personnage a des capacités spécifiques.</p>
            <p>Nous pouvons définir une <strong>classe parente</strong> appelée <code>Personnage</code>, et des <strong>classes enfants</strong> pour chaque type de personnage :</p>
            
            <pre><code>class Personnage:
            def __init__(self, nom, points_vie):
                self.nom = nom
                self.points_vie = points_vie
        
            def se_presenter(self):
                print(f"Je suis {self.nom} avec {self.points_vie} points de vie.")
        
        class Guerrier(Personnage):
            def __init__(self, nom, points_vie, force):
                super().__init__(nom, points_vie)  # Appel du constructeur de la classe parente
                self.force = force
        
            def attaquer(self):
                print(f"{self.nom} attaque avec une force de {self.force}!")
        
        class Mage(Personnage):
            def __init__(self, nom, points_vie, mana):
                super().__init__(nom, points_vie)
                self.mana = mana
        
            def lancer_sort(self):
                print(f"{self.nom} lance un sort avec {self.mana} points de mana!")
            </code></pre>
        
            <p>Dans cet exemple :</p>
            <ul>
                <li>La classe <code>Personnage</code> est la <strong>classe parente</strong>, contenant des attributs communs (<code>nom</code> et <code>points_vie</code>).</li>
                <li>Les classes <code>Guerrier</code> et <code>Mage</code> sont des <strong>classes enfants</strong> qui héritent de <code>Personnage</code>.</li>
                <li>Chaque classe enfant ajoute ses propres attributs (<code>force</code> pour <code>Guerrier</code> et <code>mana</code> pour <code>Mage</code>), et peut aussi définir des méthodes spécifiques comme <code>attaquer()</code> et <code>lancer_sort()</code>.</li>
            </ul>
        
            <h4>4. Exercices Pratiques</h4>
            <ul>
                <li>Créer une classe enfant <code>Archer</code> qui hérite de <code>Personnage</code> et ajoute un attribut spécifique comme <code>precison</code>.</li>
                <li>Implémenter une méthode pour chaque classe enfant qui utilise les attributs spécifiques de chaque personnage.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Partie 2 : Le Polymorphisme (50 min)</h3>
        
            <h4>1. Définition du Polymorphisme</h4>
            <p>Le polymorphisme est la capacité d'utiliser une même méthode sur des objets de classes différentes. Avec le polymorphisme, des objets de différentes classes peuvent être manipulés de manière uniforme en utilisant une interface commune.</p>
            <p>Dans l'exemple précédent, tous les personnages peuvent être appelés pour se présenter ou exécuter une action, quelle que soit leur classe. Cela permet de traiter différents objets de manière homogène.</p>
        
            <h4>2. Exemple de Polymorphisme</h4>
            <p>Nous allons utiliser le polymorphisme pour faire en sorte que chaque personnage (qu’il soit guerrier, mage ou archer) puisse exécuter une méthode commune <code>agir()</code> mais avec un comportement propre à chaque type de personnage.</p>
        
            <pre><code>class Personnage:
            def agir(self):
                print("Le personnage effectue une action.")
        
        class Guerrier(Personnage):
            def agir(self):
                print("Le guerrier attaque avec une épée!")
        
        class Mage(Personnage):
            def agir(self):
                print("Le mage lance un sort!")
        
        class Archer(Personnage):
            def agir(self):
                print("L'archer tire une flèche!")
            </code></pre>
        
            <h4>3. Utilisation Pratique du Polymorphisme</h4>
            <p>En utilisant le polymorphisme, nous pouvons créer une liste de personnages et les faire agir de manière uniforme :</p>
            
            <pre><code>personnages = [Guerrier(), Mage(), Archer()]
        
        for personnage in personnages:
            personnage.agir()  # Chaque personnage agit de manière spécifique
            </code></pre>
        
            <p>Dans cet exemple, chaque personnage exécute la méthode <code>agir()</code>, mais le comportement de cette méthode est propre à chaque classe. C’est là que réside la puissance du polymorphisme, car il permet d’utiliser une interface commune pour des comportements différents.</p>
        
            <h4>4. Exercices Pratiques</h4>
            <ul>
                <li>Ajouter d'autres types de personnages avec des comportements spécifiques dans la méthode <code>agir()</code>.</li>
                <li>Créer une fonction qui prend une liste de personnages et fait agir chaque personnage, démontrant ainsi le polymorphisme.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion (20 min)</h3>
            <h4>Résumé des Concepts :</h4>
            <ul>
                <li><strong>Héritage :</strong> Permet à une classe enfant d'hériter des attributs et méthodes d'une classe parente, réduisant la duplication de code.</li>
                <li><strong>Polymorphisme :</strong> Permet à des objets de classes différentes de répondre à une méthode commune de manière spécifique, offrant une grande flexibilité dans le code.</li>
            </ul>
        
            <h4>Discussion :</h4>
            <p>Discutez avec les élèves des avantages de l’héritage et du polymorphisme dans les projets de programmation. En particulier, abordez comment ces concepts permettent de structurer le code de manière claire et réutilisable dans des projets complexes, comme des jeux vidéo ou des applications de gestion.</p>
        </section>

        <section id="session40" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 40 : Pratique - Implémentation d’un Système d’Héritage dans une Application de Gestion de Personnages (Jeu Vidéo)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront à implémenter un système d’héritage en programmation orientée objet dans un contexte de jeu vidéo. Ils créeront une hiérarchie de classes pour représenter différents types de personnages dans un jeu (comme des joueurs, des ennemis, et des PNJ) et apprendront à utiliser l'héritage pour partager des caractéristiques et des comportements communs.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction à l’Héritage dans le Contexte du Jeu Vidéo</h3>
            
            <h4>Contexte :</h4>
            <p>Dans de nombreux jeux vidéo, il existe différents types de personnages : le joueur, des ennemis, et des PNJ (personnages non jouables) qui interagissent avec le joueur. Bien que chaque type de personnage ait ses propres caractéristiques, ils partagent également des propriétés communes comme des points de vie, une position, et des méthodes pour se déplacer ou attaquer.</p>
            
            <p>L’héritage permet de créer une structure de classes où les personnages partagent des attributs communs tout en ayant des comportements spécifiques. Par exemple :</p>
            <ul>
                <li>Un <strong>Personnage</strong> de base peut avoir des attributs comme des <code>points_de_vie</code> et une <code>position</code>.</li>
                <li>Un <strong>Joueur</strong> peut hériter de la classe <code>Personnage</code> et avoir des méthodes supplémentaires, comme <code>attaquer</code> ou <code>utiliser_objet</code>.</li>
                <li>Un <strong>Ennemi</strong> peut également hériter de <code>Personnage</code> et avoir une méthode <code>poursuivre_joueur</code>.</li>
            </ul>
            
            <h4>Exemple de Structure de Classe :</h4>
            <pre><code>Personnage (classe de base)
        ├── Joueur (hérite de Personnage)
        └── Ennemi (hérite de Personnage)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Définition des Classes de Base (30 min)</h3>
        
            <h4>1. Création de la Classe de Base : Personnage</h4>
            <p>La classe <code>Personnage</code> représente tous les personnages du jeu, qu’ils soient joueurs, ennemis ou PNJ. Elle contient des attributs et méthodes de base que tous les personnages partagent.</p>
        
            <pre><code>class Personnage:
            def __init__(self, nom, points_de_vie, position):
                self.nom = nom
                self.points_de_vie = points_de_vie
                self.position = position
        
            def se_deplacer(self, x, y):
                self.position = (x, y)
                print(f"{self.nom} se déplace à la position {self.position}")
        
            def afficher_statut(self):
                print(f"{self.nom} - PV : {self.points_de_vie}")
            </code></pre>
        
            <ul>
                <li><strong>Attributs :</strong> <code>nom</code>, <code>points_de_vie</code>, et <code>position</code>.</li>
                <li><strong>Méthodes :</strong> <code>se_deplacer</code> pour déplacer le personnage, et <code>afficher_statut</code> pour afficher ses points de vie.</li>
            </ul>
        
            <h4>2. Création de la Classe Joueur</h4>
            <p>La classe <code>Joueur</code> hérite de <code>Personnage</code>. Elle représente le personnage contrôlé par le joueur et ajoute des méthodes spécifiques, comme l'attaque.</p>
        
            <pre><code>class Joueur(Personnage):
            def __init__(self, nom, points_de_vie, position, niveau):
                super().__init__(nom, points_de_vie, position)
                self.niveau = niveau
        
            def attaquer(self, cible):
                print(f"{self.nom} attaque {cible.nom}!")
                cible.points_de_vie -= 10
                if cible.points_de_vie <= 0:
                    print(f"{cible.nom} est vaincu!")
            </code></pre>
        
            <ul>
                <li><strong>Attribut spécifique :</strong> <code>niveau</code> du joueur.</li>
                <li><strong>Méthode spécifique :</strong> <code>attaquer</code>, qui réduit les points de vie d'une cible.</li>
            </ul>
        
            <h4>3. Création de la Classe Ennemi</h4>
            <p>La classe <code>Ennemi</code> hérite également de <code>Personnage</code>. Elle représente un ennemi qui peut poursuivre le joueur.</p>
        
            <pre><code>class Ennemi(Personnage):
            def __init__(self, nom, points_de_vie, position, force):
                super().__init__(nom, points_de_vie, position)
                self.force = force
        
            def poursuivre_joueur(self, joueur):
                print(f"{self.nom} poursuit {joueur.nom}!")
                # Logique simplifiée pour déplacer l'ennemi vers la position du joueur
                self.position = joueur.position
                print(f"{self.nom} se déplace vers la position {self.position}")
            </code></pre>
        
            <ul>
                <li><strong>Attribut spécifique :</strong> <code>force</code> de l’ennemi.</li>
                <li><strong>Méthode spécifique :</strong> <code>poursuivre_joueur</code>, qui permet à l'ennemi de se déplacer vers la position du joueur.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique : Interaction entre Personnages (45 min)</h3>
            
            <h4>1. Initialisation des Personnages</h4>
            <p>Nous allons créer une instance de chaque classe pour tester leur interaction dans le jeu.</p>
        
            <pre><code># Création des personnages
        joueur = Joueur("Héros", 100, (0, 0), niveau=5)
        ennemi = Ennemi("Gobelin", 50, (5, 5), force=3)
        
        # Afficher le statut initial
        joueur.afficher_statut()
        ennemi.afficher_statut()
            </code></pre>
        
            <h4>2. Déplacement et Interaction</h4>
            <p>Déplaçons le joueur et l'ennemi, et faisons en sorte que le joueur attaque l'ennemi.</p>
        
            <pre><code># Déplacement du joueur et de l'ennemi
        joueur.se_deplacer(2, 2)
        ennemi.poursuivre_joueur(joueur)
        
        # Interaction : le joueur attaque l'ennemi
        joueur.attaquer(ennemi)
        
        # Afficher le statut après l'attaque
        ennemi.afficher_statut()
            </code></pre>
        
            <h4>3. Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Ajouter une nouvelle classe <code>PNJ</code> (personnage non jouable) qui hérite de <code>Personnage</code> et qui possède une méthode <code>parler</code>.</li>
                <li><strong>Étape 2 :</strong> Créer plusieurs instances de chaque type de personnage et tester leurs interactions.</li>
                <li><strong>Étape 3 :</strong> Ajouter une méthode <code>soigner</code> au <code>Joueur</code> pour restaurer des points de vie.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion (5 min)</h3>
            <p>À la fin de cette séance, les élèves auront appris à implémenter un système d'héritage pour organiser différents types de personnages dans un jeu vidéo. Ils auront vu comment l'héritage permet de partager des attributs communs tout en ajoutant des fonctionnalités spécifiques à chaque type de personnage.</p>
        
            <h4>Points de Discussion :</h4>
            <ul>
                <li>Comment l'héritage permet-il de simplifier et de structurer le code ?</li>
                <li>Quels avantages apporte l'héritage lorsqu'on ajoute de nouveaux types de personnages ?</li>
            </ul>
        </section>

        <section id="session41" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 41 : Introduction aux Design Patterns - Singleton et Factory</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Cette séance introduit deux design patterns essentiels en programmation orientée objet : le <strong>Singleton</strong> et le <strong>Factory</strong>. Les élèves apprendront comment utiliser ces patterns dans le développement d’un jeu vidéo pour simplifier la gestion des objets et optimiser le code.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Qu'est-ce qu'un Design Pattern ?</h3>
            <p>Un <strong>design pattern</strong> (ou patron de conception) est une solution standardisée pour résoudre des problèmes récurrents en développement logiciel. Les design patterns facilitent la maintenance, la compréhension et l'extensibilité du code en structurant les solutions de manière efficace.</p>
            <p>Les deux design patterns abordés aujourd'hui sont :</p>
            <ul>
                <li><strong>Singleton :</strong> Assure qu'une classe n'ait qu'une seule instance et fournit un point d'accès global à cette instance.</li>
                <li><strong>Factory :</strong> Simplifie la création d'objets en centralisant leur instanciation, permettant de choisir dynamiquement le type d'objet à créer.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Design Pattern Singleton (40 min)</h3>
        
            <h4>1. Principe du Singleton :</h4>
            <p>Le Singleton est un design pattern qui permet de restreindre l'instanciation d'une classe à une seule instance. Ce pattern est utile lorsque vous avez besoin d'un seul point de contrôle dans votre application.</p>
        
            <h4>Exemple d’Utilisation en Jeu Vidéo :</h4>
            <p>Dans un jeu vidéo, on peut utiliser le Singleton pour la <strong>gestion des paramètres de jeu</strong> ou la <strong>musique de fond</strong>. Par exemple, le jeu n’a besoin que d’une seule instance de musique en arrière-plan, et cette instance doit être accessible partout dans le code.</p>
        
            <h4>Implémentation du Singleton en Python :</h4>
            <p>Voici un exemple d’implémentation de Singleton pour la gestion de la musique de fond dans un jeu vidéo :</p>
        
            <pre><code>class MusiqueDeFond:
            _instance = None  # Stocke l'unique instance de la classe
        
            def __new__(cls):
                if cls._instance is None:
                    cls._instance = super(MusiqueDeFond, cls).__new__(cls)
                    cls._instance.volume = 50  # Par exemple, un volume par défaut
                    print("Nouvelle instance de MusiqueDeFond créée.")
                return cls._instance
            
            def jouer(self):
                print("La musique de fond joue.")
        
            def regler_volume(self, niveau):
                self.volume = niveau
                print(f"Volume réglé à : {self.volume}")
            </code></pre>
        
            <h4>Explication du Code :</h4>
            <ul>
                <li><strong>La méthode <code>__new__</code></strong> vérifie si une instance de <code>MusiqueDeFond</code> existe déjà. Si ce n'est pas le cas, elle en crée une. Sinon, elle retourne l'instance existante.</li>
                <li>En instanciant la classe plusieurs fois, on s'apercevra que la même instance est utilisée à chaque appel.</li>
            </ul>
        
            <h4>Exemple Pratique :</h4>
            <p>Testons le Singleton :</p>
        
            <pre><code>musique1 = MusiqueDeFond()
        musique2 = MusiqueDeFond()
        
        musique1.jouer()
        musique2.regler_volume(75)
        
        print(musique1.volume)  # Affichera 75, car musique1 et musique2 pointent vers la même instance
            </code></pre>
        
            <h4>Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Créez une classe Singleton pour la gestion des paramètres de jeu (volume global, difficulté).</li>
                <li><strong>Étape 2 :</strong> Utilisez le Singleton pour modifier et afficher les paramètres dans différentes parties du code.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Design Pattern Factory (40 min)</h3>
        
            <h4>1. Principe du Factory :</h4>
            <p>Le pattern Factory centralise la création d’objets dans une méthode ou une classe dédiée, ce qui permet de créer dynamiquement des instances de différents types selon les besoins. Cela rend le code plus flexible et plus facilement modifiable.</p>
        
            <h4>Exemple d’Utilisation en Jeu Vidéo :</h4>
            <p>Dans un jeu vidéo, le pattern Factory est utile pour créer des objets dynamiquement, comme des ennemis, des objets à ramasser, ou des obstacles. Par exemple, le jeu peut décider de créer différents types d’ennemis en fonction du niveau.</p>
        
            <h4>Implémentation d’un Factory en Python :</h4>
            <p>Imaginons une Factory qui génère différents types d’ennemis dans un jeu.</p>
        
            <pre><code>class Ennemi:
            def __init__(self, type_ennemi):
                self.type = type_ennemi
        
            def attaquer(self):
                print(f"L'ennemi de type {self.type} attaque !")
        
        class EnnemiFactory:
            @staticmethod
            def creer_ennemi(type_ennemi):
                return Ennemi(type_ennemi)
            </code></pre>
        
            <h4>Explication du Code :</h4>
            <ul>
                <li><strong>La classe <code>Ennemi</code></strong> représente un ennemi avec un type défini lors de sa création.</li>
                <li><strong>La classe <code>EnnemiFactory</code></strong> possède une méthode statique <code>creer_ennemi</code> qui prend le type d'ennemi en paramètre et retourne une instance d’<code>Ennemi</code>.</li>
            </ul>
        
            <h4>Exemple Pratique :</h4>
            <p>Utilisons la Factory pour créer différents types d'ennemis :</p>
        
            <pre><code># Utilisation de la Factory pour créer des ennemis
        gobelin = EnnemiFactory.creer_ennemi("gobelin")
        troll = EnnemiFactory.creer_ennemi("troll")
        
        gobelin.attaquer()  # Affiche : L'ennemi de type gobelin attaque !
        troll.attaquer()    # Affiche : L'ennemi de type troll attaque !
            </code></pre>
        
            <h4>Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Ajoutez d’autres types d’ennemis (ex. : dragon, sorcier) en utilisant la Factory.</li>
                <li><strong>Étape 2 :</strong> Créez une liste d'ennemis en utilisant un tableau et utilisez la Factory pour instancier chaque ennemi de manière dynamique.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Comparaison des Patterns Singleton et Factory (20 min)</h3>
        
            <h4>Comparaison :</h4>
            <p>Bien que Singleton et Factory soient tous deux des patterns de création, ils répondent à des besoins différents :</p>
            <ul>
                <li><strong>Singleton :</strong> Assure qu’une seule instance d’une classe existe à tout moment. Cela est utile pour des objets globaux qui nécessitent un contrôle centralisé (comme les paramètres de jeu ou la musique).</li>
                <li><strong>Factory :</strong> Simplifie la création d'objets diversifiés en centralisant leur instanciation. Cela est pratique pour créer plusieurs objets de types différents selon le contexte (comme des ennemis de types différents dans un jeu).</li>
            </ul>
        
            <h4>Avantages et Inconvénients :</h4>
            <table>
                <tr>
                    <th>Pattern</th>
                    <th>Avantages</th>
                    <th>Inconvénients</th>
                </tr>
                <tr>
                    <td>Singleton</td>
                    <td>
                        <ul>
                            <li>Contrôle centralisé de l’accès à l’instance unique.</li>
                            <li>Réduction de la consommation de mémoire pour les objets globaux.</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Peut entraîner une dépendance excessive au Singleton.</li>
                            <li>Peut devenir difficile à tester si mal utilisé.</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Factory</td>
                    <td>
                        <ul>
                            <li>Modularité et flexibilité dans la création d'objets.</li>
                            <li>Facilité de modification et d'extension du code.</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Peut compliquer la structure du code si utilisé pour des objets simples.</li>
                        </ul>
                    </td>
                </tr>
            </table>
        
            <h4>Conclusion :</h4>
            <p>Les design patterns Singleton et Factory sont des outils puissants pour améliorer la structure et la lisibilité du code. Le Singleton est idéal pour la gestion des ressources uniques, tandis que le Factory permet de créer des objets variés selon le contexte.</p>
        </section>

        <section id="session42" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 42 : Pratique - Utilisation de Design Patterns pour Optimiser la Gestion des Niveaux d’un Jeu Vidéo</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Cette séance vise à introduire certains <strong>design patterns</strong> courants en programmation orientée objet et à les appliquer pour optimiser la gestion des niveaux dans un jeu vidéo. Les élèves apprendront à structurer leur code en utilisant des patterns comme le <strong>Singleton</strong> et le <strong>Factory</strong> pour améliorer l'organisation, la réutilisabilité et l'évolutivité de leur code.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Design Patterns</h3>
            <h4>Qu’est-ce qu’un Design Pattern ?</h4>
            <p>Un design pattern est une solution générale et réutilisable à un problème récurrent dans un contexte spécifique. En programmation orientée objet, les design patterns permettent de structurer le code pour qu'il soit plus facile à comprendre, à maintenir et à faire évoluer.</p>
        
            <h4>Design Patterns Utiles pour la Gestion des Niveaux :</h4>
            <ul>
                <li><strong>Singleton :</strong> Utilisé pour s'assurer qu'une classe n'a qu'une seule instance à tout moment, ce qui est utile pour la gestion des niveaux du jeu.</li>
                <li><strong>Factory :</strong> Utilisé pour créer des objets sans exposer la logique de création. Il est idéal pour créer différents types de niveaux (ex. : niveau facile, moyen, difficile) sans modifier le code existant.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Pattern Singleton pour la Gestion du Niveau Actuel (30 min)</h3>
        
            <h4>Principe du Singleton :</h4>
            <p>Le Singleton est un design pattern qui garantit qu’une classe n’a qu’une seule instance dans l’application. Pour un jeu vidéo, cela permet de s’assurer qu’il n’y a qu’un seul niveau actif à un moment donné.</p>
        
            <h4>Application dans le Jeu Vidéo :</h4>
            <p>Nous allons utiliser le Singleton pour gérer le niveau actuel du jeu. En utilisant ce pattern, nous pouvons facilement accéder au niveau en cours sans créer d’instances supplémentaires par erreur.</p>
        
            <h4>Implémentation du Singleton en Python :</h4>
            <p>Voici un exemple d'implémentation du pattern Singleton pour un objet <code>Niveau</code> :</p>
        
            <pre><code>class Niveau:
            _instance = None  # Variable de classe pour stocker l'unique instance
        
            def __new__(cls):
                if cls._instance is None:
                    cls._instance = super(Niveau, cls).__new__(cls)
                    cls._instance.nom = None
                    cls._instance.difficulte = None
                return cls._instance
        
            def configurer_niveau(self, nom, difficulte):
                self.nom = nom
                self.difficulte = difficulte
        
            def afficher_details(self):
                print(f"Niveau: {self.nom}, Difficulté: {self.difficulte}")
            
        # Utilisation du Singleton
        niveau_actuel = Niveau()
        niveau_actuel.configurer_niveau("Forêt Mystique", "Facile")
        niveau_actuel.afficher_details()
        
        # Tentative de création d'un autre niveau
        autre_niveau = Niveau()
        autre_niveau.afficher_details()
            </code></pre>
        
            <h4>Explication du Code :</h4>
            <ul>
                <li><code>_instance</code> est une variable de classe utilisée pour stocker l’unique instance de la classe.</li>
                <li>La méthode <code>__new__</code> vérifie si une instance existe déjà ; si ce n’est pas le cas, elle en crée une, sinon elle retourne l'instance existante.</li>
                <li><code>configurer_niveau</code> permet de définir le nom et la difficulté du niveau actuel.</li>
            </ul>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Ajoutez une méthode pour changer la difficulté du niveau sans créer de nouvelle instance.</li>
                <li><strong>Étape 2 :</strong> Utilisez le Singleton pour garantir qu'un seul niveau est actif à la fois dans votre jeu.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Pattern Factory pour la Création Dynamique de Niveaux (30 min)</h3>
        
            <h4>Principe du Factory :</h4>
            <p>Le pattern Factory fournit une méthode pour créer des objets de manière dynamique, sans exposer la logique de création. Ce pattern est utile lorsque le jeu doit créer des niveaux de difficulté variable (par exemple, facile, moyen, difficile) en fonction des choix du joueur.</p>
        
            <h4>Application dans le Jeu Vidéo :</h4>
            <p>Nous allons implémenter une <strong>classe Factory</strong> qui génère des niveaux en fonction de leur difficulté. Cela permettra de créer de nouveaux types de niveaux sans modifier le code existant, ce qui rend le jeu plus flexible.</p>
        
            <h4>Implémentation du Pattern Factory en Python :</h4>
            <p>Voici un exemple d'implémentation du pattern Factory pour créer des niveaux de difficulté différente :</p>
        
            <pre><code>class Niveau:
            def __init__(self, nom, difficulte):
                self.nom = nom
                self.difficulte = difficulte
        
            def afficher_details(self):
                print(f"Niveau: {self.nom}, Difficulté: {self.difficulte}")
        
        class NiveauFactory:
            @staticmethod
            def creer_niveau(difficulte):
                if difficulte == "facile":
                    return Niveau("Plaine Verte", "Facile")
                elif difficulte == "moyen":
                    return Niveau("Désert Brûlant", "Moyen")
                elif difficulte == "difficile":
                    return Niveau("Montagne des Ombres", "Difficile")
                else:
                    print("Difficulté inconnue. Création d'un niveau par défaut.")
                    return Niveau("Plaine Inconnue", "Facile")
        
        # Utilisation de la Factory
        niveau_facile = NiveauFactory.creer_niveau("facile")
        niveau_facile.afficher_details()
        
        niveau_difficile = NiveauFactory.creer_niveau("difficile")
        niveau_difficile.afficher_details()
            </code></pre>
        
            <h4>Explication du Code :</h4>
            <ul>
                <li>La classe <code>Niveau</code> représente un niveau du jeu avec un nom et une difficulté.</li>
                <li>La <code>NiveauFactory</code> est une classe Factory qui crée des objets <code>Niveau</code> en fonction de la difficulté demandée.</li>
                <li>La méthode <code>creer_niveau</code> génère un niveau spécifique pour chaque difficulté, rendant la création d'objets flexible et modulaire.</li>
            </ul>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Ajoutez un niveau de difficulté supplémentaire (par exemple, "expert") dans la Factory.</li>
                <li><strong>Étape 2 :</strong> Intégrez la Factory dans le jeu pour permettre au joueur de choisir la difficulté de chaque niveau.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Application Pratique : Gestion Optimisée des Niveaux dans un Jeu (30 min)</h3>
        
            <h4>Conception du Projet :</h4>
            <p>Combinez le Singleton et le Factory pour gérer les niveaux dans un jeu vidéo. Utilisez le Singleton pour contrôler le niveau actif et le Factory pour créer des niveaux en fonction de la difficulté choisie par le joueur.</p>
        
            <h4>Exercice Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Créez une classe <code>GestionNiveaux</code> qui utilise le Singleton pour garder le niveau actif.</li>
                <li><strong>Étape 2 :</strong> Utilisez la Factory pour créer de nouveaux niveaux et les assigner au niveau actif à chaque nouvelle étape.</li>
                <li><strong>Étape 3 :</strong> Testez le système en créant plusieurs niveaux et en changeant dynamiquement la difficulté.</li>
            </ul>
        
            <h4>Code Exemple pour la Gestion des Niveaux :</h4>
            <pre><code>class GestionNiveaux:
            _instance = None
        
            def __new__(cls):
                if cls._instance is None:
                    cls._instance = super(GestionNiveaux, cls).__new__(cls)
                    cls._instance.niveau_actuel = None
                return cls._instance
        
            def definir_niveau(self, niveau):
                self.niveau_actuel = niveau
                print("Niveau défini :")
                self.niveau_actuel.afficher_details()
        
        # Création de niveaux via la Factory et gestion par Singleton
        gestionnaire = GestionNiveaux()
        niveau_facile = NiveauFactory.creer_niveau("facile")
        gestionnaire.definir_niveau(niveau_facile)
        
        niveau_difficile = NiveauFactory.creer_niveau("difficile")
        gestionnaire.definir_niveau(niveau_difficile)
            </code></pre>
        
            <h4>Conclusion :</h4>
            <p>À la fin de cette séance, les élèves auront appris à utiliser les patterns Singleton et Factory pour gérer la création et la gestion des niveaux dans un jeu vidéo. Ils auront appliqué ces design patterns pour structurer et optimiser le code, le rendant plus facile à maintenir et à faire évoluer.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion (10 min)</h3>
            <p>Les élèves sont encouragés à discuter de la manière dont les design patterns peuvent améliorer la qualité du code dans des projets de grande envergure, comme les jeux vidéo. Nous discuterons également de l'intérêt d'utiliser ces patterns dans d'autres contextes, tels que la gestion des personnages ou des objets dans un jeu.</p>
        </section>

        <section id="session43" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 43 : Théorie - Encapsulation, Accès aux Attributs, Getters et Setters</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront les concepts d'encapsulation en programmation orientée objet (POO). Ils comprendront pourquoi il est important de contrôler l'accès aux attributs d'une classe et comment utiliser des méthodes comme les <strong>getters</strong> et <strong>setters</strong> pour manipuler ces attributs de manière sécurisée.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Introduction à l’Encapsulation</h3>
            <h4>Qu’est-ce que l’encapsulation ?</h4>
            <p>L’encapsulation est un principe fondamental de la programmation orientée objet qui consiste à <strong>restreindre l'accès aux attributs internes d'une classe</strong> et à fournir des méthodes spécifiques (getters et setters) pour interagir avec ces attributs.</p>
            <p>Ce principe permet de :</p>
            <ul>
                <li><strong>Protéger les données sensibles :</strong> empêcher les modifications non contrôlées des attributs.</li>
                <li><strong>Contrôler la logique métier :</strong> appliquer des règles lors de l'accès ou de la modification des données.</li>
                <li><strong>Rendre le code évolutif :</strong> modifier la structure interne d'une classe sans impacter le code extérieur.</li>
            </ul>
        
            <h4>Exemple sans encapsulation :</h4>
            <p>Voici un exemple simple où les attributs d’une classe sont accessibles directement :</p>
            <pre><code>class Personnage:
            def __init__(self, nom, points_vie):
                self.nom = nom
                self.points_vie = points_vie
        
        # Création d'un personnage
        perso = Personnage("Héros", 100)
        print(perso.points_vie)  # Accès direct à l'attribut
        perso.points_vie = 200   # Modification directe
            </code></pre>
        
            <p><strong>Problème :</strong> Les attributs peuvent être modifiés directement, ce qui peut provoquer des incohérences ou des erreurs.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Utilisation des Getters et Setters</h3>
        
            <h4>Pourquoi utiliser des getters et setters ?</h4>
            <p>Les getters et setters permettent de :</p>
            <ul>
                <li>Valider les valeurs avant de les affecter à un attribut.</li>
                <li>Protéger l'accès ou la modification des attributs sensibles.</li>
                <li>Fournir un contrôle total sur la manière dont les attributs sont manipulés.</li>
            </ul>
        
            <h4>Exemple avec getters et setters :</h4>
            <pre><code>class Personnage:
            def __init__(self, nom, points_vie):
                self.__nom = nom                # Attribut privé
                self.__points_vie = points_vie  # Attribut privé
        
            # Getter pour 'nom'
            def get_nom(self):
                return self.__nom
        
            # Setter pour 'nom'
            def set_nom(self, nouveau_nom):
                if isinstance(nouveau_nom, str):
                    self.__nom = nouveau_nom
                else:
                    print("Erreur : Le nom doit être une chaîne de caractères.")
        
            # Getter pour 'points_vie'
            def get_points_vie(self):
                return self.__points_vie
        
            # Setter pour 'points_vie'
            def set_points_vie(self, nouveau_points_vie):
                if nouveau_points_vie >= 0:
                    self.__points_vie = nouveau_points_vie
                else:
                    print("Erreur : Les points de vie doivent être positifs.")
        
        # Utilisation de la classe
        perso = Personnage("Héros", 100)
        print(perso.get_nom())  # Accéder au nom
        perso.set_nom("Super Héros")  # Modifier le nom
        perso.set_points_vie(-50)     # Essayer d'affecter une valeur invalide
            </code></pre>
        
            <p><strong>Note :</strong> Les attributs privés sont indiqués par un double underscore (<code>__</code>) pour signaler qu’ils ne doivent pas être accédés directement.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Utilisation des @property et @setter en Python</h3>
        
            <h4>Simplification des getters et setters avec les décorateurs :</h4>
            <p>Python fournit les décorateurs <code>@property</code> et <code>@nom_attribut.setter</code> pour rendre les getters et setters plus intuitifs.</p>
        
            <h4>Exemple avec <code>@property</code> :</h4>
            <pre><code>class Personnage:
            def __init__(self, nom, points_vie):
                self.__nom = nom
                self.__points_vie = points_vie
        
            # Getter pour 'nom'
            @property
            def nom(self):
                return self.__nom
        
            # Setter pour 'nom'
            @nom.setter
            def nom(self, nouveau_nom):
                if isinstance(nouveau_nom, str):
                    self.__nom = nouveau_nom
                else:
                    print("Erreur : Le nom doit être une chaîne de caractères.")
        
            # Getter pour 'points_vie'
            @property
            def points_vie(self):
                return self.__points_vie
        
            # Setter pour 'points_vie'
            @points_vie.setter
            def points_vie(self, nouveau_points_vie):
                if nouveau_points_vie >= 0:
                    self.__points_vie = nouveau_points_vie
                else:
                    print("Erreur : Les points de vie doivent être positifs.")
        
        # Utilisation de la classe
        perso = Personnage("Héros", 100)
        print(perso.nom)            # Accéder au nom
        perso.nom = "Super Héros"   # Modifier le nom
        print(perso.points_vie)     # Accéder aux points de vie
        perso.points_vie = -50      # Essayer d'affecter une valeur invalide
            </code></pre>
        
            <p><strong>Avantages :</strong> Avec <code>@property</code>, on peut accéder aux attributs comme s'ils étaient publics, tout en gardant un contrôle strict sur leur accès et modification.</p>
        
            <h2>Qu’est-ce que <code>@property</code> ?</h2>
            <p>
                <code>@property</code> est un décorateur Python qui transforme une méthode en une propriété. Cela permet d’accéder à une méthode comme s’il s’agissait d’un attribut.
            </p>

            <h3>Avantages de <code>@property</code> :</h3>
            <ul>
                <li><strong>Encapsulation :</strong> Vous pouvez cacher la logique interne tout en permettant un accès simple.</li>
                <li><strong>Validation :</strong> Vous pouvez contrôler la valeur retournée ou effectuer des calculs avant de renvoyer un résultat.</li>
                <li><strong>Flexibilité :</strong> Vous pouvez modifier la logique interne sans affecter le code utilisateur.</li>
            </ul>

            <h3>Exemple simple avec <code>@property</code> :</h3>
            <pre><code class="python">
        class Cercle:
            def __init__(self, rayon):
                self.__rayon = rayon  # Attribut privé

            @property
            def rayon(self):
                """Getter pour accéder au rayon"""
                return self.__rayon

            @property
            def surface(self):
                """Calculer la surface du cercle"""
                return 3.14159 * (self.__rayon ** 2)

        # Utilisation
        c = Cercle(5)
        print(c.rayon)    # 5 (accès comme un attribut)
        print(c.surface)  # 78.53975 (surface calculée automatiquement)
            </code></pre>

            <p>Dans cet exemple :</p>
            <ul>
                <li><code>rayon</code> est un getter qui permet d’accéder à la valeur de l’attribut privé <code>__rayon</code>.</li>
                <li><code>surface</code> est une propriété calculée dynamiquement.</li>
            </ul>

            <h2>Qu’est-ce que <code>@setter</code> ?</h2>
            <p>
                <code>@setter</code> est un décorateur qui permet de définir une méthode pour modifier la valeur d’un attribut en ajoutant une logique supplémentaire, comme une validation.
            </p>

            <h3>Avantages de <code>@setter</code> :</h3>
            <ul>
                <li><strong>Validation des données :</strong> Vous pouvez contrôler les valeurs avant de les affecter à l’attribut.</li>
                <li><strong>Encapsulation :</strong> Vous pouvez restreindre l’accès direct aux attributs privés.</li>
                <li><strong>Sécurité :</strong> Vous pouvez éviter des affectations accidentelles ou incohérentes.</li>
            </ul>

            <h3>Exemple avec <code>@setter</code> :</h3>
            <pre><code class="python">
        class Cercle:
            def __init__(self, rayon):
                self.__rayon = rayon  # Attribut privé

            @property
            def rayon(self):
                """Getter pour accéder au rayon"""
                return self.__rayon

            @rayon.setter
            def rayon(self, nouveau_rayon):
                """Setter pour modifier le rayon avec validation"""
                if nouveau_rayon > 0:
                    self.__rayon = nouveau_rayon
                else:
                    print("Erreur : Le rayon doit être positif.")

        # Utilisation
        c = Cercle(5)
        print(c.rayon)    # 5 (accès au getter)

        c.rayon = 10      # Setter : modifie le rayon
        print(c.rayon)    # 10

        c.rayon = -5      # Setter : valeur invalide
        # Erreur : Le rayon doit être positif.
            </code></pre>

            <p>Dans cet exemple :</p>
            <ul>
                <li>Le getter <code>rayon</code> permet d’accéder à l’attribut privé <code>__rayon</code>.</li>
                <li>Le setter <code>rayon</code> valide la nouvelle valeur avant de la modifier. Si la valeur est négative, un message d’erreur est affiché.</li>
            </ul>

            <h2>Fonctionnement Interne de <code>@property</code> et <code>@setter</code> :</h2>
            <p>
                Les décorateurs <code>@property</code> et <code>@setter</code> créent des propriétés Python qui encapsulent des méthodes et les associent à un attribut.
            </p>

            <h3>Approche sans décorateurs :</h3>
            <p>Voici comment cela fonctionne en arrière-plan :</p>
            <pre><code class="python">
        class Cercle:
            def __init__(self, rayon):
                self.__rayon = rayon

            def get_rayon(self):
                return self.__rayon

            def set_rayon(self, nouveau_rayon):
                if nouveau_rayon > 0:
                    self.__rayon = nouveau_rayon
                else:
                    print("Erreur : Le rayon doit être positif.")

            rayon = property(get_rayon, set_rayon)

        # Utilisation
        c = Cercle(5)
        print(c.rayon)    # Utilise get_rayon()
        c.rayon = 10      # Utilise set_rayon()
            </code></pre>

            <p>Le décorateur <code>@property</code> est simplement une syntaxe plus lisible et moderne pour la méthode <code>property</code>.</p>

            <h3>Combinaison des Deux : <code>@property</code> et <code>@setter</code></h3>
            <p>Voici un exemple complet combinant les deux décorateurs pour une gestion élégante d’un attribut privé :</p>
            <pre><code class="python">
        class Rectangle:
            def __init__(self, largeur, hauteur):
                self.__largeur = largeur
                self.__hauteur = hauteur

            @property
            def largeur(self):
                """Getter pour accéder à la largeur"""
                return self.__largeur

            @largeur.setter
            def largeur(self, nouvelle_largeur):
                """Setter pour modifier la largeur avec validation"""
                if nouvelle_largeur > 0:
                    self.__largeur = nouvelle_largeur
                else:
                    print("Erreur : La largeur doit être positive.")

            @property
            def hauteur(self):
                """Getter pour accéder à la hauteur"""
                return self.__hauteur

            @hauteur.setter
            def hauteur(self, nouvelle_hauteur):
                """Setter pour modifier la hauteur avec validation"""
                if nouvelle_hauteur > 0:
                    self.__hauteur = nouvelle_hauteur
                else:
                    print("Erreur : La hauteur doit être positive.")

            @property
            def surface(self):
                """Calculer la surface du rectangle"""
                return self.__largeur * self.__hauteur

        # Utilisation
        r = Rectangle(5, 10)
        print(r.largeur, r.hauteur)  # 5, 10
        print(r.surface)             # 50

        r.largeur = -3               # Erreur : La largeur doit être positive.
        r.hauteur = 15
        print(r.surface)             # 75
            </code></pre>

            <p>Dans cet exemple :</p>
            <ul>
                <li>Les attributs <code>largeur</code> et <code>hauteur</code> sont protégés par des getters et setters.</li>
                <li>La propriété <code>surface</code> est calculée dynamiquement à partir des deux attributs.</li>
            </ul>

            <h2>Quand Utiliser <code>@property</code> et <code>@setter</code> ?</h2>
            <ul>
                <li><strong>Validation des Données :</strong> Si un attribut doit respecter certaines règles (par ex. : un rayon ne peut pas être négatif), utilisez un setter.</li>
                <li><strong>Accès Contrôlé :</strong> Si vous voulez exposer un attribut de manière sécurisée, utilisez un getter.</li>
                <li><strong>Calcul Dynamique :</strong> Si un attribut dépend d’autres valeurs, utilisez une propriété pour calculer sa valeur dynamiquement.</li>
                <li><strong>Modification Facile :</strong> Vous pouvez changer la logique interne sans affecter le code existant, car les utilisateurs accèdent toujours à l’attribut via les getters/setters.</li>
            </ul>
            
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Exercice Pratique (40 min)</h3>
        
            <p>Les élèves devront créer une classe <code>Banque</code> pour gérer des comptes bancaires avec les contraintes suivantes :</p>
            <ul>
                <li>Les attributs incluent : <code>titulaire</code> (nom du propriétaire), <code>solde</code> (montant sur le compte).</li>
                <li>Le solde ne peut jamais être négatif.</li>
                <li>Les méthodes incluent : <code>déposer</code> (ajouter de l’argent) et <code>retirer</code> (retirer de l’argent si le solde est suffisant).</li>
                <li>Utilisez des getters et setters pour protéger les attributs.</li>
            </ul>
        
            <h4>Exemple attendu :</h4>
            <pre><code>class Banque:
            def __init__(self, titulaire, solde):
                self.__titulaire = titulaire
                self.__solde = solde
        
            # Getter et Setter pour 'titulaire'
            @property
            def titulaire(self):
                return self.__titulaire
        
            @titulaire.setter
            def titulaire(self, nouveau_titulaire):
                if isinstance(nouveau_titulaire, str):
                    self.__titulaire = nouveau_titulaire
                else:
                    print("Erreur : Le titulaire doit être une chaîne de caractères.")
        
            # Getter et Setter pour 'solde'
            @property
            def solde(self):
                return self.__solde
        
            @solde.setter
            def solde(self, nouveau_solde):
                if nouveau_solde >= 0:
                    self.__solde = nouveau_solde
                else:
                    print("Erreur : Le solde ne peut pas être négatif.")
        
            # Méthodes pour déposer et retirer de l'argent
            def deposer(self, montant):
                if montant > 0:
                    self.solde += montant
                else:
                    print("Erreur : Le montant doit être positif.")
        
            def retirer(self, montant):
                if 0 < montant <= self.solde:
                    self.solde -= montant
                else:
                    print("Erreur : Solde insuffisant ou montant invalide.")
        
        # Exemple d'utilisation
        compte = Banque("Alice", 500)
        print(compte.solde)
        compte.deposer(200)
        compte.retirer(800)
        compte.retirer(100)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">5. Conclusion et Discussion (10 min)</h3>
            <ul>
                <li>Les getters et setters permettent de protéger les données sensibles d'une classe.</li>
                <li>Avec <code>@property</code>, Python offre une manière élégante de contrôler l'accès aux attributs tout en gardant une syntaxe simple pour les utilisateurs de la classe.</li>
                <li>Discussion : Quels autres scénarios pourraient bénéficier de l’encapsulation ?</li>
            </ul>
        </section>

        <section id="session44" class="content-section">
            <h2>Séance 44 : Pratique - Gestion d’attributs privés dans une application</h2>
        
            <h3>Objectif Global :</h3>
            <p>Les élèves apprendront à gérer les attributs privés dans une application en utilisant des méthodes comme les getters, setters et <code>@property</code>. Cette séance se concentre sur l’application de ces concepts dans un projet pratique : une application de gestion des employés d’une entreprise.</p>
        
            <h3>Contexte du Projet :</h3>
            <p>
                L’objectif est de développer une application de gestion des employés pour une entreprise. Chaque employé a des informations sensibles (nom, salaire, rôle) qui doivent être protégées. Les élèves devront :
            </p>
            <ul>
                <li>Utiliser des attributs privés pour sécuriser les données.</li>
                <li>Implémenter des getters et setters pour contrôler l’accès et la modification des données.</li>
                <li>Appliquer <code>@property</code> pour simplifier l’accès aux attributs.</li>
            </ul>
        
            <h3>Étape 1 : Création de la Classe Employé (30 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Créez une classe <code>Employe</code> avec les attributs suivants :
            </p>
            <ul>
                <li><code>nom</code> : Nom de l’employé (chaîne de caractères).</li>
                <li><code>salaire</code> : Salaire de l’employé (nombre positif).</li>
                <li><code>role</code> : Rôle de l’employé (par exemple, "Développeur", "Manager").</li>
            </ul>
            <p>Les attributs doivent être <strong>privés</strong> et accessibles uniquement via des getters et setters.</p>
        
            <h4>Implémentation Initiale :</h4>
            <pre><code class="python">
        class Employe:
            def __init__(self, nom, salaire, role):
                self.__nom = nom          # Attribut privé
                self.__salaire = salaire  # Attribut privé
                self.__role = role        # Attribut privé
        
            # Getter pour le nom
            @property
            def nom(self):
                return self.__nom
        
            # Setter pour le nom
            @nom.setter
            def nom(self, nouveau_nom):
                if isinstance(nouveau_nom, str):
                    self.__nom = nouveau_nom
                else:
                    print("Erreur : Le nom doit être une chaîne de caractères.")
        
            # Getter pour le salaire
            @property
            def salaire(self):
                return self.__salaire
        
            # Setter pour le salaire
            @salaire.setter
            def salaire(self, nouveau_salaire):
                if nouveau_salaire > 0:
                    self.__salaire = nouveau_salaire
                else:
                    print("Erreur : Le salaire doit être positif.")
        
            # Getter pour le rôle
            @property
            def role(self):
                return self.__role
        
            # Setter pour le rôle
            @role.setter
            def role(self, nouveau_role):
                if isinstance(nouveau_role, str):
                    self.__role = nouveau_role
                else:
                    print("Erreur : Le rôle doit être une chaîne de caractères.")
            </code></pre>
        
            <h4>Test Initial :</h4>
            <pre><code class="python">
        # Création d'un employé
        employe1 = Employe("Alice", 50000, "Développeur")
        
        # Accès et modification des attributs
        print(employe1.nom)  # Alice
        employe1.nom = "Alice Dupont"
        print(employe1.nom)  # Alice Dupont
        
        employe1.salaire = -1000  # Erreur : Le salaire doit être positif.
        print(employe1.salaire)   # 50000 (valeur inchangée)
            </code></pre>
        
            <h3>Étape 2 : Ajout de Méthodes pour la Gestion des Employés (30 min)</h3>
        
            <h4>Exercice :</h4>
            <p>Ajoutez des méthodes pour gérer les employés :</p>
            <ul>
                <li><code>augmentation_salaire(pourcentage)</code> : Augmente le salaire de l’employé d’un pourcentage donné.</li>
                <li><code>afficher_informations()</code> : Affiche les informations de l’employé.</li>
            </ul>
        
            <h4>Implémentation :</h4>
            <pre><code class="python">
        class Employe:
            # Initialisation et getters/setters comme ci-dessus
        
            # Méthode pour augmenter le salaire
            def augmentation_salaire(self, pourcentage):
                if pourcentage > 0:
                    augmentation = self.__salaire * (pourcentage / 100)
                    self.__salaire += augmentation
                else:
                    print("Erreur : Le pourcentage doit être positif.")
        
            # Méthode pour afficher les informations
            def afficher_informations(self):
                print(f"Nom : {self.nom}")
                print(f"Salaire : {self.salaire}")
                print(f"Rôle : {self.role}")
            </code></pre>
        
            <h4>Test :</h4>
            <pre><code class="python">
        employe1 = Employe("Bob", 60000, "Manager")
        employe1.afficher_informations()
        
        employe1.augmentation_salaire(10)
        employe1.afficher_informations()
            </code></pre>
        
            <h3>Étape 3 : Application Pratique (40 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Créez une classe <code>GestionEmployes</code> pour gérer une liste d’employés. Cette classe doit inclure :
            </p>
            <ul>
                <li><code>ajouter_employe(employe)</code> : Ajoute un employé à la liste.</li>
                <li><code>supprimer_employe(nom)</code> : Supprime un employé par son nom.</li>
                <li><code>afficher_tous_les_employes()</code> : Affiche les informations de tous les employés.</li>
            </ul>
        
            <h4>Implémentation :</h4>
            <pre><code class="python">
        class GestionEmployes:
            def __init__(self):
                self.__employes = []  # Liste privée d'employés
        
            def ajouter_employe(self, employe):
                if isinstance(employe, Employe):
                    self.__employes.append(employe)
                else:
                    print("Erreur : L'objet doit être une instance de la classe Employe.")
        
            def supprimer_employe(self, nom):
                for employe in self.__employes:
                    if employe.nom == nom:
                        self.__employes.remove(employe)
                        print(f"L'employé {nom} a été supprimé.")
                        return
                print(f"Erreur : Aucun employé trouvé avec le nom {nom}.")
        
            def afficher_tous_les_employes(self):
                for employe in self.__employes:
                    employe.afficher_informations()
                    print("-" * 20)
            </code></pre>
        
            <h4>Test :</h4>
            <pre><code class="python">
        # Gestion des employés
        gestion = GestionEmployes()
        
        # Création d'employés
        employe1 = Employe("Alice", 50000, "Développeur")
        employe2 = Employe("Bob", 60000, "Manager")
        
        # Ajout des employés
        gestion.ajouter_employe(employe1)
        gestion.ajouter_employe(employe2)
        
        # Affichage de tous les employés
        gestion.afficher_tous_les_employes()
        
        # Suppression d'un employé
        gestion.supprimer_employe("Alice")
        gestion.afficher_tous_les_employes()
            </code></pre>
        
            <h3>Conclusion :</h3>
            <p>
                À la fin de cette séance, les élèves auront appris à :
            </p>
            <ul>
                <li>Utiliser des attributs privés pour protéger les données sensibles.</li>
                <li>Appliquer des getters, setters et <code>@property</code> pour contrôler l’accès et la modification des attributs.</li>
                <li>Mettre en œuvre une logique métier pour gérer des données complexes dans une application réelle.</li>
            </ul>
            <p>Cette séance montre comment appliquer la gestion des attributs privés dans un contexte professionnel, en mettant l’accent sur les bonnes pratiques de programmation.</p>
        </section>

        <section id="session45" class="content-section">
            <h2>Séance 45 : Gestion de la mémoire en POO</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Comprendre comment Python gère la mémoire pour les objets en Programmation Orientée Objet (POO). Les élèves apprendront les concepts de base liés à la gestion de la mémoire (création et destruction d’objets, référence, collecte des objets non utilisés), et comment ces mécanismes influencent leurs programmes.
            </p>
        
            <h3>1. Concepts Clés de la Gestion de la Mémoire en Python</h3>
        
            <h4>1.1. Allocation de la Mémoire</h4>
            <p>
                Lorsqu’un objet est créé dans Python, de la mémoire est allouée dynamiquement. Les objets (par exemple, des instances de classe) sont stockés dans le <strong>tas mémoire</strong> (heap).
            </p>
            <ul>
                <li><strong>Variables :</strong> Elles agissent comme des références à ces objets.</li>
                <li><strong>Références multiples :</strong> Plusieurs variables peuvent référencer le même objet.</li>
            </ul>
        
            <h4>1.2. Collecte des Objets Non Utilisés</h4>
            <p>
                Python utilise un <strong>ramasse-miettes (garbage collector)</strong> pour libérer automatiquement la mémoire occupée par les objets non utilisés. Un objet est détruit lorsque :
            </p>
            <ul>
                <li>Il n’est plus référencé par aucune variable.</li>
                <li>Le compteur de références de l’objet tombe à 0.</li>
            </ul>
            <p>Le module intégré <code>gc</code> contrôle le comportement du garbage collector.</p>
        
            <h3>2. Les Compteurs de Références</h3>
        
            <h4>2.1. Comprendre le Compteur de Références</h4>
            <p>
                Chaque objet en Python possède un compteur de références, qui indique combien de variables ou d’autres objets référencent cet objet. Lorsque le compteur de références tombe à 0, l’objet est détruit.
            </p>
        
            <h4>2.2. Exemple :</h4>
            <pre><code class="python">
        import sys
        
        class Exemple:
            pass
        
        # Création d'un objet
        obj = Exemple()
        print(sys.getrefcount(obj))  # 2 : 'obj' + l'argument de la fonction
        
        # Ajout d'une référence
        obj2 = obj
        print(sys.getrefcount(obj))  # 3 : 'obj', 'obj2', et l'argument de la fonction
        
        # Suppression d'une référence
        del obj2
        print(sys.getrefcount(obj))  # 2 : 'obj' et l'argument de la fonction
            </code></pre>
        
            <p>
                Utilisez <code>sys.getrefcount()</code> pour afficher le nombre de références d’un objet. Cela peut aider à comprendre pourquoi un objet n'est pas détruit immédiatement.
            </p>
        
            <h3>3. Cycle de Vie d’un Objet</h3>
        
            <h4>3.1. Création et Initialisation</h4>
            <p>
                La méthode <code>__init__()</code> est appelée après la création d’un objet pour l’initialiser.
            </p>
        
            <h4>3.2. Destruction</h4>
            <p>
                La méthode <code>__del__()</code> est appelée avant que l’objet soit détruit par le garbage collector. Elle est utilisée pour libérer des ressources spécifiques (par exemple, des fichiers ouverts).
            </p>
        
            <h4>Exemple :</h4>
            <pre><code class="python">
        class Exemple:
            def __init__(self, nom):
                self.nom = nom
                print(f"Objet {self.nom} créé.")
        
            def __del__(self):
                print(f"Objet {self.nom} détruit.")
        
        # Création et suppression d'un objet
        obj = Exemple("A")
        del obj  # Détruit explicitement l'objet
            </code></pre>
        
            <h3>4. Gestion Avancée avec le Module <code>gc</code></h3>
        
            <h4>4.1. Forcer la Collecte des Objets Non Utilisés</h4>
            <p>
                Le module <code>gc</code> permet de forcer le garbage collector à exécuter un nettoyage manuel.
            </p>
        
            <h4>Exemple :</h4>
            <pre><code class="python">
        import gc
        
        class Exemple:
            def __del__(self):
                print("Objet détruit.")
        
        # Création d'objets
        obj1 = Exemple()
        obj2 = Exemple()
        
        # Supprimer les références
        del obj1
        del obj2
        
        # Forcer le ramasse-miettes
        gc.collect()
            </code></pre>
        
            <h4>4.2. Contrôle des Objets Collectés</h4>
            <p>
                Vous pouvez afficher les objets qui sont collectés par le garbage collector.
            </p>
            <pre><code class="python">
        gc.set_debug(gc.DEBUG_LEAK)
        gc.collect()
            </code></pre>
        
            <h3>5. Bonne Gestion de la Mémoire en POO</h3>
        
            <h4>5.1. Conseils Pratiques :</h4>
            <ul>
                <li>Évitez de créer des références circulaires (elles peuvent empêcher le garbage collector de libérer la mémoire).</li>
                <li>Libérez explicitement les ressources (comme les fichiers ou connexions réseau) dans <code>__del__()</code>.</li>
                <li>Utilisez des context managers (<code>with</code>) pour gérer les ressources de manière sûre.</li>
            </ul>
        
            <h4>5.2. Exemple avec un Context Manager :</h4>
            <pre><code class="python">
        class Fichier:
            def __init__(self, chemin):
                self.fichier = open(chemin, "w")
        
            def __enter__(self):
                return self.fichier
        
            def __exit__(self, exc_type, exc_value, traceback):
                self.fichier.close()
        
        # Utilisation du Context Manager
        with Fichier("exemple.txt") as fichier:
            fichier.write("Gestion de la mémoire avec POO")
            </code></pre>
        
            <h3>6. Application Pratique : Gestion de Ressources dans un Projet (40 min)</h3>
        
            <h4>Projet :</h4>
            <p>
                Implémentez une classe <code>SessionUtilisateur</code> qui gère des connexions utilisateurs. La classe doit inclure :
            </p>
            <ul>
                <li>Une méthode <code>connecter()</code> pour simuler une connexion utilisateur.</li>
                <li>Une méthode <code>deconnecter()</code> pour libérer la connexion.</li>
                <li>Un destructeur <code>__del__()</code> pour s’assurer que les connexions sont fermées automatiquement.</li>
            </ul>
        
            <h4>Exemple :</h4>
            <pre><code class="python">
        class SessionUtilisateur:
            def __init__(self, utilisateur):
                self.utilisateur = utilisateur
                self.connecter()
        
            def connecter(self):
                print(f"{self.utilisateur} connecté.")
        
            def deconnecter(self):
                print(f"{self.utilisateur} déconnecté.")
        
            def __del__(self):
                self.deconnecter()
        
        # Utilisation
        session = SessionUtilisateur("Alice")
        del session  # Libère la connexion automatiquement
            </code></pre>
        
            <h3>7. Conclusion :</h3>
            <p>
                À la fin de cette séance, les élèves comprendront :
            </p>
            <ul>
                <li>Comment Python gère la mémoire et les objets en POO.</li>
                <li>Comment utiliser efficacement les destructeurs pour libérer les ressources.</li>
                <li>Comment le garbage collector fonctionne et quand intervenir.</li>
            </ul>
            <p>
                La gestion de la mémoire est essentielle pour écrire des programmes performants et stables, en particulier dans des projets complexes ou avec des ressources limitées.
            </p>
        </section>

        <section id="session46" class="content-section">
            <h2>Séance 46 : Optimisation d’une application POO (jeu vidéo)</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Les élèves apprendront à identifier et appliquer des techniques d’optimisation pour une application en Programmation Orientée Objet (POO), en se concentrant sur un projet de jeu vidéo. 
                Ils analyseront le code existant pour détecter les points d’amélioration, réduire la redondance, et améliorer les performances tout en appliquant des concepts comme la refactorisation, l’utilisation de design patterns, et la gestion efficace des objets.
            </p>
        
            <h3>Contexte du Projet :</h3>
            <p>
                Le jeu vidéo est un projet en POO où un personnage se déplace dans un monde composé de différents niveaux. Le code initial comporte des fonctionnalités de base, mais il est inefficace ou redondant dans certaines parties. Les élèves devront optimiser le code en appliquant des bonnes pratiques et des concepts avancés.
            </p>
        
            <h4>Exemple de Fonctionnalités à Optimiser :</h4>
            <ul>
                <li>Gestion des niveaux.</li>
                <li>Création et destruction des objets (ennemis, objets ramassables, etc.).</li>
                <li>Système d’événements (interaction entre le joueur et les objets).</li>
            </ul>
        
            <h3>Étape 1 : Analyse du Code Existant (30 min)</h3>
        
            <h4>Code Initial :</h4>
            <pre><code class="python">
        class Niveau:
            def __init__(self, nom):
                self.nom = nom
                self.ennemis = []
                self.objets = []
        
            def ajouter_ennemi(self, ennemi):
                self.ennemis.append(ennemi)
        
            def ajouter_objet(self, objet):
                self.objets.append(objet)
        
            def afficher_contenu(self):
                print(f"Niveau : {self.nom}")
                print("Ennemis :")
                for ennemi in self.ennemis:
                    print(f" - {ennemi.nom}")
                print("Objets :")
                for objet in self.objets:
                    print(f" - {objet.nom}")
        
        class Ennemi:
            def __init__(self, nom, points_de_vie):
                self.nom = nom
                self.points_de_vie = points_de_vie
        
        class Objet:
            def __init__(self, nom, effet):
                self.nom = nom
                self.effet = effet
        
        # Exemple d'utilisation
        niveau1 = Niveau("Forêt Enchantée")
        niveau1.ajouter_ennemi(Ennemi("Gobelin", 50))
        niveau1.ajouter_ennemi(Ennemi("Troll", 100))
        niveau1.ajouter_objet(Objet("Potion de Vie", "+20 PV"))
        niveau1.afficher_contenu()
            </code></pre>
        
            <h4>Problèmes Identifiés :</h4>
            <ul>
                <li>Le code est redondant : plusieurs méthodes (ajouter_ennemi, ajouter_objet) pourraient être généralisées.</li>
                <li>Le système de création d’ennemis et d’objets manque de flexibilité.</li>
                <li>Les niveaux n’utilisent pas de design patterns pour gérer leur contenu.</li>
            </ul>
        
            <h3>Étape 2 : Refactorisation et Optimisation (40 min)</h3>
        
            <h4>1. Utilisation d’un Design Pattern (Factory) :</h4>
            <p>
                Implémentez une Factory pour gérer la création des ennemis et des objets. Cela permet de centraliser la logique de création et de rendre le code plus flexible.
            </p>
        
            <pre><code class="python">
        class Factory:
            @staticmethod
            def creer_ennemi(type_ennemi):
                if type_ennemi == "Gobelin":
                    return Ennemi("Gobelin", 50)
                elif type_ennemi == "Troll":
                    return Ennemi("Troll", 100)
                else:
                    print("Type d'ennemi inconnu.")
        
            @staticmethod
            def creer_objet(type_objet):
                if type_objet == "Potion de Vie":
                    return Objet("Potion de Vie", "+20 PV")
                elif type_objet == "Potion de Mana":
                    return Objet("Potion de Mana", "+10 Mana")
                else:
                    print("Type d'objet inconnu.")
            </code></pre>
        
            <h4>2. Généralisation de la Gestion du Contenu :</h4>
            <p>
                Remplacez les méthodes spécifiques (ajouter_ennemi, ajouter_objet) par une méthode unique <code>ajouter_contenu</code> qui accepte différents types d’objets.
            </p>
        
            <pre><code class="python">
        class Niveau:
            def __init__(self, nom):
                self.nom = nom
                self.contenu = []
        
            def ajouter_contenu(self, contenu):
                self.contenu.append(contenu)
        
            def afficher_contenu(self):
                print(f"Niveau : {self.nom}")
                for item in self.contenu:
                    print(f" - {item.nom}")
            </code></pre>
        
            <h4>3. Optimisation des Affichages :</h4>
            <p>Utilisez la méthode <code>__str__</code> pour personnaliser l’affichage des ennemis et objets.</p>
        
            <pre><code class="python">
        class Ennemi:
            def __init__(self, nom, points_de_vie):
                self.nom = nom
                self.points_de_vie = points_de_vie
        
            def __str__(self):
                return f"{self.nom} (PV : {self.points_de_vie})"
        
        class Objet:
            def __init__(self, nom, effet):
                self.nom = nom
                self.effet = effet
        
            def __str__(self):
                return f"{self.nom} - Effet : {self.effet}"
            </code></pre>
        
            <h3>Étape 3 : Tests et Vérifications (30 min)</h3>
        
            <h4>Exemple de Code Optimisé :</h4>
            <pre><code class="python">
        # Création d'un niveau optimisé
        niveau1 = Niveau("Forêt Enchantée")
        
        # Ajout de contenu via la Factory
        niveau1.ajouter_contenu(Factory.creer_ennemi("Gobelin"))
        niveau1.ajouter_contenu(Factory.creer_ennemi("Troll"))
        niveau1.ajouter_contenu(Factory.creer_objet("Potion de Vie"))
        
        # Affichage
        niveau1.afficher_contenu()
            </code></pre>
        
            <h4>Questions à se Poser :</h4>
            <ul>
                <li>Le code est-il plus lisible et maintenable après refactorisation ?</li>
                <li>Les classes sont-elles plus modulaires et réutilisables ?</li>
                <li>Y a-t-il d’autres parties du code qui pourraient être optimisées ?</li>
            </ul>
        
            <h3>Étape 4 : Extension - Gestion des Événements (20 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Implémentez un système d’événements où les ennemis attaquent le joueur ou interagissent avec les objets.
            </p>
        
            <pre><code class="python">
        class Joueur:
            def __init__(self, nom, points_de_vie):
                self.nom = nom
                self.points_de_vie = points_de_vie
        
            def subir_degats(self, degats):
                self.points_de_vie -= degats
                print(f"{self.nom} subit {degats} dégâts. PV restants : {self.points_de_vie}")
        
        class Ennemi:
            # Ajout d'une méthode d'attaque
            def attaquer(self, joueur):
                degats = 10  # Exemple simple
                joueur.subir_degats(degats)
        
        # Exemple d'utilisation
        joueur = Joueur("Héros", 100)
        gobelin = Factory.creer_ennemi("Gobelin")
        gobelin.attaquer(joueur)
            </code></pre>
        
            <h3>Conclusion :</h3>
            <ul>
                <li>Les élèves auront appris à optimiser une application POO en utilisant des concepts comme les design patterns et la refactorisation.</li>
                <li>Ils auront appliqué des bonnes pratiques pour rendre le code plus maintenable et modulaire.</li>
                <li>Ils auront exploré des améliorations fonctionnelles comme la gestion des événements dans un jeu vidéo.</li>
            </ul>
        </section>

        <section id="session47" class="content-section">
            <h2>Séance 47 : Pratique - Réorganisation d’un projet pour améliorer l’efficacité et la gestion des ressources</h2>
        
            <h3>Objectif Global :</h3>
            <p>Dans cette séance, les élèves apprendront à réorganiser un projet Python existant pour améliorer son efficacité et sa gestion des ressources. Ils utiliseront des techniques telles que la modularité, le découpage en fonctions et classes, et l’optimisation de l’utilisation des ressources (mémoire et CPU).</p>
        
            <h3>Contexte :</h3>
            <p>
                Vous avez développé un jeu vidéo simple lors d’une séance précédente. Le projet fonctionne, mais il est difficile à lire, à maintenir et manque d’efficacité. L’objectif est de :
            </p>
            <ul>
                <li>Réorganiser le projet en suivant les principes de la programmation modulaire.</li>
                <li>Optimiser les parties coûteuses du code pour réduire l’utilisation des ressources.</li>
                <li>Améliorer la gestion des fichiers, des classes et des fonctions pour rendre le projet plus clair et évolutif.</li>
            </ul>
        
            <h3>Étape 1 : Analyse du Projet Existant (30 min)</h3>
            <p>
                Le projet est un jeu vidéo simple où un joueur doit naviguer dans un labyrinthe pour atteindre la sortie tout en évitant des ennemis. Actuellement, tout le code est contenu dans un seul fichier Python, avec peu de structure.
            </p>
            <h4>Code Existant :</h4>
            <pre><code class="python">
        # Jeu simple : navigation dans un labyrinthe
        import random
        
        # Paramètres du jeu
        grille = [[0, 1, 0, 0],
                  [0, 1, 0, 1],
                  [0, 0, 0, 1],
                  [1, 1, 0, 0]]
        
        position_joueur = [0, 0]  # Départ
        position_sortie = [3, 3]
        
        # Fonction pour afficher la grille
        def afficher_grille():
            for ligne in grille:
                print(" ".join(str(x) for x in ligne))
        
        # Déplacement du joueur
        def deplacer_joueur(direction):
            global position_joueur
            x, y = position_joueur
            if direction == "haut" and x > 0:
                position_joueur[0] -= 1
            elif direction == "bas" and x < len(grille) - 1:
                position_joueur[0] += 1
            elif direction == "gauche" and y > 0:
                position_joueur[1] -= 1
            elif direction == "droite" and y < len(grille[0]) - 1:
                position_joueur[1] += 1
        
        # Jeu principal
        while position_joueur != position_sortie:
            afficher_grille()
            direction = input("Déplacez-vous (haut, bas, gauche, droite) : ")
            deplacer_joueur(direction)
            print(f"Votre position : {position_joueur}")
        
        print("Félicitations ! Vous avez trouvé la sortie.")
            </code></pre>
        
            <p><strong>Problèmes identifiés :</strong></p>
            <ul>
                <li>Le code est peu structuré et manque de modularité.</li>
                <li>La gestion des ressources (comme les entrées utilisateur et l’affichage) pourrait être optimisée.</li>
                <li>Aucune séparation entre la logique métier (déplacements) et l’interface utilisateur (affichage).</li>
            </ul>
        
            <h3>Étape 2 : Réorganisation Modulaire (40 min)</h3>
        
            <h4>Plan de Réorganisation :</h4>
            <p>
                Réorganisez le projet en plusieurs fichiers pour séparer les responsabilités :
            </p>
            <ul>
                <li><code>labyrinthe.py</code> : Contient la logique du labyrinthe.</li>
                <li><code>joueur.py</code> : Contient la gestion des déplacements et des positions.</li>
                <li><code>main.py</code> : Contient la boucle principale du jeu et gère l’interaction utilisateur.</li>
            </ul>
        
            <h4>Exemple de Fichier <code>labyrinthe.py</code> :</h4>
            <pre><code class="python">
        class Labyrinthe:
            def __init__(self, grille, position_sortie):
                self.grille = grille
                self.position_sortie = position_sortie
        
            def afficher(self):
                for ligne in self.grille:
                    print(" ".join(str(x) for x in ligne))
        
            def est_sortie(self, position):
                return position == self.position_sortie
            </code></pre>
        
            <h4>Exemple de Fichier <code>joueur.py</code> :</h4>
            <pre><code class="python">
        class Joueur:
            def __init__(self, position_initiale):
                self.position = position_initiale
        
            def deplacer(self, direction, taille_grille):
                x, y = self.position
                if direction == "haut" and x > 0:
                    self.position[0] -= 1
                elif direction == "bas" and x < taille_grille[0] - 1:
                    self.position[0] += 1
                elif direction == "gauche" and y > 0:
                    self.position[1] -= 1
                elif direction == "droite" and y < taille_grille[1] - 1:
                    self.position[1] += 1
            </code></pre>
        
            <h4>Exemple de Fichier <code>main.py</code> :</h4>
            <pre><code class="python">
        from labyrinthe import Labyrinthe
        from joueur import Joueur
        
        # Initialisation
        grille = [[0, 1, 0, 0],
                  [0, 1, 0, 1],
                  [0, 0, 0, 1],
                  [1, 1, 0, 0]]
        labyrinthe = Labyrinthe(grille, [3, 3])
        joueur = Joueur([0, 0])
        
        # Boucle principale
        while not labyrinthe.est_sortie(joueur.position):
            labyrinthe.afficher()
            direction = input("Déplacez-vous (haut, bas, gauche, droite) : ")
            joueur.deplacer(direction, (len(grille), len(grille[0])))
            print(f"Votre position : {joueur.position}")
        
        print("Félicitations ! Vous avez trouvé la sortie.")
            </code></pre>
        
            <h3>Étape 3 : Optimisation et Ajout de Fonctionnalités (30 min)</h3>
        
            <h4>Exercice :</h4>
            <p>Ajoutez des fonctionnalités pour rendre le jeu plus interactif et performant :</p>
            <ul>
                <li>Ajoutez des ennemis dans le labyrinthe et une logique pour qu’ils se déplacent de manière aléatoire.</li>
                <li>Optimisez l’affichage en ne montrant que les cases visibles autour du joueur.</li>
                <li>Ajoutez un système de points basé sur le temps ou les déplacements pour motiver les joueurs.</li>
            </ul>
        
            <h4>Exemple de Gestion d’Ennemis :</h4>
            <pre><code class="python">
        class Ennemi:
            def __init__(self, position_initiale):
                self.position = position_initiale
        
            def deplacer(self, taille_grille):
                import random
                directions = ["haut", "bas", "gauche", "droite"]
                direction = random.choice(directions)
                x, y = self.position
                if direction == "haut" and x > 0:
                    self.position[0] -= 1
                elif direction == "bas" and x < taille_grille[0] - 1:
                    self.position[0] += 1
                elif direction == "gauche" and y > 0:
                    self.position[1] -= 1
                elif direction == "droite" and y < taille_grille[1] - 1:
                    self.position[1] += 1
            </code></pre>
        
            <h3>Conclusion :</h3>
            <p>
                À la fin de cette séance, les élèves auront appris à :
            </p>
            <ul>
                <li>Réorganiser un projet en suivant les principes de modularité et de séparation des responsabilités.</li>
                <li>Optimiser la gestion des ressources pour améliorer les performances du jeu.</li>
                <li>Ajouter des fonctionnalités pour rendre une application plus évolutive et interactive.</li>
            </ul>
            <p>Cette pratique est essentielle pour comprendre comment structurer et optimiser un projet à grande échelle.</p>
        </section>

        <section id="session48" class="content-section">
            <h2>Séance 48 : Analyse des Performances dans des Projets Orientés Objet</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Les élèves apprendront à analyser les performances des projets orientés objet en Python. Ils comprendront comment identifier les goulets d’étranglement, mesurer le temps d’exécution et optimiser les classes et méthodes d’un programme.
            </p>
        
            <h3>Introduction : Pourquoi Analyser les Performances ? (15 min)</h3>
            <ul>
                <li>Les performances sont essentielles pour garantir qu’une application reste rapide et réactive, même avec des données volumineuses.</li>
                <li>Dans des projets orientés objet, les classes, objets et méthodes peuvent introduire des coûts de calcul supplémentaires si elles ne sont pas bien conçues.</li>
            </ul>
        
            <h4>Objectifs de l’analyse :</h4>
            <ul>
                <li>Identifier les parties lentes d’un programme.</li>
                <li>Évaluer les ressources utilisées (temps et mémoire).</li>
                <li>Optimiser les performances en utilisant des techniques adaptées.</li>
            </ul>
        
            <h3>Étape 1 : Mesurer le Temps d’Exécution (30 min)</h3>
        
            <h4>1. Utilisation du module <code>time</code> :</h4>
            <p>
                Le module <code>time</code> permet de mesurer le temps écoulé entre deux points dans un programme. Cela peut être utilisé pour identifier les méthodes ou sections de code lentes.
            </p>
        
            <pre><code class="python">
        import time
        
        class Calcul:
            def somme_lente(self, n):
                """Méthode lente qui utilise une boucle pour calculer la somme"""
                total = 0
                for i in range(1, n + 1):
                    total += i
                return total
        
        # Mesurer le temps d'exécution
        calcul = Calcul()
        debut = time.time()
        resultat = calcul.somme_lente(10_000_000)
        fin = time.time()
        
        print(f"Résultat : {resultat}")
        print(f"Temps d'exécution : {fin - debut} secondes")
            </code></pre>
        
            <h4>Exercice :</h4>
            <ul>
                <li>Implémentez une méthode pour calculer le produit d’une liste de nombres et mesurez son temps d’exécution avec <code>time</code>.</li>
                <li>Comparez la méthode avec une version utilisant la fonction <code>sum()</code> de Python pour observer la différence de performances.</li>
            </ul>
        
            <h4>2. Optimisation de la Méthode :</h4>
            <p>Remplacez la méthode lente par une approche optimisée (par exemple, utiliser la formule de la somme des entiers).</p>
        
            <pre><code class="python">
        class Calcul:
            def somme_optimisee(self, n):
                """Méthode optimisée pour calculer la somme"""
                return n * (n + 1) // 2
        
        debut = time.time()
        resultat = calcul.somme_optimisee(10_000_000)
        fin = time.time()
        
        print(f"Résultat : {resultat}")
        print(f"Temps d'exécution (optimisé) : {fin - debut} secondes")
            </code></pre>
        
            <h3>Étape 2 : Analyse des Méthodes avec <code>cProfile</code> (30 min)</h3>
        
            <h4>1. Présentation de <code>cProfile</code> :</h4>
            <p>
                Le module <code>cProfile</code> permet de profiler un programme Python en fournissant des statistiques détaillées sur le temps passé dans chaque fonction ou méthode.
            </p>
        
            <h4>Exemple :</h4>
            <pre><code class="python">
        import cProfile
        
        class Calcul:
            def somme_lente(self, n):
                total = 0
                for i in range(1, n + 1):
                    total += i
                return total
        
            def somme_optimisee(self, n):
                return n * (n + 1) // 2
        
        calcul = Calcul()
        
        # Profiling de la méthode lente
        cProfile.run("calcul.somme_lente(10_000_000)")
        
        # Profiling de la méthode optimisée
        cProfile.run("calcul.somme_optimisee(10_000_000)")
            </code></pre>
        
            <h4>Exercice :</h4>
            <ul>
                <li>Ajoutez une méthode supplémentaire dans la classe (par exemple, pour calculer la moyenne) et profilez-la avec <code>cProfile</code>.</li>
                <li>Comparez les performances des différentes méthodes.</li>
            </ul>
        
            <h3>Étape 3 : Analyse de l’Utilisation de la Mémoire (30 min)</h3>
        
            <h4>1. Présentation de <code>sys.getsizeof()</code> :</h4>
            <p>
                Le module <code>sys</code> fournit une méthode <code>getsizeof()</code> qui permet de mesurer la mémoire utilisée par un objet.
            </p>
        
            <h4>Exemple :</h4>
            <pre><code class="python">
        import sys
        
        class Donnees:
            def __init__(self, n):
                self.liste = [i for i in range(n)]
        
        donnees = Donnees(1_000_000)
        print(f"Utilisation mémoire de la liste : {sys.getsizeof(donnees.liste)} octets")
            </code></pre>
        
            <h4>Exercice :</h4>
            <ul>
                <li>Créez un dictionnaire de 1 million d’éléments et comparez son utilisation mémoire avec une liste de même taille.</li>
                <li>Identifiez les structures de données les plus économes en mémoire.</li>
            </ul>
        
            <h4>2. Optimisation de l’Utilisation de la Mémoire :</h4>
            <p>
                Utilisez des générateurs ou des structures de données comme <code>array</code> pour réduire l’utilisation de la mémoire.
            </p>
        
            <pre><code class="python">
        import array
        
        # Utilisation d'un tableau pour réduire la mémoire
        tableau = array.array("i", (i for i in range(1_000_000)))
        print(f"Utilisation mémoire du tableau : {sys.getsizeof(tableau)} octets")
            </code></pre>
        
            <h3>Étape 4 : Synthèse et Application Pratique (15 min)</h3>
        
            <h4>Projet Pratique :</h4>
            <p>Implémentez une application de gestion d’un système scolaire avec les fonctionnalités suivantes :</p>
            <ul>
                <li>Une classe <code>Etudiant</code> avec des attributs comme le nom, la moyenne, et la liste des matières.</li>
                <li>Une méthode pour calculer la moyenne générale d’un étudiant.</li>
                <li>Une méthode pour afficher les statistiques des étudiants d’une classe.</li>
                <li>Analysez et optimisez les performances de votre application avec <code>time</code>, <code>cProfile</code>, et <code>sys</code>.</li>
            </ul>
        
            <h4>Conclusion :</h4>
            <p>
                À la fin de cette séance, les élèves sauront :
            </p>
            <ul>
                <li>Mesurer les performances en termes de temps et de mémoire.</li>
                <li>Identifier les goulets d’étranglement dans leurs projets orientés objet.</li>
                <li>Optimiser les méthodes et les structures de données pour améliorer les performances.</li>
            </ul>
        </section>

        <section id="session49" class="content-section">
            <h2>Séance 49 : Introduction aux Bases de Données Relationnelles et SQL</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Les élèves découvriront les concepts de base des bases de données relationnelles, comprendront leur utilité et apprendront les commandes SQL fondamentales pour interagir avec ces bases.
            </p>
        
            <h3>1. Qu’est-ce qu’une Base de Données Relationnelle ?</h3>
        
            <h4>Définition :</h4>
            <p>
                Une base de données relationnelle est une collection organisée de données qui sont stockées dans des <strong>tables</strong>. Chaque table contient des <strong>lignes</strong> (ou enregistrements) et des <strong>colonnes</strong> (ou champs).
            </p>
        
            <h4>Exemple :</h4>
            <p>Voici une table <code>Employes</code> :</p>
            <table border="1" cellpadding="5" cellspacing="0">
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Nom</th>
                        <th>Poste</th>
                        <th>Salaire</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>1</td>
                        <td>Alice</td>
                        <td>Développeur</td>
                        <td>50000</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>Bob</td>
                        <td>Manager</td>
                        <td>60000</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>Charlie</td>
                        <td>Designer</td>
                        <td>45000</td>
                    </tr>
                </tbody>
            </table>
        
            <h4>Avantages des Bases de Données Relationnelles :</h4>
            <ul>
                <li><strong>Organisation des données :</strong> Les données sont structurées en tables.</li>
                <li><strong>Relation entre les tables :</strong> On peut relier des tables grâce à des clés (primaires et étrangères).</li>
                <li><strong>Requêtes dynamiques :</strong> On peut interroger, modifier ou supprimer les données avec SQL.</li>
            </ul>
        
            <h3>2. Introduction à SQL (Structured Query Language)</h3>
        
            <h4>Qu’est-ce que SQL ?</h4>
            <p>
                SQL est un langage utilisé pour interagir avec une base de données. Il permet de <strong>créer</strong>, <strong>lire</strong>, <strong>mettre à jour</strong> et <strong>supprimer</strong> des données (opérations CRUD).
            </p>
        
            <h4>Principales Commandes SQL :</h4>
            <ul>
                <li><code>CREATE</code> : Créer des tables ou des bases de données.</li>
                <li><code>SELECT</code> : Lire et récupérer des données.</li>
                <li><code>INSERT</code> : Ajouter des données.</li>
                <li><code>UPDATE</code> : Mettre à jour des données existantes.</li>
                <li><code>DELETE</code> : Supprimer des données.</li>
            </ul>
        
            <h3>3. Mise en Pratique : Créer et Manipuler une Table (40 min)</h3>
        
            <h4>Étape 1 : Créer une Table</h4>
            <p>Voici un exemple pour créer une table <code>Employes</code> :</p>
            <pre><code class="sql">
        CREATE TABLE Employes (
            ID INT PRIMARY KEY,
            Nom VARCHAR(50),
            Poste VARCHAR(50),
            Salaire INT
        );
            </code></pre>
        
            <h4>Étape 2 : Ajouter des Données</h4>
            <p>Pour insérer des données dans la table <code>Employes</code> :</p>
            <pre><code class="sql">
        INSERT INTO Employes (ID, Nom, Poste, Salaire)
        VALUES (1, 'Alice', 'Développeur', 50000);
        
        INSERT INTO Employes (ID, Nom, Poste, Salaire)
        VALUES (2, 'Bob', 'Manager', 60000);
        
        INSERT INTO Employes (ID, Nom, Poste, Salaire)
        VALUES (3, 'Charlie', 'Designer', 45000);
            </code></pre>
        
            <h4>Étape 3 : Lire les Données</h4>
            <p>Utilisez la commande <code>SELECT</code> pour afficher les données :</p>
            <pre><code class="sql">
        SELECT * FROM Employes;
            </code></pre>
            <p>
                Cette commande affichera toutes les colonnes et lignes de la table <code>Employes</code>.
            </p>
        
            <h4>Étape 4 : Modifier les Données</h4>
            <p>Pour mettre à jour le salaire d’un employé :</p>
            <pre><code class="sql">
        UPDATE Employes
        SET Salaire = 55000
        WHERE ID = 1;
            </code></pre>
        
            <h4>Étape 5 : Supprimer des Données</h4>
            <p>Pour supprimer un employé de la table :</p>
            <pre><code class="sql">
        DELETE FROM Employes
        WHERE ID = 3;
            </code></pre>
        
            <h3>4. Application Pratique : Créer une Base de Données pour un Jeu Vidéo (40 min)</h3>
        
            <h4>Exercice :</h4>
            <p>Créez une base de données pour gérer les personnages d’un jeu vidéo avec les tables suivantes :</p>
            <ul>
                <li><code>Personnages</code> :
                    <ul>
                        <li><strong>ID :</strong> Identifiant unique.</li>
                        <li><strong>Nom :</strong> Nom du personnage.</li>
                        <li><strong>Classe :</strong> Guerrier, Mage, Archer, etc.</li>
                        <li><strong>Niveau :</strong> Niveau du personnage.</li>
                    </ul>
                </li>
                <li><code>Equipements</code> :
                    <ul>
                        <li><strong>ID :</strong> Identifiant unique.</li>
                        <li><strong>Nom :</strong> Nom de l’équipement.</li>
                        <li><strong>Type :</strong> Arme, Armure, Accessoire, etc.</li>
                        <li><strong>ID_Personnage :</strong> Identifiant du personnage possédant l’équipement.</li>
                    </ul>
                </li>
            </ul>
        
            <h4>Exemple d’Implémentation :</h4>
            <pre><code class="sql">
        -- Création des tables
        CREATE TABLE Personnages (
            ID INT PRIMARY KEY,
            Nom VARCHAR(50),
            Classe VARCHAR(50),
            Niveau INT
        );
        
        CREATE TABLE Equipements (
            ID INT PRIMARY KEY,
            Nom VARCHAR(50),
            Type VARCHAR(50),
            ID_Personnage INT,
            FOREIGN KEY (ID_Personnage) REFERENCES Personnages(ID)
        );
        
        -- Insertion des données
        INSERT INTO Personnages (ID, Nom, Classe, Niveau)
        VALUES (1, 'Arthas', 'Guerrier', 10),
               (2, 'Jaina', 'Mage', 12);
        
        INSERT INTO Equipements (ID, Nom, Type, ID_Personnage)
        VALUES (1, 'Épée Longue', 'Arme', 1),
               (2, 'Robe Enchantée', 'Armure', 2);
            </code></pre>
        
            <h4>Défi :</h4>
            <p>
                Rédigez des requêtes pour :
            </p>
            <ul>
                <li>Afficher tous les personnages avec leurs équipements.</li>
                <li>Ajouter un nouveau personnage et son équipement.</li>
                <li>Mettre à jour le niveau d’un personnage.</li>
                <li>Supprimer un personnage et ses équipements associés.</li>
            </ul>
        
            <h3>5. Conclusion :</h3>
            <ul>
                <li>Les bases de données relationnelles permettent de structurer les données de manière efficace.</li>
                <li>SQL est un outil puissant pour créer, lire, mettre à jour et supprimer des données.</li>
                <li>Les relations entre les tables sont essentielles pour modéliser des systèmes complexes.</li>
            </ul>
            <p>
                Cette séance offre une première introduction pratique aux bases de données et au SQL, ouvrant la voie à des applications plus avancées.
            </p>
        </section>

        <section id="session50" class="content-section">
            <h2>Séance 50 : Pratique - Création d’une base de données pour gérer des scores de jeu vidéo</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Les élèves apprendront à concevoir et à utiliser une base de données relationnelle pour gérer les scores des joueurs d’un jeu vidéo. Ils découvriront comment créer une base de données, ajouter des données, effectuer des requêtes et mettre à jour les scores.
            </p>
        
            <h3>Contexte du Projet :</h3>
            <p>
                Imaginez un jeu vidéo où plusieurs joueurs s’affrontent pour obtenir le meilleur score. Vous devez créer un système de gestion des scores, où les données des joueurs (nom, score, date) sont stockées dans une base de données relationnelle.
            </p>
        
            <ul>
                <li>Les élèves utiliseront SQLite, une base de données légère et simple à intégrer avec Python.</li>
                <li>Ils apprendront à interagir avec la base de données en utilisant la bibliothèque <code>sqlite3</code>.</li>
            </ul>
        
            <h3>Étape 1 : Conception de la Base de Données (20 min)</h3>
        
            <h4>Structure de la Table :</h4>
            <p>La base de données contiendra une table <code>scores</code> avec les colonnes suivantes :</p>
            <ul>
                <li><code>id</code> (entier, clé primaire) : Identifiant unique pour chaque joueur.</li>
                <li><code>nom</code> (texte) : Nom du joueur.</li>
                <li><code>score</code> (entier) : Score du joueur.</li>
                <li><code>date</code> (texte) : Date du score (format AAAA-MM-JJ).</li>
            </ul>
        
            <h4>Représentation SQL :</h4>
            <pre><code class="sql">
        CREATE TABLE scores (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            nom TEXT NOT NULL,
            score INTEGER NOT NULL,
            date TEXT NOT NULL
        );
            </code></pre>
        
            <h3>Étape 2 : Création de la Base de Données et de la Table (30 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Utilisez Python et <code>sqlite3</code> pour créer une base de données nommée <code>jeux.db</code> et y ajouter une table <code>scores</code>.
            </p>
        
            <h4>Code Python :</h4>
            <pre><code class="python">
        import sqlite3
        
        # Connexion à la base de données (création si elle n'existe pas)
        connexion = sqlite3.connect("jeux.db")
        
        # Création d'un curseur pour exécuter des commandes SQL
        curseur = connexion.cursor()
        
        # Création de la table 'scores'
        curseur.execute("""
        CREATE TABLE IF NOT EXISTS scores (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            nom TEXT NOT NULL,
            score INTEGER NOT NULL,
            date TEXT NOT NULL
        )
        """)
        
        # Enregistrement des modifications et fermeture de la connexion
        connexion.commit()
        connexion.close()
        
        print("Base de données et table 'scores' créées avec succès.")
            </code></pre>
        
            <h3>Étape 3 : Ajout de Données dans la Base de Données (30 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Créez un script pour ajouter les scores de plusieurs joueurs à la table <code>scores</code>.
            </p>
        
            <h4>Code Python :</h4>
            <pre><code class="python">
        import sqlite3
        from datetime import datetime
        
        # Connexion à la base de données
        connexion = sqlite3.connect("jeux.db")
        curseur = connexion.cursor()
        
        # Données des joueurs
        joueurs = [
            ("Alice", 1200, datetime.now().strftime("%Y-%m-%d")),
            ("Bob", 950, datetime.now().strftime("%Y-%m-%d")),
            ("Charlie", 1600, datetime.now().strftime("%Y-%m-%d"))
        ]
        
        # Ajout des données
        curseur.executemany("""
        INSERT INTO scores (nom, score, date)
        VALUES (?, ?, ?)
        """, joueurs)
        
        # Enregistrement des modifications et fermeture de la connexion
        connexion.commit()
        connexion.close()
        
        print("Données insérées avec succès.")
            </code></pre>
        
            <h3>Étape 4 : Consultation et Mise à Jour des Scores (30 min)</h3>
        
            <h4>Exercice 1 :</h4>
            <p>Affichez tous les scores enregistrés dans la base de données.</p>
        
            <h4>Code Python :</h4>
            <pre><code class="python">
        # Connexion à la base de données
        connexion = sqlite3.connect("jeux.db")
        curseur = connexion.cursor()
        
        # Récupération des scores
        curseur.execute("SELECT * FROM scores")
        resultats = curseur.fetchall()
        
        # Affichage des scores
        print("Scores des joueurs :")
        for ligne in resultats:
            print(f"ID: {ligne[0]}, Nom: {ligne[1]}, Score: {ligne[2]}, Date: {ligne[3]}")
        
        # Fermeture de la connexion
        connexion.close()
            </code></pre>
        
            <h4>Exercice 2 :</h4>
            <p>
                Mettez à jour le score d’un joueur en fonction de son nom.
            </p>
        
            <h4>Code Python :</h4>
            <pre><code class="python">
        # Connexion à la base de données
        connexion = sqlite3.connect("jeux.db")
        curseur = connexion.cursor()
        
        # Mise à jour du score
        nom_joueur = "Alice"
        nouveau_score = 1350
        curseur.execute("""
        UPDATE scores
        SET score = ?
        WHERE nom = ?
        """, (nouveau_score, nom_joueur))
        
        # Vérification de la mise à jour
        curseur.execute("SELECT * FROM scores WHERE nom = ?", (nom_joueur,))
        print("Score mis à jour :", curseur.fetchone())
        
        # Enregistrement des modifications et fermeture de la connexion
        connexion.commit()
        connexion.close()
            </code></pre>
        
            <h3>Étape 5 : Suppression des Données (20 min)</h3>
        
            <h4>Exercice :</h4>
            <p>Créez un script pour supprimer les scores d’un joueur en fonction de son nom.</p>
        
            <h4>Code Python :</h4>
            <pre><code class="python">
        # Connexion à la base de données
        connexion = sqlite3.connect("jeux.db")
        curseur = connexion.cursor()
        
        # Suppression d'un joueur
        nom_joueur = "Charlie"
        curseur.execute("DELETE FROM scores WHERE nom = ?", (nom_joueur,))
        
        # Vérification de la suppression
        curseur.execute("SELECT * FROM scores")
        print("Données restantes :", curseur.fetchall())
        
        # Enregistrement des modifications et fermeture de la connexion
        connexion.commit()
        connexion.close()
            </code></pre>
        
            <h3>Conclusion :</h3>
            <p>
                À la fin de cette séance, les élèves auront appris à :
            </p>
            <ul>
                <li>Créer une base de données et une table en SQL via Python.</li>
                <li>Ajouter, consulter, mettre à jour et supprimer des données dans une base de données.</li>
                <li>Utiliser SQLite pour gérer des données de manière efficace dans une application de jeu vidéo.</li>
            </ul>
            <p>
                Ce projet montre comment appliquer les bases de données pour gérer des données complexes, tout en intégrant des pratiques professionnelles.
            </p>
        </section>

        <section id="session51" class="content-section">
            <h2>Séance 51 : Requêtes SQL de base (SELECT, INSERT, UPDATE, DELETE)</h2>
        
            <h3>Objectif Global :</h3>
            <p>Les élèves apprendront à utiliser les commandes SQL de base pour interagir avec une base de données. Ils seront capables de lire, insérer, mettre à jour et supprimer des données à l’aide des commandes <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, et <code>DELETE</code>.</p>
        
            <h3>Introduction à SQL (10 min)</h3>
            <p>
                SQL (Structured Query Language) est un langage utilisé pour interagir avec des bases de données relationnelles. Les bases de données stockent des informations de manière structurée dans des <strong>tables</strong>.
            </p>
            <p>Chaque table est composée de :</p>
            <ul>
                <li><strong>Colonnes :</strong> Définissent les types de données (ex. : nom, âge).</li>
                <li><strong>Lignes :</strong> Représentent les enregistrements individuels.</li>
            </ul>
            <p>Exemple de table <code>Employes</code> :</p>
            <pre><code>
        +----+------------+--------+-------------+
        | ID | Nom        | Age    | Poste       |
        +----+------------+--------+-------------+
        | 1  | Alice      | 30     | Développeur |
        | 2  | Bob        | 35     | Manager     |
        | 3  | Claire     | 28     | Analyste    |
        +----+------------+--------+-------------+
            </code></pre>
        
            <h3>1. Commande SELECT (20 min)</h3>
            <h4>Qu’est-ce que <code>SELECT</code> ?</h4>
            <p>La commande <code>SELECT</code> est utilisée pour lire ou récupérer des données dans une table.</p>
        
            <h4>Exemples de Requêtes <code>SELECT</code> :</h4>
            <pre><code class="sql">
        -- Récupérer toutes les colonnes de la table Employes
        SELECT * FROM Employes;
        
        -- Récupérer uniquement le nom et le poste
        SELECT Nom, Poste FROM Employes;
        
        -- Filtrer les résultats (employés ayant plus de 30 ans)
        SELECT * FROM Employes WHERE Age > 30;
            </code></pre>
        
            <h4>Exercice :</h4>
            <ul>
                <li>Affichez tous les employés avec leur poste.</li>
                <li>Affichez uniquement les employés ayant le poste de "Manager".</li>
                <li>Affichez les employés dont l’âge est inférieur à 30.</li>
            </ul>
        
            <h3>2. Commande INSERT (20 min)</h3>
            <h4>Qu’est-ce que <code>INSERT</code> ?</h4>
            <p>La commande <code>INSERT</code> est utilisée pour ajouter de nouvelles lignes dans une table.</p>
        
            <h4>Exemples de Requêtes <code>INSERT</code> :</h4>
            <pre><code class="sql">
        -- Ajouter un nouvel employé
        INSERT INTO Employes (Nom, Age, Poste) VALUES ('David', 40, 'Consultant');
        
        -- Ajouter un employé avec des valeurs partielles
        INSERT INTO Employes (Nom, Poste) VALUES ('Eve', 'Designer');
            </code></pre>
        
            <h4>Exercice :</h4>
            <ul>
                <li>Ajoutez un employé nommé "Sophie", âgé de 25 ans, au poste de "Développeur".</li>
                <li>Ajoutez un employé nommé "John" sans préciser son âge, mais avec le poste "Analyste".</li>
            </ul>
        
            <h3>3. Commande UPDATE (20 min)</h3>
            <h4>Qu’est-ce que <code>UPDATE</code> ?</h4>
            <p>La commande <code>UPDATE</code> est utilisée pour modifier les données existantes dans une table.</p>
        
            <h4>Exemples de Requêtes <code>UPDATE</code> :</h4>
            <pre><code class="sql">
        -- Modifier le poste de l'employé avec l'ID 1
        UPDATE Employes SET Poste = 'Chef de Projet' WHERE ID = 1;
        
        -- Augmenter l'âge de tous les employés de 1 an
        UPDATE Employes SET Age = Age + 1;
        
        -- Modifier le nom de l'employé nommé "Bob"
        UPDATE Employes SET Nom = 'Robert' WHERE Nom = 'Bob';
            </code></pre>
        
            <h4>Exercice :</h4>
            <ul>
                <li>Modifiez le poste de "Claire" pour qu’il devienne "Consultante".</li>
                <li>Ajoutez 2 ans à l’âge de tous les employés.</li>
            </ul>
        
            <h3>4. Commande DELETE (20 min)</h3>
            <h4>Qu’est-ce que <code>DELETE</code> ?</h4>
            <p>La commande <code>DELETE</code> est utilisée pour supprimer des lignes d’une table.</p>
        
            <h4>Exemples de Requêtes <code>DELETE</code> :</h4>
            <pre><code class="sql">
        -- Supprimer l'employé avec l'ID 3
        DELETE FROM Employes WHERE ID = 3;
        
        -- Supprimer tous les employés ayant le poste de "Analyste"
        DELETE FROM Employes WHERE Poste = 'Analyste';
        
        -- Supprimer tous les enregistrements de la table
        DELETE FROM Employes;
            </code></pre>
        
            <h4>Exercice :</h4>
            <ul>
                <li>Supprimez l’employé nommé "Eve".</li>
                <li>Supprimez tous les employés ayant plus de 40 ans.</li>
            </ul>
        
            <h3>Conclusion et Discussion (10 min)</h3>
            <p>
                Les élèves ont appris à utiliser les commandes SQL de base pour interagir avec une base de données relationnelle. Ces commandes permettent de :
            </p>
            <ul>
                <li><strong>SELECT :</strong> Lire les données.</li>
                <li><strong>INSERT :</strong> Ajouter des données.</li>
                <li><strong>UPDATE :</strong> Modifier des données existantes.</li>
                <li><strong>DELETE :</strong> Supprimer des données.</li>
            </ul>
            <p>Discussion : Quels sont les risques potentiels d’une mauvaise utilisation de <code>UPDATE</code> ou <code>DELETE</code>, et comment s’assurer que les requêtes sont sûres ?</p>
        </section>

        <section id="session52" class="content-section">
            <h2>Séance 52 : Requêtes SQL Avancées (JOIN, GROUP BY)</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Cette séance vise à introduire les élèves aux requêtes SQL avancées, avec un accent sur les opérations <code>JOIN</code> pour relier plusieurs tables et <code>GROUP BY</code> pour agréger des données. Les élèves apprendront à manipuler des bases de données complexes et à extraire des informations pertinentes.
            </p>
        
            <h3>Pré-requis :</h3>
            <ul>
                <li>Connaissances de base en SQL (SELECT, WHERE, INSERT, UPDATE).</li>
                <li>Compréhension des concepts de tables et de relations dans une base de données.</li>
            </ul>
        
            <h3>Introduction aux Concepts Avancés (20 min)</h3>
        
            <h4>1. Qu’est-ce qu’un <code>JOIN</code> ?</h4>
            <p>
                En SQL, un <code>JOIN</code> permet de combiner des colonnes de deux ou plusieurs tables en utilisant une relation entre elles. Les types principaux de <code>JOIN</code> sont :
            </p>
            <ul>
                <li><strong>INNER JOIN :</strong> Retourne les lignes où il y a une correspondance dans les deux tables.</li>
                <li><strong>LEFT JOIN :</strong> Retourne toutes les lignes de la table de gauche, avec les correspondances de la table de droite (ou NULL si aucune correspondance).</li>
                <li><strong>RIGHT JOIN :</strong> Semblable au LEFT JOIN, mais retourne toutes les lignes de la table de droite.</li>
                <li><strong>FULL OUTER JOIN :</strong> Retourne toutes les lignes lorsqu’il y a une correspondance dans l’une des tables.</li>
            </ul>
        
            <h4>2. Qu’est-ce que <code>GROUP BY</code> ?</h4>
            <p>
                Le <code>GROUP BY</code> est utilisé pour regrouper des lignes ayant les mêmes valeurs dans des colonnes spécifiées. Il est souvent utilisé avec des fonctions d’agrégation (SUM, AVG, COUNT, MAX, MIN) pour produire des résultats résumés.
            </p>
        
            <h3>Étape 1 : Pratique avec les <code>JOIN</code> (40 min)</h3>
        
            <h4>Base de Données Exemple :</h4>
            <p>
                Les élèves travailleront avec deux tables liées dans une base de données de gestion d’une librairie :
            </p>
        
            <pre><code>
            Table : Livres
            +----+-------------------+--------+
            | ID | Titre             | Auteur |
            +----+-------------------+--------+
            | 1  | Python pour Débutants | 101    |
            | 2  | SQL Avancé        | 102    |
            | 3  | Algorithmes       | 103    |
            +----+-------------------+--------+
        
            Table : Auteurs
            +----+--------------------+
            | ID | Nom               |
            +----+--------------------+
            | 101| Alice             |
            | 102| Bob               |
            | 103| Charlie           |
            +----+--------------------+
            </code></pre>
        
            <h4>Exemple d’un <code>INNER JOIN</code> :</h4>
            <p>Combinez les informations des livres avec leurs auteurs :</p>
            <pre><code class="sql">
            SELECT Livres.Titre, Auteurs.Nom
            FROM Livres
            INNER JOIN Auteurs
            ON Livres.Auteur = Auteurs.ID;
            </code></pre>
        
            <p><strong>Résultat :</strong></p>
            <pre><code>
            +-------------------+---------+
            | Titre             | Nom     |
            +-------------------+---------+
            | Python pour Débutants | Alice   |
            | SQL Avancé        | Bob     |
            | Algorithmes       | Charlie |
            +-------------------+---------+
            </code></pre>
        
            <h4>Exercice :</h4>
            <p>Modifiez la requête pour inclure uniquement les livres écrits par "Alice".</p>
            <pre><code class="sql">
            SELECT Livres.Titre
            FROM Livres
            INNER JOIN Auteurs
            ON Livres.Auteur = Auteurs.ID
            WHERE Auteurs.Nom = 'Alice';
            </code></pre>
        
            <h4>Exemple d’un <code>LEFT JOIN</code> :</h4>
            <p>Affichez tous les livres, même ceux sans auteur (imaginons qu’un auteur soit supprimé) :</p>
            <pre><code class="sql">
            SELECT Livres.Titre, Auteurs.Nom
            FROM Livres
            LEFT JOIN Auteurs
            ON Livres.Auteur = Auteurs.ID;
            </code></pre>
        
            <h3>Étape 2 : Pratique avec <code>GROUP BY</code> (40 min)</h3>
        
            <h4>Base de Données Exemple :</h4>
            <p>
                Ajoutons une table des ventes pour regrouper les données sur les livres vendus :
            </p>
        
            <pre><code>
            Table : Ventes
            +----+---------+--------+
            | ID | LivreID | Quantité |
            +----+---------+--------+
            | 1  | 1       | 5      |
            | 2  | 1       | 3      |
            | 3  | 2       | 8      |
            | 4  | 3       | 2      |
            +----+---------+--------+
            </code></pre>
        
            <h4>Exemple de <code>GROUP BY</code> :</h4>
            <p>Regroupez les données pour afficher le total des ventes par livre :</p>
            <pre><code class="sql">
            SELECT Livres.Titre, SUM(Ventes.Quantité) AS TotalVentes
            FROM Ventes
            INNER JOIN Livres
            ON Ventes.LivreID = Livres.ID
            GROUP BY Livres.Titre;
            </code></pre>
        
            <p><strong>Résultat :</strong></p>
            <pre><code>
            +-------------------+-------------+
            | Titre             | TotalVentes |
            +-------------------+-------------+
            | Python pour Débutants | 8           |
            | SQL Avancé        | 8           |
            | Algorithmes       | 2           |
            +-------------------+-------------+
            </code></pre>
        
            <h4>Exercice :</h4>
            <p>
                Affichez uniquement les livres ayant vendu plus de 5 exemplaires :
            </p>
            <pre><code class="sql">
            SELECT Livres.Titre, SUM(Ventes.Quantité) AS TotalVentes
            FROM Ventes
            INNER JOIN Livres
            ON Ventes.LivreID = Livres.ID
            GROUP BY Livres.Titre
            HAVING SUM(Ventes.Quantité) > 5;
            </code></pre>
        
            <h3>Conclusion :</h3>
            <p>
                À la fin de cette séance, les élèves sauront utiliser :
            </p>
            <ul>
                <li><strong>JOIN :</strong> Combiner des données de plusieurs tables pour obtenir des informations complètes.</li>
                <li><strong>GROUP BY :</strong> Résumer et agréger des données pour des analyses statistiques.</li>
                <li><strong>HAVING :</strong> Filtrer des groupes après l'agrégation.</li>
            </ul>
            <p>Ces compétences permettent de manipuler efficacement des bases de données complexes et d’extraire des informations pertinentes dans des contextes réels.</p>
        </section>

        <section id="session53" class="content-section">
            <h2>Séance 53 : Pratique - Interrogation complexe d'une base de données pour récupérer des données sur les personnages d’un manga</h2>
        
            <h3>Objectif Global :</h3>
            <p>Les élèves apprendront à interroger une base de données relationnelle avec des requêtes SQL complexes, comprenant des filtres, des jointures, et des agrégations. Le contexte pratique sera basé sur une base de données contenant des informations sur les personnages, les arcs narratifs, et les capacités spéciales des personnages d’un manga.</p>
        
            <h3>Contexte du Projet :</h3>
            <p>
                Imaginez une base de données pour un manga populaire. La base contient les tables suivantes :
            </p>
            <ul>
                <li><strong>Personnages :</strong> Informations générales sur les personnages.</li>
                <li><strong>Arcs_Narratifs :</strong> Détails sur les arcs du manga.</li>
                <li><strong>Capacites_Speciales :</strong> Capacités spéciales associées aux personnages.</li>
                <li><strong>Personnage_Arc :</strong> Relation entre les personnages et les arcs narratifs.</li>
            </ul>
        
            <h3>Structure de la Base de Données :</h3>
            <pre><code class="sql">
        -- Table des personnages
        CREATE TABLE Personnages (
            id INT PRIMARY KEY,
            nom VARCHAR(100),
            niveau_puissance INT,
            clan VARCHAR(100)
        );
        
        -- Table des arcs narratifs
        CREATE TABLE Arcs_Narratifs (
            id INT PRIMARY KEY,
            nom VARCHAR(100),
            debut_episode INT,
            fin_episode INT
        );
        
        -- Table des capacités spéciales
        CREATE TABLE Capacites_Speciales (
            id INT PRIMARY KEY,
            nom VARCHAR(100),
            description TEXT
        );
        
        -- Table pour relier les personnages et les arcs
        CREATE TABLE Personnage_Arc (
            id_personnage INT,
            id_arc INT,
            FOREIGN KEY (id_personnage) REFERENCES Personnages(id),
            FOREIGN KEY (id_arc) REFERENCES Arcs_Narratifs(id)
        );
            </code></pre>
        
            <h3>Étape 1 : Préparation de la Base de Données (20 min)</h3>
        
            <h4>Exercice :</h4>
            <p>Insérez des données dans les tables pour représenter les personnages et les arcs d’un manga. Par exemple :</p>
        
            <pre><code class="sql">
        -- Données pour la table Personnages
        INSERT INTO Personnages (id, nom, niveau_puissance, clan) VALUES
        (1, 'Naruto Uzumaki', 9000, 'Konoha'),
        (2, 'Sasuke Uchiha', 9500, 'Konoha'),
        (3, 'Gaara', 8000, 'Suna'),
        (4, 'Madara Uchiha', 12000, 'Konoha');
        
        -- Données pour la table Arcs_Narratifs
        INSERT INTO Arcs_Narratifs (id, nom, debut_episode, fin_episode) VALUES
        (1, 'Examen Chunin', 1, 20),
        (2, 'Invasion de Konoha', 21, 50),
        (3, 'Grande Guerre Ninja', 51, 100);
        
        -- Données pour la table Capacites_Speciales
        INSERT INTO Capacites_Speciales (id, nom, description) VALUES
        (1, 'Rasengan', 'Technique de concentration de chakra.'),
        (2, 'Sharingan', 'Technique héréditaire du clan Uchiha.'),
        (3, 'Sabaku no Tate', 'Bouclier de sable automatique.');
        
        -- Données pour la table Personnage_Arc
        INSERT INTO Personnage_Arc (id_personnage, id_arc) VALUES
        (1, 1),
        (2, 1),
        (1, 2),
        (3, 2),
        (4, 3);
            </code></pre>
        
            <p>Les élèves doivent vérifier que les données ont été insérées correctement en utilisant des requêtes simples comme :</p>
            <pre><code class="sql">
        SELECT * FROM Personnages;
        SELECT * FROM Arcs_Narratifs;
        SELECT * FROM Personnage_Arc;
            </code></pre>
        
            <h3>Étape 2 : Requêtes SQL Complexes (40 min)</h3>
        
            <h4>Exercice :</h4>
            <p>Les élèves doivent écrire des requêtes SQL pour extraire des informations complexes. Voici quelques exemples de scénarios :</p>
        
            <h5>1. Récupérer les personnages d’un arc narratif donné :</h5>
            <pre><code class="sql">
        SELECT p.nom
        FROM Personnages p
        JOIN Personnage_Arc pa ON p.id = pa.id_personnage
        JOIN Arcs_Narratifs a ON pa.id_arc = a.id
        WHERE a.nom = 'Invasion de Konoha';
            </code></pre>
        
            <h5>2. Trouver le personnage avec le niveau de puissance le plus élevé :</h5>
            <pre><code class="sql">
        SELECT nom, niveau_puissance
        FROM Personnages
        ORDER BY niveau_puissance DESC
        LIMIT 1;
            </code></pre>
        
            <h5>3. Lister tous les personnages avec leurs capacités spéciales :</h5>
            <pre><code class="sql">
        SELECT p.nom AS personnage, c.nom AS capacite
        FROM Personnages p
        JOIN Capacites_Speciales c ON p.id = c.id
        ORDER BY p.nom;
            </code></pre>
        
            <h5>4. Compter le nombre de personnages par clan :</h5>
            <pre><code class="sql">
        SELECT clan, COUNT(*) AS nombre_personnages
        FROM Personnages
        GROUP BY clan;
            </code></pre>
        
            <h5>5. Récupérer les arcs dans lesquels un personnage spécifique apparaît :</h5>
            <pre><code class="sql">
        SELECT a.nom AS arc
        FROM Arcs_Narratifs a
        JOIN Personnage_Arc pa ON a.id = pa.id_arc
        JOIN Personnages p ON pa.id_personnage = p.id
        WHERE p.nom = 'Naruto Uzumaki';
            </code></pre>
        
            <h3>Étape 3 : Application Pratique et Défi (40 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Les élèves doivent répondre aux questions suivantes en écrivant les requêtes SQL correspondantes :
            </p>
            <ul>
                <li><strong>Quels personnages apparaissent dans plus d’un arc narratif ?</strong></li>
                <li><strong>Quels arcs narratifs incluent uniquement des personnages de Konoha ?</strong></li>
                <li><strong>Quelle est la capacité spéciale la plus courante parmi les personnages ?</strong></li>
            </ul>
        
            <h4>Défi Bonus :</h4>
            <p>Créez une vue SQL pour simplifier l’accès aux informations sur les personnages et les arcs :</p>
            <pre><code class="sql">
        CREATE VIEW Vue_Personnages_Arcs AS
        SELECT p.nom AS personnage, a.nom AS arc, p.niveau_puissance, p.clan
        FROM Personnages p
        JOIN Personnage_Arc pa ON p.id = pa.id_personnage
        JOIN Arcs_Narratifs a ON pa.id_arc = a.id;
            </code></pre>
            <p>Les élèves peuvent ensuite interroger cette vue :</p>
            <pre><code class="sql">
        SELECT * FROM Vue_Personnages_Arcs WHERE clan = 'Konoha';
            </code></pre>
        
            <h3>Conclusion :</h3>
            <p>
                À la fin de cette séance, les élèves auront appris à :
            </p>
            <ul>
                <li>Créer et manipuler une base de données relationnelle.</li>
                <li>Écrire des requêtes SQL complexes incluant des jointures, des filtres et des agrégations.</li>
                <li>Appliquer ces compétences dans un contexte concret et engageant basé sur un manga populaire.</li>
            </ul>
        </section>

        <section id="session54" class="content-section">
            <h2>Séance 54 : Optimisation des Requêtes SQL</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Les élèves apprendront à identifier les problèmes de performance dans les requêtes SQL et à utiliser des techniques d’optimisation. L'objectif est d'améliorer l'efficacité des requêtes pour manipuler des bases de données volumineuses.
            </p>
        
            <h3>Introduction (15 min)</h3>
        
            <h4>Pourquoi optimiser les requêtes SQL ?</h4>
            <p>
                L’optimisation des requêtes SQL est essentielle pour améliorer la vitesse et réduire la charge sur les bases de données, en particulier dans les applications à grande échelle. Des requêtes inefficaces peuvent ralentir une application et consommer beaucoup de ressources.
            </p>
        
            <h4>Concepts Clés :</h4>
            <ul>
                <li><strong>Index :</strong> Structures de données qui permettent de retrouver rapidement des lignes dans une table.</li>
                <li><strong>Analyse des plans d’exécution :</strong> Outils pour comprendre comment une requête est traitée par le moteur SQL.</li>
                <li><strong>Requêtes non optimisées :</strong> Exemples de requêtes lentes à cause de jointures ou de filtres inefficaces.</li>
            </ul>
        
            <h3>Étape 1 : Analyse des Problèmes de Performance (20 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Donnez une base de données simple avec deux tables :
            </p>
            <pre><code class="sql">
        CREATE TABLE Employes (
            id INT PRIMARY KEY,
            nom VARCHAR(50),
            salaire DECIMAL(10, 2),
            departement_id INT
        );
        
        CREATE TABLE Departements (
            id INT PRIMARY KEY,
            nom VARCHAR(50)
        );
        
        -- Insertion de données
        INSERT INTO Employes VALUES (1, 'Alice', 50000, 1);
        INSERT INTO Employes VALUES (2, 'Bob', 60000, 2);
        INSERT INTO Departements VALUES (1, 'Informatique');
        INSERT INTO Departements VALUES (2, 'Ressources Humaines');
            </code></pre>
        
            <p>Requête initiale :</p>
            <pre><code class="sql">
        SELECT Employes.nom, Departements.nom
        FROM Employes
        JOIN Departements ON Employes.departement_id = Departements.id;
            </code></pre>
        
            <p><strong>Problème :</strong> Si la base contient beaucoup de données, cette requête peut devenir lente.</p>
        
            <h4>Analyse avec EXPLAIN :</h4>
            <p>
                Utilisez la commande <code>EXPLAIN</code> pour comprendre comment le moteur SQL exécute cette requête.
            </p>
            <pre><code class="sql">
        EXPLAIN SELECT Employes.nom, Departements.nom
        FROM Employes
        JOIN Departements ON Employes.departement_id = Departements.id;
            </code></pre>
        
            <p>Analyse des résultats :</p>
            <ul>
                <li>Regardez le type de jointure utilisé (ex. : <code>ALL</code>, <code>INDEX</code>, <code>REF</code>).</li>
                <li>Identifiez les colonnes non indexées qui ralentissent la recherche.</li>
            </ul>
        
            <h3>Étape 2 : Utilisation des Index pour Améliorer les Performances (30 min)</h3>
        
            <h4>Qu’est-ce qu’un Index ?</h4>
            <p>
                Un index est une structure de données qui permet d’accélérer les recherches dans une table en réduisant le nombre de lignes à parcourir.
            </p>
        
            <h4>Création d’un Index :</h4>
            <pre><code class="sql">
        -- Création d'un index sur la colonne departement_id
        CREATE INDEX idx_departement_id ON Employes(departement_id);
            </code></pre>
        
            <h4>Test de Performance :</h4>
            <p>Exécutez à nouveau la requête après avoir créé l’index et analysez les résultats avec <code>EXPLAIN</code>.</p>
            <pre><code class="sql">
        EXPLAIN SELECT Employes.nom, Departements.nom
        FROM Employes
        JOIN Departements ON Employes.departement_id = Departements.id;
            </code></pre>
        
            <h4>Comparaison :</h4>
            <ul>
                <li>Notez les différences dans le type de jointure utilisé (ex. : utilisation de l’index).</li>
                <li>Observez la réduction du temps d’exécution.</li>
            </ul>
        
            <h3>Étape 3 : Optimisation des Filtres et des Jointures (30 min)</h3>
        
            <h4>Filtres Inefficaces :</h4>
            <p>
                Les requêtes avec des conditions non optimisées peuvent être lentes, par exemple :
            </p>
            <pre><code class="sql">
        SELECT * FROM Employes WHERE salaire * 2 > 100000;
            </code></pre>
        
            <p><strong>Problème :</strong> L’utilisation d’une opération sur la colonne (<code>salaire * 2</code>) empêche l’utilisation d’un index.</p>
        
            <h4>Solution :</h4>
            <p>
                Réécrivez la requête pour éviter les opérations sur les colonnes :
            </p>
            <pre><code class="sql">
        SELECT * FROM Employes WHERE salaire > 50000;
            </code></pre>
        
            <h4>Optimisation des Jointures :</h4>
            <p>
                Les jointures entre plusieurs tables peuvent ralentir les requêtes si elles ne sont pas bien conçues. Assurez-vous que les colonnes utilisées pour les jointures sont indexées.
            </p>
            <pre><code class="sql">
        -- Exemple avec une jointure optimisée
        SELECT Employes.nom, Departements.nom
        FROM Employes
        JOIN Departements ON Employes.departement_id = Departements.id
        WHERE Departements.nom = 'Informatique';
            </code></pre>
        
            <h3>Étape 4 : Utilisation de LIMIT et Pagination (20 min)</h3>
        
            <h4>Pourquoi utiliser LIMIT ?</h4>
            <p>
                Lorsqu’une requête renvoie un grand nombre de résultats, afficher uniquement une partie des données améliore les performances.
            </p>
        
            <h4>Exemple :</h4>
            <pre><code class="sql">
        -- Limiter les résultats à 10 lignes
        SELECT * FROM Employes LIMIT 10;
        
        -- Pagination : afficher les résultats de la page 2 (10 lignes par page)
        SELECT * FROM Employes LIMIT 10 OFFSET 10;
            </code></pre>
        
            <h4>Défi Pratique :</h4>
            <p>Ajoutez la pagination à une requête complexe pour afficher les employés par tranche de 10.</p>
        
            <h3>Conclusion et Discussion (10 min)</h3>
        
            <ul>
                <li><strong>Analyse :</strong> Utilisez <code>EXPLAIN</code> pour identifier les goulots d’étranglement dans les requêtes.</li>
                <li><strong>Indexation :</strong> Créez des index sur les colonnes utilisées dans les conditions ou les jointures.</li>
                <li><strong>Filtres :</strong> Évitez les calculs sur les colonnes dans les clauses <code>WHERE</code>.</li>
                <li><strong>Pagination :</strong> Utilisez <code>LIMIT</code> pour afficher les résultats par petits lots.</li>
            </ul>
        
            <p>
                À la fin de cette séance, les élèves auront appris à identifier et résoudre les problèmes de performance dans les requêtes SQL, en appliquant des techniques pratiques adaptées à des scénarios réels.
            </p>
        </section>

        <section id="session55" class="content-section">
            <h2>Séance 55 : Introduction à la Normalisation (1NF, 2NF, 3NF)</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Les élèves comprendront les principes de la normalisation des bases de données relationnelles. Ils apprendront les règles associées aux trois premières formes normales (1NF, 2NF, 3NF) et appliqueront ces principes pour concevoir des bases de données optimisées et cohérentes.
            </p>
        
            <h3>Introduction à la Normalisation</h3>
            <p>
                La normalisation est un processus en base de données visant à organiser les tables pour :
            </p>
            <ul>
                <li>Réduire la redondance des données.</li>
                <li>Améliorer l'intégrité des données.</li>
                <li>Faciliter la maintenance et la mise à jour des données.</li>
            </ul>
            <p>
                Elle repose sur une série de règles appelées "formes normales", chaque niveau résolvant des problèmes spécifiques.
            </p>
        
            <h3>1NF : Première Forme Normale</h3>
            <h4>Définition :</h4>
            <p>
                Une table est en première forme normale (1NF) si :
            </p>
            <ul>
                <li>Toutes les colonnes contiennent des valeurs atomiques (non divisibles).</li>
                <li>Chaque ligne est unique et identifiable par une clé primaire.</li>
            </ul>
        
            <h4>Exemple :</h4>
            <p>Table non normalisée :</p>
            <pre><code>
        Étudiant   | Cours
        -----------|---------------------
        Alice      | Math, Physique
        Bob        | Biologie
        Charlie    | Math, Biologie
            </code></pre>
        
            <p>Problèmes :</p>
            <ul>
                <li>Les colonnes contiennent plusieurs valeurs (Math, Physique).</li>
                <li>Les données ne sont pas atomiques.</li>
            </ul>
        
            <p>Table normalisée en 1NF :</p>
            <pre><code>
        Étudiant   | Cours
        -----------|---------
        Alice      | Math
        Alice      | Physique
        Bob        | Biologie
        Charlie    | Math
        Charlie    | Biologie
            </code></pre>
        
            <h4>Exercice 1 :</h4>
            <p>Normalisez la table suivante en 1NF :</p>
            <pre><code>
        Commande   | Articles
        -----------|----------------
        001        | Livre, Stylo
        002        | Cahier
        003        | Livre, Cahier
            </code></pre>
        
            <h3>2NF : Deuxième Forme Normale</h3>
            <h4>Définition :</h4>
            <p>
                Une table est en deuxième forme normale (2NF) si elle est en 1NF et que toutes les colonnes non clés dépendent entièrement de la clé primaire.
            </p>
            <p>
                Une dépendance partielle se produit lorsqu'une colonne non clé dépend d'une partie de la clé primaire (dans le cas de clés composées).
            </p>
        
            <h4>Exemple :</h4>
            <p>Table en 1NF mais pas en 2NF :</p>
            <pre><code>
        Commande   | Article    | Prix
        -----------|------------|-----
        001        | Livre      | 10
        001        | Stylo      | 2
        002        | Cahier     | 5
        003        | Livre      | 10
        003        | Cahier     | 5
            </code></pre>
        
            <p>Problème :</p>
            <ul>
                <li>Le prix d’un article dépend uniquement de l’Article, pas de la commande complète.</li>
            </ul>
        
            <p>Table normalisée en 2NF :</p>
            <pre><code>
        Commande   | Article
        -----------|---------
        001        | Livre
        001        | Stylo
        002        | Cahier
        003        | Livre
        003        | Cahier
        
        Article    | Prix
        -----------|-----
        Livre      | 10
        Stylo      | 2
        Cahier     | 5
            </code></pre>
        
            <h4>Exercice 2 :</h4>
            <p>Normalisez la table suivante en 2NF :</p>
            <pre><code>
        Commande   | Article    | Quantité | Fournisseur
        -----------|------------|----------|------------
        001        | Livre      | 2        | A
        002        | Cahier     | 5        | B
        003        | Stylo      | 1        | A
            </code></pre>
        
            <h3>3NF : Troisième Forme Normale</h3>
            <h4>Définition :</h4>
            <p>
                Une table est en troisième forme normale (3NF) si elle est en 2NF et qu’aucune colonne non clé ne dépend d’une autre colonne non clé (pas de dépendance transitive).
            </p>
        
            <h4>Exemple :</h4>
            <p>Table en 2NF mais pas en 3NF :</p>
            <pre><code>
        Étudiant   | Département  | Chef
        -----------|--------------|-----
        Alice      | Math         | Dr. X
        Bob        | Physique     | Dr. Y
        Charlie    | Math         | Dr. X
            </code></pre>
        
            <p>Problème :</p>
            <ul>
                <li>Le chef de département dépend du département, pas de l’étudiant.</li>
            </ul>
        
            <p>Table normalisée en 3NF :</p>
            <pre><code>
        Étudiant   | Département
        -----------|--------------
        Alice      | Math
        Bob        | Physique
        Charlie    | Math
        
        Département  | Chef
        -------------|--------
        Math         | Dr. X
        Physique     | Dr. Y
            </code></pre>
        
            <h4>Exercice 3 :</h4>
            <p>Normalisez la table suivante en 3NF :</p>
            <pre><code>
        Produit     | Fournisseur  | Ville
        ------------|--------------|--------
        Livre       | A            | Paris
        Cahier      | B            | Lyon
        Stylo       | A            | Paris
            </code></pre>
        
            <h3>Conclusion et Discussion :</h3>
            <p>À la fin de cette séance, les élèves devraient être capables de :</p>
            <ul>
                <li>Identifier les problèmes de redondance et de dépendance dans des tables de bases de données.</li>
                <li>Appliquer les principes des trois premières formes normales (1NF, 2NF, 3NF).</li>
                <li>Expliquer pourquoi la normalisation est importante pour l’intégrité et la maintenance des bases de données.</li>
            </ul>
            <p>
                La discussion pourrait inclure les avantages de la normalisation (cohérence, réduction de la redondance) et ses limites (complexité accrue des requêtes).
            </p>
        </section>

        <section id="session56" class="content-section">
            <h2>Séance 56 : Pratique - Réorganisation d’une base de données pour une meilleure gestion des données</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Les élèves apprendront à analyser une base de données existante, identifier ses problèmes structurels, et appliquer des techniques de normalisation pour améliorer sa gestion. L’objectif est d’optimiser les performances et la cohérence des données.
            </p>
        
            <h3>Contexte du Projet :</h3>
            <p>
                Une base de données pour une bibliothèque contient des informations sur les livres, les abonnés, et les emprunts. Cependant, la structure actuelle pose plusieurs problèmes :
            </p>
            <ul>
                <li>Les données sont redondantes.</li>
                <li>Des anomalies se produisent lors des mises à jour ou des suppressions.</li>
                <li>La recherche d’informations est inefficace.</li>
            </ul>
            <p>
                Les élèves vont réorganiser cette base pour appliquer les principes de la **normalisation** et améliorer sa gestion.
            </p>
        
            <h3>Étape 1 : Analyse de la Base de Données Existante (30 min)</h3>
        
            <h4>Structure actuelle :</h4>
            <p>
                La base est contenue dans une seule table appelée <code>Bibliotheque</code>, avec les colonnes suivantes :
            </p>
            <pre><code>
        ID | NomLivre      | Auteur         | AbonneNom     | AbonneEmail         | DateEmprunt
        --------------------------------------------------------------------------------------
        1  | Python Basics | John Doe       | Alice Dupont  | alice@mail.com      | 2023-01-10
        2  | Python Basics | John Doe       | Bob Martin    | bob@mail.com        | 2023-01-11
        3  | AI Advanced   | Jane Smith     | Alice Dupont  | alice@mail.com      | 2023-01-12
            </code></pre>
        
            <h4>Problèmes observés :</h4>
            <ul>
                <li><strong>Redondance :</strong> Le même livre ou abonné apparaît plusieurs fois.</li>
                <li><strong>Manque de normalisation :</strong> Les informations sur les livres et abonnés sont mélangées.</li>
                <li><strong>Anomalies potentielles :</strong> Modifier l’email d’un abonné nécessite de changer plusieurs lignes.</li>
            </ul>
        
            <h4>Objectifs :</h4>
            <ul>
                <li>Réduire les redondances en divisant la base en plusieurs tables liées.</li>
                <li>Appliquer les principes de la **1ère Forme Normale (1NF)**, **2ème Forme Normale (2NF)**, et **3ème Forme Normale (3NF)**.</li>
            </ul>
        
            <h3>Étape 2 : Réorganisation en Suivant les Formes Normales (40 min)</h3>
        
            <h4>1. Première Forme Normale (1NF) :</h4>
            <p>
                Chaque cellule doit contenir une valeur unique et chaque ligne doit être identifiable de manière unique. Les colonnes <code>NomLivre</code> et <code>AbonneNom</code> contenant des données redondantes doivent être divisées.
            </p>
        
            <h4>Structure après 1NF :</h4>
            <pre><code>
        Livres
        ID_Livre | NomLivre       | Auteur
        -----------------------------------
        1        | Python Basics  | John Doe
        2        | AI Advanced    | Jane Smith
        
        Abonnes
        ID_Abonne | NomAbonne     | Email
        -------------------------------------
        1         | Alice Dupont  | alice@mail.com
        2         | Bob Martin    | bob@mail.com
        
        Emprunts
        ID_Emprunt | ID_Livre | ID_Abonne | DateEmprunt
        -----------------------------------------------
        1           | 1        | 1         | 2023-01-10
        2           | 1        | 2         | 2023-01-11
        3           | 2        | 1         | 2023-01-12
            </code></pre>
        
            <h4>2. Deuxième Forme Normale (2NF) :</h4>
            <p>
                Tous les attributs non-clés doivent dépendre entièrement de la clé primaire. Par exemple, les informations sur les livres ne doivent pas être répétées dans plusieurs lignes.
            </p>
        
            <h4>Structure après 2NF :</h4>
            <p>Pas de changement majeur dans cet exemple, car nous avons déjà séparé les informations en tables liées.</p>
        
            <h4>3. Troisième Forme Normale (3NF) :</h4>
            <p>
                Aucun attribut ne doit dépendre transitivement de la clé primaire. Par exemple, les emails des abonnés ne doivent pas être stockés ailleurs que dans la table des abonnés.
            </p>
            <p>La structure après la 1NF respecte déjà cette règle.</p>
        
            <h3>Étape 3 : Implémentation en SQL (40 min)</h3>
        
            <h4>Création des Tables :</h4>
            <pre><code class="sql">
        CREATE TABLE Livres (
            ID_Livre INT PRIMARY KEY,
            NomLivre VARCHAR(100),
            Auteur VARCHAR(100)
        );
        
        CREATE TABLE Abonnes (
            ID_Abonne INT PRIMARY KEY,
            NomAbonne VARCHAR(100),
            Email VARCHAR(100)
        );
        
        CREATE TABLE Emprunts (
            ID_Emprunt INT PRIMARY KEY,
            ID_Livre INT,
            ID_Abonne INT,
            DateEmprunt DATE,
            FOREIGN KEY (ID_Livre) REFERENCES Livres(ID_Livre),
            FOREIGN KEY (ID_Abonne) REFERENCES Abonnes(ID_Abonne)
        );
            </code></pre>
        
            <h4>Insertion des Données :</h4>
            <pre><code class="sql">
        INSERT INTO Livres (ID_Livre, NomLivre, Auteur) VALUES
        (1, 'Python Basics', 'John Doe'),
        (2, 'AI Advanced', 'Jane Smith');
        
        INSERT INTO Abonnes (ID_Abonne, NomAbonne, Email) VALUES
        (1, 'Alice Dupont', 'alice@mail.com'),
        (2, 'Bob Martin', 'bob@mail.com');
        
        INSERT INTO Emprunts (ID_Emprunt, ID_Livre, ID_Abonne, DateEmprunt) VALUES
        (1, 1, 1, '2023-01-10'),
        (2, 1, 2, '2023-01-11'),
        (3, 2, 1, '2023-01-12');
            </code></pre>
        
            <h4>Requêtes Pratiques :</h4>
            <p>Les élèves devront exécuter des requêtes pour tester la nouvelle structure :</p>
            <ul>
                <li><strong>Afficher tous les livres empruntés :</strong></li>
                <pre><code class="sql">
        SELECT Emprunts.ID_Emprunt, Livres.NomLivre, Abonnes.NomAbonne, Emprunts.DateEmprunt
        FROM Emprunts
        JOIN Livres ON Emprunts.ID_Livre = Livres.ID_Livre
        JOIN Abonnes ON Emprunts.ID_Abonne = Abonnes.ID_Abonne;
                </code></pre>
        
                <li><strong>Modifier l’email d’un abonné :</strong></li>
                <pre><code class="sql">
        UPDATE Abonnes
        SET Email = 'nouvel_email@mail.com'
        WHERE ID_Abonne = 1;
                </code></pre>
            </ul>
        
            <h3>Conclusion :</h3>
            <p>
                À la fin de cette séance, les élèves auront appris à :
            </p>
            <ul>
                <li>Analyser les problèmes d’une base de données existante.</li>
                <li>Appliquer les principes de normalisation pour réduire les redondances et les anomalies.</li>
                <li>Réorganiser une base en utilisant plusieurs tables liées.</li>
                <li>Écrire des requêtes SQL pour manipuler efficacement les données.</li>
            </ul>
            <p>Ce projet montre l'importance de la structure des bases de données pour garantir leur performance et leur fiabilité.</p>
        </section>

        <section id="session57" class="content-section">
            <h2>Séance 57 : Cas pratiques de normalisation dans des projets réels (jeu vidéo, actualité)</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Les élèves apprendront à appliquer les concepts de normalisation dans des bases de données à travers des cas pratiques. 
                Ils verront comment organiser les données efficacement pour éviter la redondance et garantir l'intégrité des données, 
                avec deux scénarios spécifiques : un jeu vidéo et une application d’actualité.
            </p>
        
            <h3>Introduction à la Normalisation (10 min)</h3>
            <p>
                La normalisation est un processus de structuration des tables d’une base de données pour réduire les redondances 
                et améliorer l’intégrité des données. Elle repose sur plusieurs formes normales (FN), parmi lesquelles :
            </p>
            <ul>
                <li><strong>1ère Forme Normale (1FN) :</strong> Toutes les colonnes contiennent des valeurs atomiques.</li>
                <li><strong>2ème Forme Normale (2FN) :</strong> Chaque colonne dépend de la clé primaire.</li>
                <li><strong>3ème Forme Normale (3FN) :</strong> Élimine les dépendances transitives entre colonnes.</li>
            </ul>
        
            <h3>Étape 1 : Cas Pratique - Base de Données pour un Jeu Vidéo (40 min)</h3>
        
            <h4>Contexte :</h4>
            <p>
                Un jeu vidéo contient des personnages, des armes, et des niveaux. Nous devons concevoir une base de données 
                pour stocker ces informations tout en respectant les règles de normalisation.
            </p>
        
            <h4>Exemple Initial Non Normalisé :</h4>
            <pre><code class="sql">
        Table Personnages :
        +----+-------------+--------+-----------------+-------------+
        | ID | Nom         | Niveau | Nom_Arme       | Type_Arme   |
        +----+-------------+--------+-----------------+-------------+
        | 1  | Guerrier    | 10     | Épée Lourde    | Tranchante  |
        | 2  | Archer      | 5      | Arc Long       | Projectile  |
        | 3  | Mage        | 8      | Bâton Magique  | Magique     |
        +----+-------------+--------+-----------------+-------------+
            </code></pre>
        
            <p><strong>Problèmes :</strong></p>
            <ul>
                <li>Les informations sur les armes sont répétées pour chaque personnage.</li>
                <li>Si le type d’arme change, il faut modifier plusieurs lignes, ce qui augmente le risque d’erreur.</li>
            </ul>
        
            <h4>Solution Normalisée :</h4>
            <p>
                Pour normaliser cette base de données, nous allons :
            </p>
            <ul>
                <li>Créer une table pour les personnages avec une clé étrangère vers les armes.</li>
                <li>Créer une table séparée pour les armes avec leurs types.</li>
            </ul>
        
            <h4>Tables Normalisées :</h4>
            <pre><code class="sql">
        Table Personnages :
        +----+-------------+--------+-------+
        | ID | Nom         | Niveau | Arme  |
        +----+-------------+--------+-------+
        | 1  | Guerrier    | 10     | 1     |
        | 2  | Archer      | 5      | 2     |
        | 3  | Mage        | 8      | 3     |
        +----+-------------+--------+-------+
        
        Table Armes :
        +----+-----------------+-------------+
        | ID | Nom_Arme        | Type_Arme   |
        +----+-----------------+-------------+
        | 1  | Épée Lourde     | Tranchante  |
        | 2  | Arc Long        | Projectile  |
        | 3  | Bâton Magique   | Magique     |
        +----+-----------------+-------------+
            </code></pre>
        
            <h4>Avantages :</h4>
            <ul>
                <li>Les informations sur les armes sont centralisées, ce qui réduit les risques d’incohérences.</li>
                <li>Les modifications, comme le changement de type d’arme, sont plus faciles.</li>
                <li>La structure respecte la 3ème Forme Normale (3FN).</li>
            </ul>
        
            <h3>Étape 2 : Cas Pratique - Base de Données pour une Application d’Actualité (40 min)</h3>
        
            <h4>Contexte :</h4>
            <p>
                Une application d’actualité gère des articles, des auteurs et des catégories. 
                Nous devons concevoir une base de données pour organiser ces informations et éviter les redondances.
            </p>
        
            <h4>Exemple Initial Non Normalisé :</h4>
            <pre><code class="sql">
        Table Articles :
        +----+----------------------+----------+-----------+-----------------+
        | ID | Titre               | Auteur   | Catégorie | Description     |
        +----+----------------------+----------+-----------+-----------------+
        | 1  | Nouveaux Jeux Vidéo | Alice    | Technologie | Jeux récents   |
        | 2  | Économie 2025       | Bob      | Finance    | Analyse du PIB |
        | 3  | IA en 2025          | Alice    | Technologie | Innovation IA  |
        +----+----------------------+----------+-----------+-----------------+
            </code></pre>
        
            <p><strong>Problèmes :</strong></p>
            <ul>
                <li>Les noms d’auteurs et de catégories sont répétés.</li>
                <li>Les descriptions des catégories sont redondantes.</li>
            </ul>
        
            <h4>Solution Normalisée :</h4>
            <p>
                Pour normaliser cette base de données, nous allons :
            </p>
            <ul>
                <li>Créer une table pour les articles avec des clés étrangères vers les auteurs et les catégories.</li>
                <li>Créer des tables séparées pour les auteurs et les catégories.</li>
            </ul>
        
            <h4>Tables Normalisées :</h4>
            <pre><code class="sql">
        Table Articles :
        +----+----------------------+--------+----------+
        | ID | Titre               | Auteur | Catégorie|
        +----+----------------------+--------+----------+
        | 1  | Nouveaux Jeux Vidéo | 1      | 1        |
        | 2  | Économie 2025       | 2      | 2        |
        | 3  | IA en 2025          | 1      | 1        |
        +----+----------------------+--------+----------+
        
        Table Auteurs :
        +----+----------+
        | ID | Nom      |
        +----+----------+
        | 1  | Alice    |
        | 2  | Bob      |
        +----+----------+
        
        Table Catégories :
        +----+-------------+-----------------+
        | ID | Nom         | Description     |
        +----+-------------+-----------------+
        | 1  | Technologie | Jeux récents    |
        | 2  | Finance     | Analyse du PIB  |
        +----+-------------+-----------------+
            </code></pre>
        
            <h4>Avantages :</h4>
            <ul>
                <li>Les informations sur les auteurs et les catégories sont centralisées.</li>
                <li>Les données redondantes sont éliminées.</li>
                <li>La structure respecte la 3ème Forme Normale (3FN).</li>
            </ul>
        
            <h3>Conclusion et Discussion (10 min)</h3>
            <p>
                La normalisation est essentielle pour concevoir des bases de données robustes, éviter les redondances et garantir l’intégrité des données. 
                Ces cas pratiques montrent comment appliquer la normalisation dans des projets concrets et réels.
            </p>
            <p>Points de réflexion pour les élèves :</p>
            <ul>
                <li>Quels sont les compromis entre normalisation et performance ?</li>
                <li>Comment dénormaliser pour optimiser certaines requêtes tout en gardant une structure logique ?</li>
            </ul>
        </section>

        <section id="session58" class="content-section">
            <h2>Séance 58 : Introduction à l’indexation et optimisation des bases de données</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Cette séance vise à introduire les concepts fondamentaux de l’indexation et de l’optimisation des bases de données relationnelles. Les élèves apprendront comment l’indexation améliore les performances des requêtes et découvriront des techniques pratiques pour optimiser les bases de données.
            </p>
        
            <h3>Introduction à l’Indexation (30 min)</h3>
        
            <h4>1. Qu’est-ce qu’un index dans une base de données ?</h4>
            <p>
                Un <strong>index</strong> est une structure de données qui accélère les recherches dans une table en fournissant un chemin rapide vers les données. Il fonctionne comme un index dans un livre : au lieu de chercher à chaque page, vous consultez l’index pour localiser directement la section souhaitée.
            </p>
            <ul>
                <li><strong>Utilisation :</strong> Un index est généralement créé sur des colonnes fréquemment utilisées dans les clauses <code>WHERE</code> ou <code>JOIN</code>.</li>
                <li><strong>Avantages :</strong> Réduction du temps de recherche.</li>
                <li><strong>Inconvénients :</strong> Consommation supplémentaire d’espace disque et de temps lors des insertions, mises à jour et suppressions.</li>
            </ul>
        
            <h4>2. Comment fonctionne un index ?</h4>
            <p>
                Les bases de données utilisent souvent des structures comme les <strong>B-trees</strong> ou les <strong>hash maps</strong> pour implémenter des index.
            </p>
            <ul>
                <li>Les B-trees permettent des recherches rapides en maintenant les données triées.</li>
                <li>Les hash maps permettent des recherches rapides sur des valeurs exactes, mais sont moins efficaces pour des plages de valeurs.</li>
            </ul>
        
            <h4>3. Exemple d’utilisation d’un index :</h4>
            <pre><code class="sql">
        -- Création d’un index sur une colonne
        CREATE INDEX idx_nom_sur_table_employes ON employes(nom);
        
        -- Exemple de requête utilisant l’index
        SELECT * FROM employes WHERE nom = 'Dupont';
            </code></pre>
        
            <p>Dans cet exemple, l’index sur la colonne <code>nom</code> accélère les recherches par rapport à une recherche classique.</p>
        
            <h3>Optimisation des Bases de Données (30 min)</h3>
        
            <h4>1. Techniques d’optimisation :</h4>
            <ul>
                <li><strong>Analyse des requêtes :</strong> Utilisez des outils comme <code>EXPLAIN</code> ou <code>ANALYZE</code> pour comprendre comment une requête est exécutée.</li>
                <li><strong>Indexation stratégique :</strong> Créez des index uniquement sur les colonnes utilisées dans des recherches fréquentes.</li>
                <li><strong>Normalisation :</strong> Réduisez la redondance des données en suivant les formes normales (1NF, 2NF, 3NF, etc.).</li>
                <li><strong>Désnormalisation :</strong> Ajoutez des redondances pour optimiser les lectures dans certains cas spécifiques.</li>
                <li><strong>Requêtes optimisées :</strong> Évitez les requêtes inutiles ou redondantes, utilisez des jointures efficaces et des sous-requêtes judicieuses.</li>
            </ul>
        
            <h4>2. Exemple avec l’analyse d’une requête :</h4>
            <pre><code class="sql">
        -- Requête simple
        SELECT * FROM employes WHERE salaire > 50000;
        
        -- Analyse de la requête
        EXPLAIN SELECT * FROM employes WHERE salaire > 50000;
        
        -- Résultat (exemple simplifié)
        -- Utilisation d'un scan complet si aucun index n'existe sur 'salaire'.
        -- Ajout d'un index pour optimiser :
        CREATE INDEX idx_salaire ON employes(salaire);
            </code></pre>
        
            <p>Avec l’index <code>idx_salaire</code>, la base de données peut réduire significativement le temps de traitement de la requête.</p>
        
            <h3>Étape Pratique : Implémentation et Analyse d’Index (40 min)</h3>
        
            <h4>Exercice :</h4>
            <p>Les élèves travailleront sur une table fictive <code>produits</code>, contenant les colonnes suivantes :</p>
            <ul>
                <li><code>id</code> : Identifiant unique.</li>
                <li><code>nom</code> : Nom du produit.</li>
                <li><code>prix</code> : Prix du produit.</li>
                <li><code>categorie</code> : Catégorie du produit.</li>
            </ul>
        
            <h4>Tâches :</h4>
            <ol>
                <li>Créer un index sur la colonne <code>categorie</code> pour accélérer les recherches par catégorie.</li>
                <li>Analyser une requête sans index et avec index pour observer la différence de performances.</li>
                <li>Ajouter un index sur la colonne <code>prix</code> pour optimiser les recherches de produits dans une plage de prix.</li>
            </ol>
        
            <h4>Implémentation :</h4>
            <pre><code class="sql">
        -- Création de la table
        CREATE TABLE produits (
            id INT PRIMARY KEY,
            nom VARCHAR(100),
            prix DECIMAL(10, 2),
            categorie VARCHAR(50)
        );
        
        -- Insertion de données fictives
        INSERT INTO produits (id, nom, prix, categorie) VALUES
        (1, 'Téléphone', 699.99, 'Électronique'),
        (2, 'Tablette', 499.99, 'Électronique'),
        (3, 'Chaise', 89.99, 'Mobilier'),
        (4, 'Table', 199.99, 'Mobilier'),
        (5, 'Ordinateur', 999.99, 'Électronique');
        
        -- Requête initiale sans index
        EXPLAIN SELECT * FROM produits WHERE categorie = 'Électronique';
        
        -- Création d’un index sur la colonne 'categorie'
        CREATE INDEX idx_categorie ON produits(categorie);
        
        -- Requête après indexation
        EXPLAIN SELECT * FROM produits WHERE categorie = 'Électronique';
            </code></pre>
        
            <h4>Analyse attendue :</h4>
            <ul>
                <li>Les élèves remarqueront que l’utilisation de l’index réduit le temps de recherche en éliminant les scans complets de la table.</li>
                <li>Ils pourront observer dans le plan d’exécution que l’index est utilisé.</li>
            </ul>
        
            <h3>Discussion et Conclusion (20 min)</h3>
        
            <h4>Points Clés :</h4>
            <ul>
                <li>Les index sont essentiels pour améliorer les performances des bases de données, mais ils ont un coût en espace disque et en temps de mise à jour.</li>
                <li>Il est important de créer des index uniquement là où ils apportent une réelle valeur ajoutée.</li>
                <li>La normalisation et la désnormalisation sont des outils complémentaires pour optimiser les bases de données en fonction des besoins.</li>
            </ul>
        
            <h4>Questions pour les élèves :</h4>
            <ul>
                <li>Quels types de colonnes bénéficient le plus des index ?</li>
                <li>Quels sont les inconvénients de l’utilisation excessive d’index ?</li>
                <li>Comment choisir entre normalisation et désnormalisation ?</li>
            </ul>
        
            <p>
                À la fin de cette séance, les élèves seront capables de comprendre le rôle des index dans les bases de données, de les créer et de les analyser pour optimiser les performances des requêtes.
            </p>
        </section>

        <section id="session59" class="content-section">
            <h2>Séance 59 : Pratique - Amélioration de la performance des requêtes SQL avec indexation</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Les élèves apprendront à utiliser les index pour améliorer la performance des requêtes SQL. Cette séance mettra en pratique l’impact de l’indexation sur des requêtes courantes et expliquera comment et quand utiliser des index efficacement.
            </p>
        
            <h3>Introduction : L'importance de l’indexation (15 min)</h3>
            <h4>Qu’est-ce qu’un index en base de données ?</h4>
            <p>
                Un index est une structure de données qui permet d’accélérer les opérations de recherche dans une table. C’est un peu comme un index dans un livre, qui vous permet de trouver rapidement la page correspondant à un mot clé.
            </p>
            <ul>
                <li>Sans index : La base de données doit parcourir toute la table pour trouver les données (recherche dite "full table scan").</li>
                <li>Avec index : La base de données peut localiser rapidement les lignes correspondantes grâce à l’index.</li>
            </ul>
        
            <h4>Types d'index courants :</h4>
            <ul>
                <li><strong>Index unique :</strong> Garantit l’unicité des valeurs dans une colonne (exemple : clés primaires).</li>
                <li><strong>Index normal :</strong> Accélère la recherche mais ne garantit pas l’unicité.</li>
                <li><strong>Index composite :</strong> Porte sur plusieurs colonnes.</li>
            </ul>
        
            <h4>Quand utiliser un index ?</h4>
            <ul>
                <li>Pour accélérer les recherches sur des colonnes souvent utilisées dans les requêtes <code>SELECT</code> ou <code>WHERE</code>.</li>
                <li>Pour améliorer les performances des jointures.</li>
                <li>Pour optimiser le tri avec <code>ORDER BY</code>.</li>
            </ul>
        
            <h3>Étape 1 : Préparation de la Table (15 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Créez une table appelée <code>Produits</code> avec un grand nombre d’enregistrements pour observer l’impact de l’indexation.
            </p>
        
            <h4>Script SQL pour créer la table :</h4>
            <pre><code class="sql">
        CREATE TABLE Produits (
            id INT PRIMARY KEY AUTO_INCREMENT,
            nom VARCHAR(255) NOT NULL,
            categorie VARCHAR(100),
            prix DECIMAL(10, 2),
            stock INT
        );
        
        -- Insérer des données aléatoires
        INSERT INTO Produits (nom, categorie, prix, stock)
        VALUES
        ('Produit 1', 'Catégorie A', 10.99, 50),
        ('Produit 2', 'Catégorie B', 15.99, 20),
        ('Produit 3', 'Catégorie A', 5.49, 0),
        ('Produit 4', 'Catégorie C', 7.99, 100),
        ('Produit 5', 'Catégorie B', 12.99, 75);
        
        -- Répéter les données pour simuler un grand nombre de lignes
        -- (Vous pouvez utiliser un script ou une boucle pour générer 10 000 enregistrements)
            </code></pre>
        
            <h3>Étape 2 : Mesurer les Performances sans Index (15 min)</h3>
        
            <h4>Exercice :</h4>
            <p>Exécutez les requêtes suivantes et mesurez leur temps d'exécution :</p>
            <ul>
                <li>Rechercher un produit par nom :</li>
                <pre><code class="sql">
        SELECT * FROM Produits WHERE nom = 'Produit 1';
                </code></pre>
                <li>Rechercher des produits par catégorie :</li>
                <pre><code class="sql">
        SELECT * FROM Produits WHERE categorie = 'Catégorie A';
                </code></pre>
            </ul>
            <p>
                Observez le temps pris pour chaque requête et notez que sans index, la base effectue un scan complet de la table.
            </p>
        
            <h3>Étape 3 : Ajouter des Index (15 min)</h3>
        
            <h4>Exercice :</h4>
            <p>Ajoutez des index sur les colonnes utilisées dans les requêtes précédentes.</p>
            <h4>Script SQL :</h4>
            <pre><code class="sql">
        -- Ajouter un index sur la colonne 'nom'
        CREATE INDEX idx_nom ON Produits(nom);
        
        -- Ajouter un index sur la colonne 'categorie'
        CREATE INDEX idx_categorie ON Produits(categorie);
            </code></pre>
        
            <h4>Requêtes après ajout des index :</h4>
            <ul>
                <li>Rechercher un produit par nom :</li>
                <pre><code class="sql">
        SELECT * FROM Produits WHERE nom = 'Produit 1';
                </code></pre>
                <li>Rechercher des produits par catégorie :</li>
                <pre><code class="sql">
        SELECT * FROM Produits WHERE categorie = 'Catégorie A';
                </code></pre>
            </ul>
            <p>
                Mesurez à nouveau le temps d’exécution de ces requêtes. Vous devriez observer une nette amélioration grâce à l’indexation.
            </p>
        
            <h3>Étape 4 : Utilisation d’Index Composites (15 min)</h3>
        
            <h4>Exercice :</h4>
            <p>Ajoutez un index composite pour optimiser les recherches combinant plusieurs colonnes.</p>
            <h4>Script SQL :</h4>
            <pre><code class="sql">
        -- Ajouter un index composite sur 'categorie' et 'prix'
        CREATE INDEX idx_categorie_prix ON Produits(categorie, prix);
        
        -- Requête utilisant l'index composite
        SELECT * FROM Produits WHERE categorie = 'Catégorie A' AND prix < 20;
            </code></pre>
            <p>
                Observez comment l’index composite réduit le temps de recherche pour les requêtes multi-colonnes.
            </p>
        
            <h3>Étape 5 : Analyse et Visualisation des Index (15 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Utilisez la commande <code>EXPLAIN</code> pour analyser comment la base de données utilise les index.
            </p>
            <h4>Exemple :</h4>
            <pre><code class="sql">
        EXPLAIN SELECT * FROM Produits WHERE categorie = 'Catégorie A';
            </code></pre>
            <p>
                Analysez les colonnes <code>key</code> et <code>possible_keys</code> pour vérifier si l’index est utilisé.
            </p>
        
            <h3>Conclusion :</h3>
            <ul>
                <li>Les index sont essentiels pour optimiser les performances des requêtes, en particulier sur de grandes tables.</li>
                <li>Bien que les index accélèrent les requêtes, ils peuvent ralentir les opérations d’insertion et de mise à jour. Utilisez-les avec modération et pertinence.</li>
                <li>La commande <code>EXPLAIN</code> est un outil puissant pour analyser et optimiser les requêtes SQL.</li>
            </ul>
        </section>

        <section id="session60" class="content-section">
            <h2>Séance 60 : Étude de cas sur les performances des bases de données dans un projet</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Les élèves exploreront les performances des bases de données en étudiant les facteurs qui influencent leur efficacité. Cette séance est basée sur un projet concret qui simule un système de gestion d’utilisateurs dans une application, avec une analyse des performances pour différentes configurations et requêtes.
            </p>
        
            <h3>Contexte du Projet :</h3>
            <p>
                Le projet consiste à gérer une base de données d’utilisateurs pour une application fictive. Les élèves analyseront les performances des opérations courantes, telles que :
            </p>
            <ul>
                <li>Insertion de données massives.</li>
                <li>Recherches avec et sans index.</li>
                <li>Requêtes complexes impliquant des jointures.</li>
            </ul>
            <p>
                Ils découvriront les meilleures pratiques pour optimiser les performances des bases de données relationnelles et identifieront les compromis entre performance et flexibilité.
            </p>
        
            <h3>Étape 1 : Mise en Place de la Base de Données (30 min)</h3>
        
            <h4>Exercice :</h4>
            <p>Créez une base de données SQLite pour gérer les utilisateurs. La table <code>Utilisateurs</code> doit inclure les colonnes suivantes :</p>
            <ul>
                <li><code>id</code> : Identifiant unique (clé primaire).</li>
                <li><code>nom</code> : Nom de l’utilisateur.</li>
                <li><code>email</code> : Adresse email (unique).</li>
                <li><code>date_inscription</code> : Date d’inscription.</li>
            </ul>
        
            <h4>Code d’Implémentation :</h4>
            <pre><code class="python">
        import sqlite3
        
        # Création de la base de données et de la table
        conn = sqlite3.connect("utilisateurs.db")
        cursor = conn.cursor()
        
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS Utilisateurs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            nom TEXT NOT NULL,
            email TEXT UNIQUE NOT NULL,
            date_inscription DATE NOT NULL
        )
        """)
        conn.commit()
        print("Table Utilisateurs créée.")
        conn.close()
            </code></pre>
        
            <h4>Test :</h4>
            <p>
                Vérifiez que la base de données et la table sont correctement créées en réexécutant le script et en inspectant la structure de la table.
            </p>
        
            <h3>Étape 2 : Insertion Massive et Analyse des Performances (30 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Insérez un grand nombre d’utilisateurs dans la table <code>Utilisateurs</code> (par exemple, 100 000) et mesurez le temps nécessaire pour les insérer. Comparez les performances avec et sans utilisation d’une transaction.
            </p>
        
            <h4>Code pour Insertion avec Analyse de Temps :</h4>
            <pre><code class="python">
        import sqlite3
        import time
        from datetime import datetime
        import random
        
        # Générer des noms et emails aléatoires
        def generer_donnees(n):
            utilisateurs = []
            for i in range(n):
                nom = f"Utilisateur_{i}"
                email = f"user_{i}@example.com"
                date_inscription = datetime.now().strftime("%Y-%m-%d")
                utilisateurs.append((nom, email, date_inscription))
            return utilisateurs
        
        # Insérer des utilisateurs sans transaction
        def insertion_sans_transaction(data):
            conn = sqlite3.connect("utilisateurs.db")
            cursor = conn.cursor()
            debut = time.time()
            for utilisateur in data:
                cursor.execute("INSERT INTO Utilisateurs (nom, email, date_inscription) VALUES (?, ?, ?)", utilisateur)
            conn.commit()
            fin = time.time()
            conn.close()
            print(f"Insertion sans transaction : {fin - debut:.2f} secondes")
        
        # Insérer des utilisateurs avec transaction
        def insertion_avec_transaction(data):
            conn = sqlite3.connect("utilisateurs.db")
            cursor = conn.cursor()
            debut = time.time()
            cursor.executemany("INSERT INTO Utilisateurs (nom, email, date_inscription) VALUES (?, ?, ?)", data)
            conn.commit()
            fin = time.time()
            conn.close()
            print(f"Insertion avec transaction : {fin - debut:.2f} secondes")
        
        # Générer et insérer des données
        data = generer_donnees(100000)
        insertion_sans_transaction(data)  # Sans transaction
        insertion_avec_transaction(data)  # Avec transaction
            </code></pre>
        
            <h4>Analyse :</h4>
            <p>
                Comparez les temps d’insertion et discutez de l’importance des transactions pour améliorer les performances des bases de données.
            </p>
        
            <h3>Étape 3 : Recherches et Indexation (30 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Effectuez des recherches sur la table <code>Utilisateurs</code> pour trouver des utilisateurs par email. Mesurez les temps de recherche avec et sans index sur la colonne <code>email</code>.
            </p>
        
            <h4>Code pour la Recherche et l’Indexation :</h4>
            <pre><code class="python">
        import sqlite3
        import time
        
        # Rechercher un utilisateur par email
        def rechercher_par_email(email):
            conn = sqlite3.connect("utilisateurs.db")
            cursor = conn.cursor()
            debut = time.time()
            cursor.execute("SELECT * FROM Utilisateurs WHERE email = ?", (email,))
            result = cursor.fetchone()
            fin = time.time()
            conn.close()
            print(f"Temps de recherche : {fin - debut:.6f} secondes")
            return result
        
        # Ajouter un index sur la colonne email
        def ajouter_index():
            conn = sqlite3.connect("utilisateurs.db")
            cursor = conn.cursor()
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_email ON Utilisateurs (email)")
            conn.commit()
            conn.close()
            print("Index ajouté sur la colonne email.")
        
        # Test de recherche avec et sans index
        email_test = "user_50000@example.com"
        print("Recherche sans index :")
        rechercher_par_email(email_test)
        
        ajouter_index()  # Ajouter un index
        print("Recherche avec index :")
        rechercher_par_email(email_test)
            </code></pre>
        
            <h4>Analyse :</h4>
            <p>
                Comparez les temps de recherche avec et sans index. Discutez de l’importance des index pour optimiser les recherches dans les bases de données.
            </p>
        
            <h3>Étape 4 : Jointures et Requêtes Complexes (30 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Ajoutez une nouvelle table <code>Achats</code> pour suivre les achats des utilisateurs, puis effectuez des jointures pour afficher les utilisateurs et leurs achats. Analysez les performances des jointures.
            </p>
        
            <h4>Code pour les Jointures :</h4>
            <pre><code class="python">
        # Création de la table Achats
        def creer_table_achats():
            conn = sqlite3.connect("utilisateurs.db")
            cursor = conn.cursor()
            cursor.execute("""
            CREATE TABLE IF NOT EXISTS Achats (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                utilisateur_id INTEGER NOT NULL,
                montant REAL NOT NULL,
                date_achat DATE NOT NULL,
                FOREIGN KEY(utilisateur_id) REFERENCES Utilisateurs(id)
            )
            """)
            conn.commit()
            conn.close()
            print("Table Achats créée.")
        
        # Insertion d'achats
        def inserer_achats():
            conn = sqlite3.connect("utilisateurs.db")
            cursor = conn.cursor()
            achats = [(random.randint(1, 100000), random.uniform(10, 500), datetime.now().strftime("%Y-%m-%d")) for _ in range(10000)]
            cursor.executemany("INSERT INTO Achats (utilisateur_id, montant, date_achat) VALUES (?, ?, ?)", achats)
            conn.commit()
            conn.close()
            print("Achats insérés.")
        
        # Jointure pour afficher les utilisateurs et leurs achats
        def jointure_utilisateurs_achats():
            conn = sqlite3.connect("utilisateurs.db")
            cursor = conn.cursor()
            debut = time.time()
            cursor.execute("""
            SELECT Utilisateurs.nom, Utilisateurs.email, Achats.montant, Achats.date_achat
            FROM Utilisateurs
            INNER JOIN Achats ON Utilisateurs.id = Achats.utilisateur_id
            """)
            resultats = cursor.fetchall()
            fin = time.time()
            conn.close()
            print(f"Temps de jointure : {fin - debut:.2f} secondes")
            for resultat in resultats[:10]:
                print(resultat)
        
        # Exécution
        creer_table_achats()
        inserer_achats()
        jointure_utilisateurs_achats()
            </code></pre>
        
            <h4>Analyse :</h4>
            <p>
                Discutez de l’impact des jointures sur les performances et des moyens d’optimiser les requêtes complexes.
            </p>
        
            <h3>Conclusion :</h3>
            <p>
                Cette séance montre comment les facteurs tels que les transactions, les index et les jointures influencent les performances des bases de données. Les élèves auront appris à analyser et optimiser les bases de données dans un contexte réaliste, en mettant l'accent sur les bonnes pratiques.
            </p>
        </section>

        <section id="session61" class="content-section">
            <h2>Séance 61 : Introduction à la Cryptographie - Chiffrement Symétrique</h2>
        
            <h3>Objectif Global :</h3>
            <p>Comprendre les bases de la cryptographie et découvrir le chiffrement symétrique. Les élèves apprendront les concepts fondamentaux, suivis d’une mise en pratique pour chiffrer et déchiffrer des messages en utilisant des algorithmes simples.</p>
        
            <h3>1. Introduction à la Cryptographie (20 min)</h3>
            <h4>Qu’est-ce que la cryptographie ?</h4>
            <p>
                La cryptographie est l’art et la science de protéger les informations en les rendant illisibles pour les personnes non autorisées. Elle est utilisée pour garantir la confidentialité, l’intégrité et l’authenticité des données.
            </p>
        
            <h4>Applications Pratiques :</h4>
            <ul>
                <li>Sécuriser les communications (emails, messageries).</li>
                <li>Protéger les transactions bancaires en ligne.</li>
                <li>Authentifier des utilisateurs et des systèmes.</li>
            </ul>
        
            <h4>Types de Cryptographie :</h4>
            <p>
                La cryptographie se divise en deux grandes catégories :
            </p>
            <ul>
                <li><strong>Chiffrement symétrique :</strong> Une même clé est utilisée pour chiffrer et déchiffrer un message.</li>
                <li><strong>Chiffrement asymétrique :</strong> Une paire de clés (publique et privée) est utilisée. Ce type sera abordé dans une séance ultérieure.</li>
            </ul>
        
            <h4>Focus sur le Chiffrement Symétrique :</h4>
            <p>
                Le chiffrement symétrique est simple et rapide. Il est idéal pour des systèmes où les deux parties peuvent partager une clé secrète.
            </p>
            <p>Exemple d’algorithme : le chiffrement par substitution ou le chiffrement de César.</p>
        
            <h3>2. Chiffrement de César (30 min)</h3>
            <h4>Principe :</h4>
            <p>
                Le chiffrement de César est une méthode classique où chaque lettre du message est décalée d’un certain nombre de positions dans l’alphabet.
            </p>
            <p>Par exemple, avec un décalage de 3 :</p>
            <ul>
                <li><code>A</code> devient <code>D</code>, <code>B</code> devient <code>E</code>, et ainsi de suite.</li>
            </ul>
        
            <h4>Implémentation de Base :</h4>
            <pre><code class="python">
        def chiffrer_cesar(message, cle):
            resultat = ""
            for caractere in message:
                if caractere.isalpha():  # Vérifie si c'est une lettre
                    base = ord('A') if caractere.isupper() else ord('a')
                    decalage = (ord(caractere) - base + cle) % 26
                    resultat += chr(base + decalage)
                else:
                    resultat += caractere  # Garde les caractères non alphabétiques inchangés
            return resultat
        
        def dechiffrer_cesar(message, cle):
            return chiffrer_cesar(message, -cle)
        
        # Exemple d'utilisation
        message = "Bonjour tout le monde"
        cle = 3
        
        message_chiffre = chiffrer_cesar(message, cle)
        print("Message chiffré :", message_chiffre)
        
        message_dechiffre = dechiffrer_cesar(message_chiffre, cle)
        print("Message déchiffré :", message_dechiffre)
            </code></pre>
        
            <h4>Exercice Pratique :</h4>
            <p>
                Implémentez un programme qui demande à l’utilisateur de saisir un message et une clé, puis :
            </p>
            <ul>
                <li>Chiffre le message en utilisant le chiffrement de César.</li>
                <li>Déchiffre le message pour retrouver le texte original.</li>
            </ul>
        
            <h3>3. Chiffrement Symétrique Avancé avec une Bibliothèque (40 min)</h3>
        
            <h4>Utilisation de la Bibliothèque <code>cryptography</code> :</h4>
            <p>
                Python propose des bibliothèques puissantes comme <code>cryptography</code> pour des implémentations modernes de chiffrement symétrique, telles que l’AES (Advanced Encryption Standard).
            </p>
        
            <h4>Installation :</h4>
            <p>Assurez-vous d’avoir installé la bibliothèque :</p>
            <pre><code>pip install cryptography</code></pre>
        
            <h4>Exemple de Chiffrement avec AES :</h4>
            <pre><code class="python">
        from cryptography.fernet import Fernet
        
        # Générer une clé et l'enregistrer
        cle = Fernet.generate_key()
        chiffreur = Fernet(cle)
        
        # Message à chiffrer
        message = "Ceci est un message secret"
        message_bytes = message.encode()
        
        # Chiffrement
        message_chiffre = chiffreur.encrypt(message_bytes)
        print("Message chiffré :", message_chiffre)
        
        # Déchiffrement
        message_dechiffre = chiffreur.decrypt(message_chiffre).decode()
        print("Message déchiffré :", message_dechiffre)
            </code></pre>
        
            <h4>Exercice Pratique :</h4>
            <ul>
                <li>Générez une clé et sauvegardez-la dans un fichier pour la réutiliser.</li>
                <li>Créez un programme qui chiffre un message et l’enregistre dans un fichier.</li>
                <li>Ajoutez une fonctionnalité pour lire un fichier chiffré et le déchiffrer.</li>
            </ul>
        
            <h3>4. Conclusion et Discussion (10 min)</h3>
            <ul>
                <li>Le chiffrement symétrique est rapide mais nécessite un partage sécurisé de la clé.</li>
                <li>Des algorithmes simples comme le chiffrement de César aident à comprendre les bases, tandis que des bibliothèques modernes offrent une sécurité robuste pour des applications réelles.</li>
                <li>Discussion : Quels sont les avantages et les inconvénients du chiffrement symétrique ? Dans quels cas utiliseriez-vous cette méthode ?</li>
            </ul>
        </section>

        <section id="session62" class="content-section">
            <h2>Séance 62 : Pratique - Implémentation d’un chiffrement simple pour protéger les données d’un jeu vidéo</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Les élèves apprendront à implémenter un chiffrement simple pour protéger les données sensibles d’un jeu vidéo (par exemple : scores, informations de joueur ou configurations). Cette séance vise à introduire des concepts de cryptographie pratique et leur application dans un contexte ludique.
            </p>
        
            <h3>Contexte :</h3>
            <p>
                Imaginez un jeu vidéo où les scores des joueurs et leurs données personnelles sont enregistrés dans un fichier. Pour empêcher la triche ou la modification non autorisée des données, il est nécessaire de les protéger en les chiffrant.
            </p>
            <ul>
                <li><strong>Chiffrement :</strong> Transformer les données pour qu’elles soient illisibles sans une clé.</li>
                <li><strong>Déchiffrement :</strong> Reconvertir les données chiffrées en leur forme lisible en utilisant la clé correcte.</li>
            </ul>
        
            <h3>Étape 1 : Comprendre le Chiffrement Simple (30 min)</h3>
        
            <h4>Introduction :</h4>
            <p>
                Pour cette séance, nous allons utiliser un chiffrement par substitution basé sur un décalage, appelé <strong>chiffrement de César</strong>. Chaque caractère d’un texte est remplacé par un autre caractère situé à un nombre fixe de positions dans l’alphabet.
            </p>
        
            <h4>Exemple :</h4>
            <p>Avec un décalage de 3 :</p>
            <ul>
                <li>Le caractère <code>A</code> devient <code>D</code>.</li>
                <li>Le mot <code>JEU</code> devient <code>MHX</code>.</li>
                <li>Le déchiffrement inverse cette transformation.</li>
            </ul>
        
            <h4>Fonctions Python :</h4>
            <p>Voici comment coder un chiffrement et un déchiffrement basiques :</p>
            <pre><code class="python">
        def chiffrer_cesar(texte, decalage):
            resultat = ""
            for caractere in texte:
                if caractere.isalpha():  # Vérifie si c'est une lettre
                    base = ord('A') if caractere.isupper() else ord('a')
                    resultat += chr((ord(caractere) - base + decalage) % 26 + base)
                else:
                    resultat += caractere  # Conserve les autres caractères (espaces, chiffres)
            return resultat
        
        def dechiffrer_cesar(texte, decalage):
            return chiffrer_cesar(texte, -decalage)
        
        # Test
        message = "BONJOUR"
        message_chiffre = chiffrer_cesar(message, 3)
        print("Message chiffré :", message_chiffre)  # EONMRXU
        message_dechiffre = dechiffrer_cesar(message_chiffre, 3)
        print("Message déchiffré :", message_dechiffre)  # BONJOUR
            </code></pre>
        
            <h3>Étape 2 : Application au Jeu Vidéo (40 min)</h3>
        
            <h4>Contexte Pratique :</h4>
            <p>
                Dans un jeu vidéo, les données sensibles à protéger pourraient inclure :
            </p>
            <ul>
                <li>Le nom des joueurs.</li>
                <li>Leurs scores.</li>
                <li>Les paramètres de configuration (niveau de difficulté, progression).</li>
            </ul>
            <p>Nous allons créer un programme pour chiffrer et enregistrer ces données dans un fichier, puis les déchiffrer pour les lire.</p>
        
            <h4>Exercice :</h4>
            <p>
                Implémentez une classe <code>GestionDonnees</code> avec les fonctionnalités suivantes :
            </p>
            <ul>
                <li><code>chiffrer_donnees</code> : Chiffre les données d’un joueur.</li>
                <li><code>dechiffrer_donnees</code> : Déchiffre les données chiffrées.</li>
                <li><code>enregistrer_donnees</code> : Sauvegarde les données chiffrées dans un fichier.</li>
                <li><code>lire_donnees</code> : Lit les données d’un fichier et les déchiffre.</li>
            </ul>
        
            <h4>Implémentation :</h4>
            <pre><code class="python">
        class GestionDonnees:
            def __init__(self, cle_decalage):
                self.cle = cle_decalage  # Clé utilisée pour le chiffrement
        
            def chiffrer_donnees(self, texte):
                resultat = ""
                for caractere in texte:
                    if caractere.isalpha():
                        base = ord('A') if caractere.isupper() else ord('a')
                        resultat += chr((ord(caractere) - base + self.cle) % 26 + base)
                    else:
                        resultat += caractere
                return resultat
        
            def dechiffrer_donnees(self, texte):
                return self.chiffrer_donnees(texte, -self.cle)
        
            def enregistrer_donnees(self, nom_fichier, donnees):
                with open(nom_fichier, "w") as fichier:
                    fichier.write(self.chiffrer_donnees(donnees))
        
            def lire_donnees(self, nom_fichier):
                with open(nom_fichier, "r") as fichier:
                    donnees_chiffrees = fichier.read()
                return self.dechiffrer_donnees(donnees_chiffrees)
        
        # Utilisation
        gestion = GestionDonnees(3)
        nom_joueur = "Alice"
        score = "1500"
        
        donnees = f"Joueur: {nom_joueur}, Score: {score}"
        gestion.enregistrer_donnees("donnees.txt", donnees)
        
        donnees_recuperees = gestion.lire_donnees("donnees.txt")
        print("Données récupérées :", donnees_recuperees)
            </code></pre>
        
            <h3>Étape 3 : Extension (30 min)</h3>
        
            <h4>Challenge :</h4>
            <p>
                Les élèves doivent améliorer le programme en :
            </p>
            <ul>
                <li>Ajoutant une protection par mot de passe pour déchiffrer les données.</li>
                <li>Permettant de chiffrer plusieurs joueurs dans un fichier JSON.</li>
            </ul>
        
            <h4>Exemple de format JSON :</h4>
            <pre><code class="json">
        {
            "joueurs": [
                {"nom": "Alice", "score": "1500"},
                {"nom": "Bob", "score": "2000"}
            ]
        }
            </code></pre>
        
            <h4>Discussion :</h4>
            <p>Pourquoi le chiffrement est-il essentiel dans les jeux vidéo (anti-triche, confidentialité) ? Quels sont ses avantages et limites ?</p>
        
            <h3>Conclusion :</h3>
            <p>
                À la fin de cette séance, les élèves sauront :
            </p>
            <ul>
                <li>Implémenter un chiffrement simple avec Python.</li>
                <li>Appliquer ce chiffrement pour protéger des données sensibles dans un jeu.</li>
                <li>Utiliser des concepts de cryptographie pratique dans un contexte ludique.</li>
            </ul>
        </section>

        <section id="session63" class="content-section">
            <h2>Séance 63 : Algorithmes de chiffrement asymétrique (RSA)</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Les élèves apprendront le fonctionnement de l’algorithme de chiffrement asymétrique RSA, son importance en cryptographie, et comment l’implémenter dans un contexte simplifié. Cette séance combine théorie et pratique pour explorer les concepts de clés publiques/privées et leur utilisation pour sécuriser les communications.
            </p>
        
            <h3>1. Introduction au Chiffrement Asymétrique (20 min)</h3>
            <p>
                Le chiffrement asymétrique est une méthode de cryptographie où deux clés distinctes sont utilisées :
            </p>
            <ul>
                <li><strong>Clé publique :</strong> utilisée pour chiffrer les données. Elle est accessible à tous.</li>
                <li><strong>Clé privée :</strong> utilisée pour déchiffrer les données. Elle est gardée secrète.</li>
            </ul>
        
            <h4>Pourquoi RSA ?</h4>
            <p>RSA (Rivest-Shamir-Adleman) est l’un des premiers algorithmes de chiffrement asymétrique et reste largement utilisé pour sécuriser les communications en ligne, comme dans HTTPS.</p>
        
            <h4>Principe de RSA :</h4>
            <ol>
                <li>Deux nombres premiers très grands (<code>p</code> et <code>q</code>) sont choisis pour générer les clés.</li>
                <li>Une clé publique (<code>e, n</code>) est utilisée pour chiffrer les messages.</li>
                <li>Une clé privée (<code>d, n</code>) est utilisée pour déchiffrer les messages.</li>
            </ol>
        
            <p><strong>Formules importantes :</strong></p>
            <ul>
                <li><code>n = p × q</code></li>
                <li><code>φ(n) = (p - 1) × (q - 1)</code> (fonction indicatrice d’Euler)</li>
                <li><code>e</code> : un entier tel que <code>1 < e < φ(n)</code> et <code>e</code> soit copremier avec <code>φ(n)</code>.</li>
                <li><code>d</code> : l’inverse modulaire de <code>e</code> modulo <code>φ(n)</code>.</li>
            </ul>
        
            <h3>2. Implémentation Simplifiée de RSA (40 min)</h3>
        
            <h4>Étape 1 : Génération des Clés</h4>
            <pre><code class="python">
        import random
        from math import gcd
        
        # Générer un nombre premier simple
        def est_premier(n):
            if n < 2:
                return False
            for i in range(2, int(n ** 0.5) + 1):
                if n % i == 0:
                    return False
            return True
        
        def generer_premier():
            while True:
                nombre = random.randint(10, 50)  # Petit intervalle pour simplifier
                if est_premier(nombre):
                    return nombre
        
        # Génération des clés RSA
        def generer_cles():
            p = generer_premier()
            q = generer_premier()
            while q == p:  # S'assurer que p != q
                q = generer_premier()
        
            n = p * q
            phi = (p - 1) * (q - 1)
        
            # Trouver e (copremier avec phi)
            e = random.randint(2, phi - 1)
            while gcd(e, phi) != 1:
                e = random.randint(2, phi - 1)
        
            # Calculer d (l'inverse modulaire de e mod phi)
            d = pow(e, -1, phi)
        
            return (e, n), (d, n)  # Clé publique, Clé privée
        
        # Générer les clés
        cle_publique, cle_privee = generer_cles()
        print("Clé publique :", cle_publique)
        print("Clé privée :", cle_privee)
            </code></pre>
        
            <h4>Étape 2 : Chiffrement et Déchiffrement</h4>
            <pre><code class="python">
        # Fonction de chiffrement
        def chiffrer(message, cle_publique):
            e, n = cle_publique
            return [pow(ord(char), e, n) for char in message]
        
        # Fonction de déchiffrement
        def dechiffrer(message_chiffre, cle_privee):
            d, n = cle_privee
            return ''.join([chr(pow(char, d, n)) for char in message_chiffre])
        
        # Exemple de test
        message = "HELLO"
        message_chiffre = chiffrer(message, cle_publique)
        print("Message chiffré :", message_chiffre)
        
        message_dechiffre = dechiffrer(message_chiffre, cle_privee)
        print("Message déchiffré :", message_dechiffre)
            </code></pre>
        
            <h4>Explication :</h4>
            <ul>
                <li><strong>Chiffrement :</strong> Chaque caractère du message est transformé en un entier à l’aide de la clé publique.</li>
                <li><strong>Déchiffrement :</strong> Les entiers sont reconvertis en caractères à l’aide de la clé privée.</li>
            </ul>
        
            <h3>3. Activité Pratique (40 min)</h3>
            <p>
                Les élèves devront écrire un programme Python qui :
            </p>
            <ul>
                <li>Génère des clés publiques et privées RSA.</li>
                <li>Permet à un utilisateur d’entrer un message à chiffrer.</li>
                <li>Affiche le message chiffré et déchiffré.</li>
            </ul>
        
            <h4>Défi supplémentaire :</h4>
            <ul>
                <li>Améliorez la sécurité en utilisant des nombres premiers plus grands (ex. : dans l’intervalle [100, 500]).</li>
                <li>Ajoutez des vérifications pour empêcher l’utilisateur de chiffrer un message trop long pour <code>n</code>.</li>
            </ul>
        
            <h3>4. Conclusion et Discussion (20 min)</h3>
            <p>Points à discuter :</p>
            <ul>
                <li>Pourquoi le chiffrement asymétrique est-il plus sécurisé que le chiffrement symétrique ?</li>
                <li>Quels sont les inconvénients de RSA (par exemple, la lenteur pour de grandes quantités de données) ?</li>
                <li>Dans quels cas RSA est-il utilisé (certificats SSL, signatures numériques, etc.) ?</li>
            </ul>
            <p>
                Les élèves doivent également réfléchir à comment combiner RSA avec des algorithmes symétriques (comme AES) pour maximiser sécurité et performance.
            </p>
        </section>

        <section id="session64" class="content-section">
            <h2>Séance 64 : Introduction aux Protocoles de Sécurité (SSL, HTTPS)</h2>
        
            <h3>Objectif Global :</h3>
            <p>Les élèves apprendront les bases des protocoles de sécurité en informatique, notamment SSL (Secure Sockets Layer) et HTTPS (HyperText Transfer Protocol Secure). Cette séance vise à expliquer leur fonctionnement, leur rôle dans la sécurisation des communications, et à illustrer leur application à travers des exemples pratiques.</p>
        
            <h3>1. Contexte et Importance des Protocoles de Sécurité</h3>
        
            <h4>Pourquoi les Protocoles de Sécurité sont-ils Importants ?</h4>
            <p>Les protocoles de sécurité sont essentiels pour protéger les échanges de données sur Internet. Ils garantissent :</p>
            <ul>
                <li><strong>Confidentialité :</strong> Les données échangées sont chiffrées pour empêcher leur lecture par des tiers.</li>
                <li><strong>Authenticité :</strong> Les parties en communication peuvent vérifier leur identité mutuelle.</li>
                <li><strong>Intégrité :</strong> Les données ne peuvent pas être modifiées ou altérées pendant leur transfert.</li>
            </ul>
        
            <h4>Exemples de Menaces Courantes :</h4>
            <ul>
                <li>Interception des données par un attaquant (attaque de l’homme du milieu).</li>
                <li>Sites Web frauduleux imitant des sites légitimes pour voler des informations (hameçonnage).</li>
                <li>Altération des données pendant leur transfert.</li>
            </ul>
        
            <h3>2. Comprendre SSL et TLS (20 min)</h3>
        
            <h4>Qu’est-ce que SSL ?</h4>
            <p>
                SSL (Secure Sockets Layer) est un protocole qui établit une connexion sécurisée entre un client (navigateur) et un serveur. Il utilise des techniques de chiffrement pour protéger les données échangées.
            </p>
        
            <h4>Qu’est-ce que TLS ?</h4>
            <p>
                TLS (Transport Layer Security) est une version améliorée et plus sécurisée de SSL. Aujourd’hui, TLS a remplacé SSL, mais le terme SSL est souvent utilisé par commodité pour désigner les deux.
            </p>
        
            <h4>Fonctionnement de SSL/TLS :</h4>
            <p>SSL/TLS repose sur les concepts suivants :</p>
            <ul>
                <li><strong>Chiffrement :</strong> Les données sont chiffrées pour garantir leur confidentialité.</li>
                <li><strong>Certificats :</strong> Un certificat SSL/TLS est utilisé pour vérifier l’identité du serveur.</li>
                <li><strong>Négociation :</strong> Le client et le serveur négocient un "canal sécurisé" pour échanger les données.</li>
            </ul>
        
            <h4>Schéma de Fonctionnement :</h4>
            <pre><code>1. Le client (navigateur) contacte le serveur et demande une connexion sécurisée.
        2. Le serveur envoie son certificat SSL/TLS au client.
        3. Le client vérifie le certificat pour s'assurer qu'il est valide.
        4. Le client et le serveur établissent un canal chiffré.
        5. Les données sont échangées en toute sécurité.
            </code></pre>
        
            <h3>3. Comprendre HTTPS (HyperText Transfer Protocol Secure)</h3>
        
            <h4>Qu’est-ce que HTTPS ?</h4>
            <p>
                HTTPS est une version sécurisée de HTTP qui utilise SSL/TLS pour protéger les données échangées entre le client et le serveur. HTTPS est indispensable pour des applications comme :
            </p>
            <ul>
                <li>Les transactions financières (paiements en ligne).</li>
                <li>La connexion à des comptes utilisateur.</li>
                <li>La navigation sur des sites Web sensibles.</li>
            </ul>
        
            <h4>Différence entre HTTP et HTTPS :</h4>
            <table border="1" style="border-collapse: collapse; width: 100%; text-align: left;">
                <thead>
                    <tr>
                        <th>HTTP</th>
                        <th>HTTPS</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Les données échangées ne sont pas chiffrées.</td>
                        <td>Les données sont chiffrées et protégées.</td>
                    </tr>
                    <tr>
                        <td>Pas de certificat SSL/TLS requis.</td>
                        <td>Requiert un certificat SSL/TLS.</td>
                    </tr>
                    <tr>
                        <td>Vulnérable aux attaques.</td>
                        <td>Protège contre les interceptions et les altérations.</td>
                    </tr>
                </tbody>
            </table>
        
            <h4>Indicateurs Visuels de HTTPS :</h4>
            <p>Sur un navigateur Web, un site HTTPS est indiqué par :</p>
            <ul>
                <li>Un cadenas dans la barre d’adresse.</li>
                <li>L’URL commençant par <code>https://</code>.</li>
            </ul>
        
            <h3>4. Mise en Pratique (40 min)</h3>
        
            <h4>Exercice : Vérifier un Certificat SSL/TLS</h4>
            <p>
                Les élèves utiliseront leur navigateur pour vérifier les certificats SSL/TLS de plusieurs sites Web.
            </p>
            <ul>
                <li><strong>Étape 1 :</strong> Accédez à un site HTTPS (par exemple, https://www.google.com).</li>
                <li><strong>Étape 2 :</strong> Cliquez sur le cadenas dans la barre d’adresse.</li>
                <li><strong>Étape 3 :</strong> Examinez les informations du certificat (organisation, validité, autorité de certification).</li>
            </ul>

            <h2>Exercice : Configurer un Site Local avec HTTPS</h2>

            <h3>Objectif :</h3>
            <p>
                Configurer un serveur local sécurisé avec HTTPS en utilisant Python et OpenSSL. Cet exercice permettra de comprendre les étapes nécessaires pour mettre en place un certificat SSL/TLS et de tester HTTPS dans un environnement local.
            </p>

            <h3>Prérequis :</h3>
            <ul>
                <li>Python (version 3.7 ou supérieure) installé.</li>
                <li>OpenSSL installé (disponible par défaut sur Linux/Mac, téléchargeable pour Windows).</li>
                <li>Un éditeur de texte et un terminal (par exemple, VS Code, Terminal ou Command Prompt).</li>
            </ul>

            <h3>Étape 1 : Créer un Certificat SSL/TLS Auto-signé</h3>
            <p>
                Un certificat auto-signé sera généré pour sécuriser les communications. Cela convient uniquement pour un usage local (non recommandé en production).
            </p>

            <h4>Commandes à Exécuter :</h4>
            <pre><code class="bash">
        # 1. Générer une clé privée
        openssl genrsa -out cle_privee.key 2048

        # 2. Créer une demande de signature de certificat (CSR)
        openssl req -new -key cle_privee.key -out demande_signature.csr

        # Pendant cette étape, fournissez les informations demandées :
        # - Country Name (e.g., FR)
        # - State or Province Name
        # - Locality Name
        # - Organization Name
        # - Common Name (utilisez "localhost" pour usage local)

        # 3. Générer un certificat auto-signé (valable 365 jours)
        openssl x509 -req -days 365 -in demande_signature.csr -signkey cle_privee.key -out certificat.crt
            </code></pre>

            <h4>Fichiers Générés :</h4>
            <ul>
                <li><code>cle_privee.key</code> : Clé privée du serveur.</li>
                <li><code>certificat.crt</code> : Certificat SSL auto-signé.</li>
                <li><code>demande_signature.csr</code> : Demande de signature (optionnelle ici).</li>
            </ul>

            <h3>Étape 2 : Configurer un Serveur Local avec HTTPS</h3>

            <h4>Création d’un Fichier HTML Simple :</h4>
            <p>Créez un fichier <code>index.html</code> avec le contenu suivant :</p>
            <pre><code class="html">
        <!DOCTYPE html>
        <html lang="fr">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Serveur HTTPS Local</title>
        </head>
        <body>
            <h1>Bienvenue sur le serveur HTTPS local !</h1>
            <p>Ce site est sécurisé avec HTTPS (certificat auto-signé).</p>
        </body>
        </html>
            </code></pre>

            <h4>Lancement du Serveur HTTPS :</h4>
            <p>
                Dans le même répertoire que les fichiers, exécutez la commande suivante pour démarrer un serveur HTTPS :
            </p>
            <pre><code class="bash">
        python -m http.server 8000 --bind 127.0.0.1 --certfile certificat.crt --keyfile cle_privee.key
            </code></pre>

            <h4>Explication des Options :</h4>
            <ul>
                <li><code>8000</code> : Port du serveur.</li>
                <li><code>--bind 127.0.0.1</code> : Limite le serveur à localhost.</li>
                <li><code>--certfile certificat.crt</code> : Chemin vers le certificat SSL.</li>
                <li><code>--keyfile cle_privee.key</code> : Chemin vers la clé privée.</li>
            </ul>

            <h3>Étape 3 : Tester le Serveur HTTPS</h3>
            <ol>
                <li>Ouvrez un navigateur Web (Chrome, Firefox, Edge, etc.).</li>
                <li>Accédez à l’URL suivante : <code>https://localhost:8000</code>.</li>
            </ol>

            <h4>Que Se Passe-t-il ?</h4>
            <ul>
                <li>Votre navigateur affichera un avertissement indiquant que le certificat n’est pas fiable (c’est normal pour un certificat auto-signé).</li>
                <li>Cliquez sur <strong>“Avancé”</strong> puis <strong>“Continuer vers localhost”</strong> pour accéder au site.</li>
            </ul>

            <h4>Résultat Attendu :</h4>
            <p>Le navigateur affichera le contenu de votre fichier <code>index.html</code>.</p>

            <h3>Étape 4 : Comprendre les Limites</h3>
            <p>
                Un certificat auto-signé est suffisant pour les tests locaux, mais en production, vous devez utiliser un certificat signé par une autorité de certification (CA) reconnue comme Let’s Encrypt.
            </p>

            <h3>Étape 5 : Défi Supplémentaire</h3>
            <p>Pour aller plus loin, essayez les activités suivantes :</p>
            <ul>
                <li><strong>Intercepter les Requêtes :</strong> Utilisez un outil comme Wireshark pour capturer et analyser les données échangées.</li>
                <li><strong>Ajouter des Pages :</strong> Créez plusieurs fichiers HTML (par exemple, <code>page1.html</code>, <code>page2.html</code>) et testez leur navigation sur le serveur HTTPS.</li>
                <li><strong>Configurer HTTPS avec un Serveur Web Complet :</strong> Essayez de configurer un serveur local sécurisé avec Apache ou Nginx.</li>
            </ul>

            <h3>Conclusion :</h3>
            <p>
                À la fin de cet exercice, vous aurez appris :
            </p>
            <ul>
                <li>À générer un certificat SSL/TLS.</li>
                <li>À configurer un serveur local sécurisé avec HTTPS.</li>
                <li>Les différences entre HTTP et HTTPS, ainsi que leurs implications pour la sécurité.</li>
            </ul>
        
            <h4>Défi :</h4>
            <ul>
                <li>Comparez la navigation sur un site HTTP et HTTPS pour observer les différences.</li>
                <li>Essayez d’intercepter les requêtes d’un site HTTP avec un outil comme Wireshark.</li>
            </ul>
        
            <h3>5. Discussion et Questions (20 min)</h3>
        
            <h4>Questions de Réflexion :</h4>
            <ul>
                <li>Pourquoi est-il risqué de naviguer sur un site HTTP non sécurisé ?</li>
                <li>Quels sont les avantages d’implémenter HTTPS sur un site Web ?</li>
                <li>Quelles autres mesures de sécurité pourraient être utilisées en complément de HTTPS ?</li>
            </ul>
        
            <h3>Conclusion :</h3>
            <p>
                À la fin de cette séance, les élèves auront une compréhension claire des protocoles de sécurité SSL/TLS et HTTPS. Ils auront appris :
            </p>
            <ul>
                <li>Les principes de base de SSL/TLS et leur fonctionnement.</li>
                <li>Les avantages de HTTPS par rapport à HTTP.</li>
                <li>À analyser des certificats SSL/TLS et à configurer un site local sécurisé.</li>
            </ul>
            <p>Ces connaissances sont essentielles pour comprendre comment protéger les communications sur Internet et les intégrer dans des projets futurs.</p>
        </section>

        <section id="session65" class="content-section">
            <h2>Séance 65 : Pratique - Sécurisation des échanges entre un serveur de jeu et un client</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Les élèves apprendront à sécuriser les échanges de données entre un serveur de jeu et un client en utilisant des techniques telles que le chiffrement, les protocoles sécurisés et les clés API. Ils mettront en œuvre ces concepts dans une application client-serveur simplifiée.
            </p>
        
            <h3>Contexte du Projet :</h3>
            <p>
                Imaginez un jeu multijoueur où le client envoie des informations (comme les scores ou les mouvements du joueur) au serveur. Ces échanges doivent être sécurisés pour éviter les attaques, comme l’interception ou la falsification des données. L’objectif est de créer un petit système client-serveur où :
            </p>
            <ul>
                <li>Le client communique avec le serveur en utilisant un protocole sécurisé (chiffrement des données).</li>
                <li>Le serveur vérifie l’identité du client à l’aide d’une clé API unique.</li>
                <li>Les données transmises sont protégées contre les attaques "man-in-the-middle".</li>
            </ul>
        
            <h3>Étape 1 : Création de la Structure Client-Serveur (30 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Configurez une application client-serveur de base en utilisant Python et les sockets pour établir une communication simple.
            </p>
        
            <h4>Code du Serveur :</h4>
            <pre><code class="python">
        import socket
        
        # Configuration du serveur
        HOST = '127.0.0.1'  # Adresse IP locale
        PORT = 65432        # Port à utiliser
        
        # Création du socket
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.bind((HOST, PORT))
        server_socket.listen()
        
        print("Serveur en attente de connexion...")
        
        # Acceptation d'une connexion client
        conn, addr = server_socket.accept()
        print(f"Connexion établie avec {addr}")
        
        # Réception et affichage des données
        data = conn.recv(1024).decode('utf-8')
        print(f"Données reçues : {data}")
        
        # Envoi de réponse au client
        conn.sendall("Données reçues avec succès.".encode('utf-8'))
        
        # Fermeture de la connexion
        conn.close()
            </code></pre>
        
            <h4>Code du Client :</h4>
            <pre><code class="python">
        import socket
        
        # Configuration du client
        HOST = '127.0.0.1'  # Adresse IP du serveur
        PORT = 65432        # Port à utiliser
        
        # Création du socket
        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket.connect((HOST, PORT))
        
        # Envoi des données au serveur
        message = "Bonjour, serveur !"
        client_socket.sendall(message.encode('utf-8'))
        
        # Réception de la réponse
        response = client_socket.recv(1024).decode('utf-8')
        print(f"Réponse du serveur : {response}")
        
        # Fermeture de la connexion
        client_socket.close()
            </code></pre>
        
            <p><strong>Test :</strong> Lancer d'abord le serveur, puis le client, et observez les échanges de données dans la console.</p>
        
            <h3>Étape 2 : Ajout de Chiffrement des Données (30 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Intégrez un chiffrement simple en utilisant la bibliothèque Python <code>cryptography</code> pour sécuriser les échanges entre le client et le serveur.
            </p>
        
            <h4>Installation de la bibliothèque :</h4>
            <pre><code>pip install cryptography</code></pre>
        
            <h4>Code Mise à Jour :</h4>
            <h5>Serveur :</h5>
            <pre><code class="python">
        from cryptography.fernet import Fernet
        import socket
        
        # Génération et stockage de la clé de chiffrement
        key = Fernet.generate_key()
        cipher_suite = Fernet(key)
        
        # Configuration du serveur
        HOST = '127.0.0.1'
        PORT = 65432
        
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.bind((HOST, PORT))
        server_socket.listen()
        
        print("Serveur en attente de connexion...")
        
        conn, addr = server_socket.accept()
        print(f"Connexion établie avec {addr}")
        
        # Envoi de la clé au client
        conn.sendall(key)
        
        # Réception et déchiffrement des données
        data = conn.recv(1024)
        decrypted_data = cipher_suite.decrypt(data).decode('utf-8')
        print(f"Données reçues : {decrypted_data}")
        
        # Réponse chiffrée au client
        response = cipher_suite.encrypt("Données reçues avec succès.".encode('utf-8'))
        conn.sendall(response)
        
        conn.close()
            </code></pre>
        
            <h5>Client :</h5>
            <pre><code class="python">
        from cryptography.fernet import Fernet
        import socket
        
        # Configuration du client
        HOST = '127.0.0.1'
        PORT = 65432
        
        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket.connect((HOST, PORT))
        
        # Réception de la clé de chiffrement
        key = client_socket.recv(1024)
        cipher_suite = Fernet(key)
        
        # Envoi des données chiffrées
        message = "Bonjour, serveur sécurisé !"
        encrypted_message = cipher_suite.encrypt(message.encode('utf-8'))
        client_socket.sendall(encrypted_message)
        
        # Réception et déchiffrement de la réponse
        response = client_socket.recv(1024)
        decrypted_response = cipher_suite.decrypt(response).decode('utf-8')
        print(f"Réponse du serveur : {decrypted_response}")
        
        client_socket.close()
            </code></pre>
        
            <p><strong>Test :</strong> Reprenez le test précédent et observez que les données sont chiffrées lors des échanges.</p>
        
            <h3>Étape 3 : Sécurisation avec une Clé API (30 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Ajoutez une vérification par clé API pour valider l’identité du client avant d’autoriser les échanges de données.
            </p>
        
            <h4>Ajout au Serveur :</h4>
            <pre><code class="python">
        VALID_API_KEY = "my_secure_api_key"
        
        # Réception de la clé API
        client_api_key = conn.recv(1024).decode('utf-8')
        if client_api_key != VALID_API_KEY:
            conn.sendall("Clé API invalide".encode('utf-8'))
            conn.close()
        else:
            conn.sendall("Clé API valide, connexion autorisée.".encode('utf-8'))
            # Suite des échanges sécurisés...
            </code></pre>
        
            <h4>Ajout au Client :</h4>
            <pre><code class="python">
        API_KEY = "my_secure_api_key"
        
        # Envoi de la clé API
        client_socket.sendall(API_KEY.encode('utf-8'))
        
        # Vérification de la réponse du serveur
        response = client_socket.recv(1024).decode('utf-8')
        if "Clé API invalide" in response:
            print("Connexion refusée par le serveur.")
            client_socket.close()
        else:
            print("Connexion autorisée par le serveur.")
            # Suite des échanges sécurisés...
            </code></pre>
        
            <h3>Conclusion :</h3>
            <p>
                À la fin de cette séance, les élèves auront appris à :
            </p>
            <ul>
                <li>Créer une communication client-serveur avec Python et les sockets.</li>
                <li>Intégrer un chiffrement des données pour sécuriser les échanges.</li>
                <li>Utiliser une clé API pour authentifier les clients.</li>
            </ul>
            <p>
                Ces techniques sont essentielles pour sécuriser les communications dans des applications réseau, en particulier dans le contexte des jeux multijoueurs.
            </p>
        </section>

        <section id="session66" class="content-section">
            <h2>Séance 66 : Algorithmes de Hachage et Intégrité des Données</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Cette séance introduit les <strong>algorithmes de hachage</strong>, leur fonctionnement, et leur rôle dans la vérification de l’intégrité des données et la sécurité informatique. Les élèves apprendront à utiliser des fonctions de hachage comme <code>SHA-256</code> dans Python pour garantir l’intégrité et détecter des altérations potentielles des données.
            </p>
        
            <h3>Introduction aux Algorithmes de Hachage (30 min)</h3>
        
            <h4>Qu’est-ce qu’un Algorithme de Hachage ?</h4>
            <ul>
                <li>Un algorithme de hachage est une fonction qui convertit une entrée (texte, fichier, etc.) en une chaîne de caractères fixe appelée <strong>empreinte</strong> ou <strong>hash</strong>.</li>
                <li>Les propriétés principales d’un bon algorithme de hachage sont :</li>
                <ul>
                    <li><strong>Déterminisme :</strong> La même entrée produit toujours le même hash.</li>
                    <li><strong>Rapidité :</strong> Le calcul du hash est rapide.</li>
                    <li><strong>Unicité :</strong> Deux entrées différentes produisent des hash différents (très peu de collisions).</li>
                    <li><strong>Irréversibilité :</strong> Impossible de retrouver l’entrée d’origine à partir du hash.</li>
                </ul>
            </ul>
        
            <h4>Applications des Algorithmes de Hachage :</h4>
            <ul>
                <li><strong>Vérification de l’intégrité :</strong> Garantir qu’un fichier ou un message n’a pas été altéré.</li>
                <li><strong>Sécurité des mots de passe :</strong> Stocker des mots de passe de manière sécurisée (hachés au lieu de texte brut).</li>
                <li><strong>Signatures numériques :</strong> Vérifier l’identité d’un utilisateur ou l’authenticité d’un document.</li>
            </ul>
        
            <h4>Exemples d’Algorithmes de Hachage :</h4>
            <ul>
                <li><code>MD5</code> : Obsolète, peu sécurisé.</li>
                <li><code>SHA-1</code> : Plus sécurisé que MD5, mais des failles existent.</li>
                <li><code>SHA-256</code> : Algorithme largement utilisé pour sa robustesse.</li>
            </ul>
        
            <h3>Étape 1 : Utilisation de SHA-256 dans Python (30 min)</h3>
        
            <h4>Exemple Simple :</h4>
            <p>
                Nous allons utiliser le module <code>hashlib</code> de Python pour calculer le hash d’une chaîne de caractères.
            </p>
            <pre><code class="python">
        import hashlib
        
        # Texte à hacher
        texte = "Bonjour, monde !"
        
        # Calcul du hash SHA-256
        hash_object = hashlib.sha256(texte.encode())
        hash_hex = hash_object.hexdigest()
        
        print(f"Texte original : {texte}")
        print(f"Hash SHA-256 : {hash_hex}")
            </code></pre>
        
            <h4>Explication du Code :</h4>
            <ul>
                <li><code>hashlib.sha256</code> : Fonction pour calculer un hash SHA-256.</li>
                <li><code>encode()</code> : Convertit le texte en bytes (nécessaire pour le calcul du hash).</li>
                <li><code>hexdigest()</code> : Retourne l’empreinte sous forme de chaîne hexadécimale.</li>
            </ul>
        
            <h4>Test :</h4>
            <p>Modifiez le texte d’origine et observez comment le hash change complètement, même si la modification est minime (effet avalanche).</p>
        
            <h3>Étape 2 : Vérification de l’Intégrité des Fichiers (40 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Écrivez un programme qui vérifie si un fichier a été modifié en comparant son hash actuel avec un hash de référence.
            </p>
        
            <h4>Implémentation :</h4>
            <pre><code class="python">
        import hashlib
        
        def calculer_hash_fichier(nom_fichier):
            """Calcule le hash SHA-256 d'un fichier."""
            sha256 = hashlib.sha256()
            try:
                with open(nom_fichier, "rb") as f:
                    while chunk := f.read(4096):
                        sha256.update(chunk)
                return sha256.hexdigest()
            except FileNotFoundError:
                print("Fichier introuvable.")
                return None
        
        # Comparer le hash d'origine avec celui recalculé
        fichier = "document.txt"
        hash_original = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
        
        hash_actuel = calculer_hash_fichier(fichier)
        
        if hash_actuel == hash_original:
            print("Le fichier est intact.")
        else:
            print("Le fichier a été modifié.")
            </code></pre>
        
            <h4>Explication du Code :</h4>
            <ul>
                <li><code>open(nom_fichier, "rb")</code> : Ouvre le fichier en mode binaire pour lire son contenu brut.</li>
                <li><code>sha256.update(chunk)</code> : Met à jour le calcul du hash avec des blocs successifs de données (évite de charger de gros fichiers en mémoire).</li>
                <li><code>hash_original</code> : Hash de référence pour vérifier l’intégrité du fichier.</li>
            </ul>
        
            <h4>Test :</h4>
            <p>
                Créez un fichier texte avec un contenu connu. Calculez son hash et modifiez légèrement le fichier. Recalculez le hash pour voir la différence.
            </p>
        
            <h3>Étape 3 : Application Pratique - Stockage de Mots de Passe Sécurisé (40 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Écrivez un programme qui stocke les mots de passe sous forme hachée et vérifie si un mot de passe saisi correspond à celui enregistré.
            </p>
        
            <h4>Implémentation :</h4>
            <pre><code class="python">
        import hashlib
        
        # Fonction pour hacher un mot de passe
        def hacher_mot_de_passe(mot_de_passe):
            return hashlib.sha256(mot_de_passe.encode()).hexdigest()
        
        # Fonction pour vérifier un mot de passe
        def verifier_mot_de_passe(mot_de_passe, hash_enregistre):
            return hacher_mot_de_passe(mot_de_passe) == hash_enregistre
        
        # Enregistrement d'un mot de passe
        mot_de_passe = "monSuperMotDePasse"
        hash_enregistre = hacher_mot_de_passe(mot_de_passe)
        print(f"Hash enregistré : {hash_enregistre}")
        
        # Vérification d'un mot de passe
        mot_de_passe_saisi = "monSuperMotDePasse"
        if verifier_mot_de_passe(mot_de_passe_saisi, hash_enregistre):
            print("Mot de passe correct.")
        else:
            print("Mot de passe incorrect.")
            </code></pre>
        
            <h4>Explication du Code :</h4>
            <ul>
                <li><code>hacher_mot_de_passe</code> : Retourne le hash SHA-256 d’un mot de passe.</li>
                <li><code>verifier_mot_de_passe</code> : Compare un mot de passe saisi avec le hash enregistré.</li>
            </ul>
        
            <h4>Test :</h4>
            <p>
                Testez avec le mot de passe correct, puis avec un mot de passe incorrect pour vérifier le comportement du programme.
            </p>
        
            <h3>Conclusion et Discussion (10 min)</h3>
            <p>
                À la fin de cette séance, les élèves auront appris :
            </p>
            <ul>
                <li>Les concepts clés des algorithmes de hachage et leur utilité.</li>
                <li>Comment utiliser les fonctions de hachage dans Python pour vérifier l’intégrité des données.</li>
                <li>Comment sécuriser des mots de passe grâce au hachage.</li>
            </ul>
            <p>
                Discutez des limitations des algorithmes de hachage, comme les attaques par collision, et introduisez des concepts plus avancés comme les "salts" et les "pepper" pour améliorer la sécurité.
            </p>
        </section>

        <section id="session67" class="content-section">
            <h2>Séance 67 : Signature numérique et validation de l’intégrité des données</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Les élèves découvriront les concepts de signature numérique et de validation de l’intégrité des données. Ils apprendront à utiliser des algorithmes de hachage et des clés cryptographiques pour vérifier l’authenticité et la non-altération des données dans un système sécurisé.
            </p>
        
            <h3>Introduction (15 min)</h3>
        
            <h4>1. Qu’est-ce qu’une Signature Numérique ?</h4>
            <p>
                Une signature numérique est un mécanisme cryptographique qui permet de garantir l’authenticité et l’intégrité des données ou des messages. Elle joue un rôle similaire à une signature manuscrite dans le monde numérique.
            </p>
            <ul>
                <li><strong>Authenticité :</strong> Vérifie que les données proviennent d’un expéditeur légitime.</li>
                <li><strong>Intégrité :</strong> Garantit que les données n’ont pas été modifiées depuis leur création.</li>
                <li><strong>Non-répudiation :</strong> Empêche l’expéditeur de nier avoir envoyé les données.</li>
            </ul>
        
            <h4>2. Algorithmes Clés :</h4>
            <p>Les signatures numériques reposent sur deux mécanismes principaux :</p>
            <ul>
                <li><strong>Algorithmes de hachage :</strong> Ils transforment des données en une empreinte unique (exemple : SHA-256).</li>
                <li><strong>Cryptographie asymétrique :</strong> Utilise une paire de clés (publique et privée) pour signer et vérifier les données.</li>
            </ul>
        
            <h3>Étape 1 : Algorithmes de Hachage (30 min)</h3>
        
            <h4>1. Concept de Hachage :</h4>
            <p>
                Un algorithme de hachage prend une entrée (un message ou des données) et produit une empreinte unique et fixe, appelée <strong>hash</strong>. Les propriétés d’un bon algorithme de hachage sont :
            </p>
            <ul>
                <li><strong>Unidirectionnel :</strong> Impossible de retrouver l’entrée à partir du hash.</li>
                <li><strong>Sensible :</strong> Une petite modification de l’entrée entraîne un hash complètement différent.</li>
                <li><strong>Collisions rares :</strong> Deux entrées différentes ne doivent pas produire le même hash.</li>
            </ul>
        
            <h4>2. Exemple avec SHA-256 :</h4>
            <pre><code class="python">
        import hashlib
        
        # Données à hacher
        message = "Bonjour, monde !"
        
        # Calcul du hash avec SHA-256
        hash_message = hashlib.sha256(message.encode()).hexdigest()
        
        print(f"Message : {message}")
        print(f"Hash (SHA-256) : {hash_message}")
            </code></pre>
        
            <h4>Exercice :</h4>
            <p>
                Modifiez le message d’entrée et observez comment le hash change complètement. Discutez de l'importance de cette sensibilité dans la validation de l'intégrité.
            </p>
        
            <h3>Étape 2 : Création et Vérification de Signatures Numériques (40 min)</h3>
        
            <h4>1. Principe :</h4>
            <p>Une signature numérique utilise la cryptographie asymétrique pour signer un message et vérifier son authenticité :</p>
            <ul>
                <li><strong>Clé privée :</strong> Utilisée pour signer le message.</li>
                <li><strong>Clé publique :</strong> Utilisée pour vérifier la signature.</li>
            </ul>
        
            <h4>2. Exemple Pratique :</h4>
            <p>
                Utilisons la bibliothèque <code>cryptography</code> pour générer une signature numérique et vérifier l'intégrité des données.
            </p>
            <pre><code class="python">
        from cryptography.hazmat.primitives.asymmetric import rsa, padding
        from cryptography.hazmat.primitives import hashes
        
        # Génération d'une paire de clés
        cle_privee = rsa.generate_private_key(public_exponent=65537, key_size=2048)
        cle_publique = cle_privee.public_key()
        
        # Données à signer
        message = b"Voici un message important."
        
        # Création de la signature numérique
        signature = cle_privee.sign(
            message,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        
        print("Signature créée avec succès.")
        
        # Vérification de la signature
        try:
            cle_publique.verify(
                signature,
                message,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            print("Signature vérifiée avec succès. Intégrité garantie.")
        except Exception as e:
            print("La vérification a échoué :", e)
            </code></pre>
        
            <h4>Exercice :</h4>
            <p>
                Modifiez le message d’entrée ou la clé publique et observez comment la vérification échoue. Discutez de l'importance de ce processus dans la détection de modifications non autorisées.
            </p>
        
            <h3>Étape 3 : Application Pratique (30 min)</h3>
        
            <h4>Scénario :</h4>
            <p>
                Créez une application où un utilisateur envoie un fichier signé numériquement à un autre utilisateur. L'application doit :
            </p>
            <ul>
                <li>Générer une signature numérique pour le fichier.</li>
                <li>Permettre à l’utilisateur destinataire de vérifier la signature et l’intégrité du fichier.</li>
            </ul>
        
            <h4>Exemple de Code :</h4>
            <pre><code class="python">
        # Exemple d'application de signature pour un fichier
        from cryptography.hazmat.primitives.asymmetric import rsa, padding
        from cryptography.hazmat.primitives import hashes
        
        # Génération de clés
        cle_privee = rsa.generate_private_key(public_exponent=65537, key_size=2048)
        cle_publique = cle_privee.public_key()
        
        # Lecture d'un fichier
        with open("fichier.txt", "rb") as f:
            contenu = f.read()
        
        # Création de la signature
        signature = cle_privee.sign(
            contenu,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        
        print("Fichier signé.")
        
        # Vérification de la signature
        try:
            cle_publique.verify(
                signature,
                contenu,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            print("Signature valide. Le fichier n'a pas été altéré.")
        except Exception as e:
            print("La vérification a échoué :", e)
            </code></pre>
        
            <h4>Défi :</h4>
            <ul>
                <li>Ajoutez une interface utilisateur simple (ex. : en ligne de commande) pour signer et vérifier les fichiers.</li>
                <li>Gérez les cas d'erreur, comme un fichier corrompu ou une clé publique incorrecte.</li>
            </ul>
        
            <h3>Conclusion et Discussion (15 min)</h3>
            <ul>
                <li>Les signatures numériques garantissent l’intégrité et l’authenticité des données dans des systèmes sécurisés.</li>
                <li>Les algorithmes de hachage et la cryptographie asymétrique sont les piliers de ces mécanismes.</li>
                <li>Discussion : Quels autres usages de la signature numérique pouvez-vous imaginer (e-mails sécurisés, certificats SSL, etc.) ?</li>
            </ul>
        </section>

        <section id="session68" class="content-section">
            <h2>Séance 68 : Pratique - Protection des données d’une application de gestion d’actualité</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Les élèves apprendront à protéger les données sensibles dans une application de gestion d’actualité en utilisant les principes de l’encapsulation. Ils mettront en œuvre des pratiques comme l’utilisation d’attributs privés, la validation des entrées, et la sécurisation des accès aux données à travers des méthodes dédiées.
            </p>
        
            <h3>Contexte du Projet :</h3>
            <p>
                Vous développez une application de gestion d’actualité pour un journal. Cette application stocke et gère des articles, avec des informations sensibles telles que l’auteur, le contenu, et la date de publication. Les élèves devront :
            </p>
            <ul>
                <li>Créer une classe <code>Article</code> avec des attributs privés pour protéger les données.</li>
                <li>Mettre en œuvre des getters et setters avec validation pour les attributs critiques.</li>
                <li>Gérer une liste d’articles à travers une classe <code>GestionActualites</code> qui sécurise les opérations.</li>
            </ul>
        
            <h3>Étape 1 : Création de la Classe Article (30 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Créez une classe <code>Article</code> avec les attributs suivants :
            </p>
            <ul>
                <li><code>titre</code> : Le titre de l’article (chaîne de caractères).</li>
                <li><code>auteur</code> : L’auteur de l’article (chaîne de caractères).</li>
                <li><code>contenu</code> : Le contenu de l’article (chaîne de caractères).</li>
                <li><code>date_publication</code> : La date de publication (format YYYY-MM-DD).</li>
            </ul>
            <p>
                Ces attributs doivent être <strong>privés</strong> et accessibles uniquement via des getters et setters, avec validation pour garantir leur validité.
            </p>
        
            <h4>Implémentation Initiale :</h4>
            <pre><code class="python">
        from datetime import datetime
        
        class Article:
            def __init__(self, titre, auteur, contenu, date_publication):
                self.__titre = titre
                self.__auteur = auteur
                self.__contenu = contenu
                self.__date_publication = self.__valider_date(date_publication)
        
            # Getter et setter pour titre
            @property
            def titre(self):
                return self.__titre
        
            @titre.setter
            def titre(self, nouveau_titre):
                if isinstance(nouveau_titre, str) and len(nouveau_titre) > 0:
                    self.__titre = nouveau_titre
                else:
                    print("Erreur : Le titre doit être une chaîne non vide.")
        
            # Getter et setter pour auteur
            @property
            def auteur(self):
                return self.__auteur
        
            @auteur.setter
            def auteur(self, nouvel_auteur):
                if isinstance(nouvel_auteur, str) and len(nouvel_auteur) > 0:
                    self.__auteur = nouvel_auteur
                else:
                    print("Erreur : L'auteur doit être une chaîne non vide.")
        
            # Getter et setter pour contenu
            @property
            def contenu(self):
                return self.__contenu
        
            @contenu.setter
            def contenu(self, nouveau_contenu):
                if isinstance(nouveau_contenu, str) and len(nouveau_contenu) > 0:
                    self.__contenu = nouveau_contenu
                else:
                    print("Erreur : Le contenu doit être une chaîne non vide.")
        
            # Getter et validation pour date_publication
            @property
            def date_publication(self):
                return self.__date_publication
        
            @date_publication.setter
            def date_publication(self, nouvelle_date):
                self.__date_publication = self.__valider_date(nouvelle_date)
        
            def __valider_date(self, date_str):
                try:
                    return datetime.strptime(date_str, "%Y-%m-%d")
                except ValueError:
                    print("Erreur : La date doit être au format YYYY-MM-DD.")
                    return None
            </code></pre>
        
            <h4>Test Initial :</h4>
            <pre><code class="python">
        # Création d'un article
        article = Article("Titre de l'article", "Alice", "Ceci est le contenu.", "2025-01-01")
        
        # Affichage des informations
        print(article.titre)  # Titre de l'article
        print(article.date_publication)  # 2025-01-01
        
        # Modifications avec validation
        article.titre = ""  # Erreur : Le titre doit être une chaîne non vide.
        article.date_publication = "2025-15-01"  # Erreur : La date doit être au format YYYY-MM-DD.
            </code></pre>
        
            <h3>Étape 2 : Gestion des Articles avec GestionActualites (30 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Créez une classe <code>GestionActualites</code> pour gérer une liste d’articles. Cette classe doit inclure :
            </p>
            <ul>
                <li><code>ajouter_article(article)</code> : Ajoute un article à la liste.</li>
                <li><code>supprimer_article(titre)</code> : Supprime un article par son titre.</li>
                <li><code>afficher_articles()</code> : Affiche les détails de tous les articles.</li>
            </ul>
        
            <h4>Implémentation :</h4>
            <pre><code class="python">
        class GestionActualites:
            def __init__(self):
                self.__articles = []  # Liste privée d'articles
        
            def ajouter_article(self, article):
                if isinstance(article, Article):
                    self.__articles.append(article)
                else:
                    print("Erreur : L'objet doit être une instance de la classe Article.")
        
            def supprimer_article(self, titre):
                for article in self.__articles:
                    if article.titre == titre:
                        self.__articles.remove(article)
                        print(f"L'article '{titre}' a été supprimé.")
                        return
                print(f"Erreur : Aucun article trouvé avec le titre '{titre}'.")
        
            def afficher_articles(self):
                if not self.__articles:
                    print("Aucun article disponible.")
                    return
                for article in self.__articles:
                    print(f"Titre : {article.titre}")
                    print(f"Auteur : {article.auteur}")
                    print(f"Date : {article.date_publication.strftime('%Y-%m-%d')}")
                    print(f"Contenu : {article.contenu}")
                    print("-" * 40)
            </code></pre>
        
            <h4>Test :</h4>
            <pre><code class="python">
        # Gestion des actualités
        gestion = GestionActualites()
        
        # Création d'articles
        article1 = Article("Titre 1", "Bob", "Contenu 1", "2025-01-02")
        article2 = Article("Titre 2", "Alice", "Contenu 2", "2025-01-03")
        
        # Ajout des articles
        gestion.ajouter_article(article1)
        gestion.ajouter_article(article2)
        
        # Affichage des articles
        gestion.afficher_articles()
        
        # Suppression d'un article
        gestion.supprimer_article("Titre 1")
        gestion.afficher_articles()
            </code></pre>
        
            <h3>Étape 3 : Sécurisation des Opérations (30 min)</h3>
            <p>
                Ajoutez des fonctionnalités supplémentaires pour protéger les données :
            </p>
            <ul>
                <li>Empêcher l’ajout d’un article avec un titre déjà existant.</li>
                <li>Ajouter une méthode pour rechercher un article par auteur ou par date.</li>
            </ul>
        
            <h4>Exemple :</h4>
            <pre><code class="python">
        def rechercher_articles_par_auteur(self, auteur):
            resultats = [article for article in self.__articles if article.auteur == auteur]
            if resultats:
                for article in resultats:
                    print(f"Titre : {article.titre}")
            else:
                print(f"Aucun article trouvé pour l'auteur '{auteur}'.")
            </code></pre>
        
            <h3>Conclusion :</h3>
            <ul>
                <li>Les élèves auront appris à protéger les données sensibles en utilisant des attributs privés et des getters/setters.</li>
                <li>Ils auront mis en œuvre une logique métier dans une application réelle.</li>
                <li>Ils auront exploré des scénarios pratiques de gestion d’actualité tout en assurant la sécurité et la validité des données.</li>
            </ul>
        </section>

        <section id="session69" class="content-section">
            <h2>Séance 69 : Révision des Concepts de Sécurité et Cryptographie</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Cette séance a pour but de réviser les concepts fondamentaux de la sécurité informatique et de la cryptographie. Les élèves consolideront leurs connaissances sur les notions de sécurité des données, d’algorithmes cryptographiques et de bonnes pratiques en matière de sécurité.
            </p>
        
            <h3>Partie 1 : Concepts Fondamentaux de la Sécurité (30 min)</h3>
        
            <h4>1. Principes de Sécurité Informatique :</h4>
            <p>
                Les trois piliers de la sécurité informatique sont :
            </p>
            <ul>
                <li><strong>Confidentialité :</strong> Garantir que les données sont accessibles uniquement aux personnes autorisées.</li>
                <li><strong>Intégrité :</strong> Assurer que les données n’ont pas été modifiées ou altérées de manière non autorisée.</li>
                <li><strong>Disponibilité :</strong> Garantir que les données et les systèmes sont accessibles lorsque nécessaire.</li>
            </ul>
        
            <h4>2. Menaces Courantes :</h4>
            <p>
                Les élèves doivent comprendre les menaces auxquelles un système peut être confronté :
            </p>
            <ul>
                <li><strong>Phishing :</strong> Tentative de voler des informations sensibles via des communications frauduleuses.</li>
                <li><strong>Attaques par force brute :</strong> Essayer toutes les combinaisons possibles pour deviner un mot de passe.</li>
                <li><strong>Malware :</strong> Programmes malveillants conçus pour nuire, comme les virus, les ransomwares et les chevaux de Troie.</li>
            </ul>
        
            <h4>3. Bonnes Pratiques en Sécurité :</h4>
            <ul>
                <li>Utiliser des mots de passe complexes et uniques pour chaque compte.</li>
                <li>Activer l’authentification à deux facteurs (2FA).</li>
                <li>Maintenir les logiciels et systèmes à jour.</li>
                <li>Éviter de cliquer sur des liens suspects ou d’ouvrir des pièces jointes inconnues.</li>
            </ul>
        
            <h3>Partie 2 : Révision des Concepts de Cryptographie (40 min)</h3>
        
            <h4>1. Définitions Clés :</h4>
            <ul>
                <li><strong>Cryptographie :</strong> L’art de protéger les informations en les rendant illisibles pour toute personne non autorisée.</li>
                <li><strong>Clé :</strong> Une donnée utilisée pour chiffrer ou déchiffrer des informations.</li>
                <li><strong>Chiffrement Symétrique :</strong> Utilisation d’une clé unique pour le chiffrement et le déchiffrement.</li>
                <li><strong>Chiffrement Asymétrique :</strong> Utilisation d’une paire de clés (publique et privée) pour le chiffrement et le déchiffrement.</li>
            </ul>
        
            <h4>2. Algorithmes Cryptographiques :</h4>
            <ul>
                <li><strong>Chiffrement Symétrique :</strong> 
                    <ul>
                        <li><strong>AES (Advanced Encryption Standard) :</strong> Algorithme rapide et sécurisé pour le chiffrement des données.</li>
                        <li><strong>DES (Data Encryption Standard) :</strong> Ancien standard remplacé par AES, considéré comme moins sûr aujourd’hui.</li>
                    </ul>
                </li>
                <li><strong>Chiffrement Asymétrique :</strong> 
                    <ul>
                        <li><strong>RSA :</strong> Utilisé pour sécuriser les communications (par ex., HTTPS).</li>
                        <li><strong>Elliptic Curve Cryptography (ECC) :</strong> Alternative efficace à RSA avec des clés plus courtes.</li>
                    </ul>
                </li>
                <li><strong>Fonctions de Hachage :</strong>
                    <ul>
                        <li><strong>SHA-256 :</strong> Algorithme de hachage utilisé dans la blockchain.</li>
                        <li><strong>MD5 :</strong> Ancien algorithme de hachage désormais considéré comme peu sécurisé.</li>
                    </ul>
                </li>
            </ul>
        
            <h4>3. Exercice Pratique :</h4>
            <p>Les élèves devront mettre en œuvre les concepts de cryptographie en Python.</p>
            <pre><code class="python">
        # Exemple de chiffrement symétrique avec Fernet (bibliothèque cryptography)
        from cryptography.fernet import Fernet
        
        # Générer une clé
        cle = Fernet.generate_key()
        cipher_suite = Fernet(cle)
        
        # Chiffrer un message
        message = b"Secret important"
        chiffre = cipher_suite.encrypt(message)
        print("Message chiffré :", chiffre)
        
        # Déchiffrer le message
        dechiffre = cipher_suite.decrypt(chiffre)
        print("Message déchiffré :", dechiffre.decode())
            </code></pre>
        
            <p><strong>Défi :</strong> Modifiez le programme pour que l’utilisateur entre son propre message et voyez comment il est chiffré puis déchiffré.</p>
        
            <h3>Partie 3 : Étude de Cas (30 min)</h3>
        
            <h4>Contexte :</h4>
            <p>
                Imaginez que vous travaillez pour une banque. Votre mission est de sécuriser les communications entre les employés et les serveurs de la banque en utilisant un chiffrement asymétrique.
            </p>
        
            <h4>Exercice :</h4>
            <p>Implémentez un système de chiffrement et de déchiffrement RSA en Python.</p>
            <pre><code class="python">
        from Crypto.PublicKey import RSA
        from Crypto.Cipher import PKCS1_OAEP
        
        # Générer une paire de clés RSA
        cle_privee = RSA.generate(2048)
        cle_publique = cle_privee.publickey()
        
        # Message à chiffrer
        message = b"Transaction confidentielle"
        
        # Chiffrement avec la clé publique
        cipher = PKCS1_OAEP.new(cle_publique)
        chiffre = cipher.encrypt(message)
        print("Message chiffré :", chiffre)
        
        # Déchiffrement avec la clé privée
        decrypt_cipher = PKCS1_OAEP.new(cle_privee)
        dechiffre = decrypt_cipher.decrypt(chiffre)
        print("Message déchiffré :", dechiffre.decode())
            </code></pre>
        
            <p><strong>Défi :</strong> Ajoutez une validation des signatures numériques pour garantir que le message provient d’un expéditeur légitime.</p>
        
            <h3>Conclusion :</h3>
            <p>
                À la fin de cette séance, les élèves auront révisé les concepts fondamentaux de la sécurité et de la cryptographie. Ils auront appliqué ces notions dans des exercices pratiques, consolidant leur compréhension des menaces, des algorithmes cryptographiques et des bonnes pratiques de sécurité.
            </p>
        </section>

        <section id="session70" class="content-section">
            <h2>Séance 70 : Introduction aux Architectures Matérielles, fonctionnement du Processeur et des Bus</h2>
        
            <h3>Objectif Global :</h3>
            <p>Les élèves découvriront les bases des architectures matérielles des ordinateurs. Ils apprendront à comprendre comment un ordinateur est structuré et comment ses composants interagissent pour exécuter des instructions. La séance mettra l’accent sur la structure de Von Neumann et ses implications pratiques.</p>
        
            <a href="https://eduscol.education.fr/document/7283/download" target="_blank" rel="noopener noreferrer">Ressources Eduscol</a>

            <h3>Plan de la Séance :</h3>
            <ul>
                <li><strong>Introduction aux architectures matérielles.</strong></li>
                <li><strong>Présentation de l'architecture de Von Neumann.</strong></li>
                <li><strong>Principaux composants matériels d’un ordinateur.</strong></li>
                <li><strong>Étude de cas : Cycle d’exécution d’une instruction.</strong></li>
                <li><strong>Atelier pratique : Simulation du fonctionnement matériel.</strong></li>
            </ul>
        
            <h3>1. Introduction aux Architectures Matérielles (20 min)</h3>
        
            <h4>Qu’est-ce qu’une architecture matérielle ?</h4>
            <p>
                Une architecture matérielle définit l’organisation des composants physiques (matériel) d’un ordinateur et la manière dont ces composants interagissent pour exécuter des programmes. Elle est composée de plusieurs parties principales, telles que :
            </p>
            <ul>
                <li>Le processeur (CPU).</li>
                <li>La mémoire (RAM, ROM, etc.).</li>
                <li>Les périphériques d’entrée et de sortie.</li>
                <li>Les bus (chemins de communication entre les composants).</li>
            </ul>
        
            <h4>Pourquoi est-ce important ?</h4>
            <p>
                Comprendre les architectures matérielles permet de :
            </p>
            <ul>
                <li>Savoir comment les programmes interagissent avec le matériel.</li>
                <li>Optimiser les performances des applications.</li>
                <li>Résoudre des problèmes liés au matériel et au logiciel.</li>
            </ul>
        
            <h3>2. Présentation de l'Architecture de Von Neumann (30 min)</h3>
        
            <h4>Concept clé :</h4>
            <p>
                L’architecture de Von Neumann est un modèle de base pour les ordinateurs modernes. Elle repose sur l’idée que les programmes et les données sont stockés dans une même mémoire accessible au processeur.
            </p>
        
            <h4>Structure de Von Neumann :</h4>
            <p>Voici les composants principaux :</p>
            <ul>
                <li><strong>Unité de traitement :</strong> Inclut l’Unité de Contrôle (UC) et l’Unité Arithmétique et Logique (ALU).</li>
                <li><strong>Mémoire :</strong> Stocke les programmes et les données.</li>
                <li><strong>Entrées/Sorties :</strong> Permettent la communication avec l’extérieur (clavier, écran, etc.).</li>
                <li><strong>Bus :</strong> Moyen de communication entre les composants.</li>
            </ul>
        
            <h4>Schéma de Von Neumann :</h4>
            <pre><code>
            Entrées  --->  Processeur  --->  Sorties
                               |
                          Mémoire
            </code></pre>
        
            <h4>Limitation principale :</h4>
            <p>
                Le "goulot d’étranglement de Von Neumann" : le processeur doit attendre que la mémoire transfère les instructions et les données, ce qui ralentit les performances.
            </p>
        
            <h3>3. Principaux Composants Matériels (30 min)</h3>
        
            <h4>1. Processeur (CPU) :</h4>
            <ul>
                <li><strong>Unité de Contrôle (UC) :</strong> Gère l’exécution des instructions.</li>
                <li><strong>Unité Arithmétique et Logique (ALU) :</strong> Effectue les calculs et les opérations logiques.</li>
            </ul>
        
            <h4>2. Mémoire :</h4>
            <ul>
                <li><strong>RAM :</strong> Mémoire volatile utilisée pour stocker les données et instructions en cours d’utilisation.</li>
                <li><strong>ROM :</strong> Mémoire non volatile contenant des instructions permanentes.</li>
                <li><strong>Mémoire cache :</strong> Mémoire rapide pour stocker des données fréquemment utilisées.</li>
            </ul>
        
            <h4>3. Périphériques :</h4>
            <ul>
                <li><strong>Entrée :</strong> Clavier, souris, capteurs.</li>
                <li><strong>Sortie :</strong> Écran, imprimante, haut-parleurs.</li>
            </ul>
        
            <h4>4. Bus :</h4>
            <ul>
                <li><strong>Bus de données :</strong> Transporte les données.</li>
                <li><strong>Bus d’adresse :</strong> Indique où les données doivent être envoyées.</li>
                <li><strong>Bus de contrôle :</strong> Coordonne les opérations entre les composants.</li>
            </ul>
        
            <h3>4. Étude de Cas : Cycle d’Exécution d’une Instruction (20 min)</h3>
        
            <h4>Cycle de base :</h4>
            <p>
                Une instruction dans un ordinateur suit trois étapes principales :
            </p>
            <ol>
                <li><strong>Fetch :</strong> L’unité de contrôle récupère l’instruction depuis la mémoire.</li>
                <li><strong>Decode :</strong> L’instruction est déchiffrée pour déterminer l’opération à effectuer.</li>
                <li><strong>Execute :</strong> L’ALU exécute l’instruction.</li>
            </ol>
        
            <h4>Exemple d’une addition :</h4>
            <p>Considérons une instruction pour additionner deux nombres stockés en mémoire :</p>
            <ul>
                <li><strong>Fetch :</strong> Récupérer l’instruction "ajouter A et B".</li>
                <li><strong>Decode :</strong> Déchiffrer l’instruction pour savoir que c’est une addition.</li>
                <li><strong>Execute :</strong> Effectuer l’opération A + B et stocker le résultat.</li>
            </ul>
        
            <h3>5. Atelier Pratique : Simulation (20 min)</h3>
        
            <h4>Objectif :</h4>
            <p>
                Les élèves simuleront le fonctionnement d’une architecture matérielle en utilisant des listes et des fonctions en Python.
            </p>
        
            <h4>Exercice :</h4>
            <p>Écrivez un programme qui simule l’exécution d’instructions dans un modèle simplifié de Von Neumann.</p>
        
            <h4>Exemple de Code :</h4>
            <pre><code class="python">
        # Simulation de l'architecture de Von Neumann
        memoire = [10, 20, "ADD", 0]  # Instructions et données
        accumulateur = 0  # Stockage temporaire des calculs
        
        def fetch(memoire, pc):
            """Récupère l'instruction à l'adresse PC"""
            return memoire[pc]
        
        def decode(instruction):
            """Décode l'instruction"""
            return instruction
        
        def execute(instruction, memoire):
            """Exécute l'instruction"""
            global accumulateur
            if instruction == "ADD":
                accumulateur = memoire[0] + memoire[1]
                memoire[3] = accumulateur
            return accumulateur
        
        # Cycle d'exécution
        pc = 2  # Pointeur de l'instruction actuelle
        instruction = fetch(memoire, pc)
        decoded_instruction = decode(instruction)
        resultat = execute(decoded_instruction, memoire)
        
        print(f"Résultat de l'addition : {resultat}")  # 30
            </code></pre>
        
            <h4>Questions pour les élèves :</h4>
            <ul>
                <li>Quels composants matériels sont simulés dans ce programme ?</li>
                <li>Comment améliorer le programme pour inclure plusieurs instructions ?</li>
            </ul>
            <hr>
            <h2>Fonctionnement du Processeur et des Bus</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Comprendre le fonctionnement interne d’un processeur, son interaction avec les bus (bus de données, bus d’adresse, bus de contrôle) et leur rôle dans l’exécution des instructions. Cette séance vise à fournir une base théorique solide complétée par des exemples pratiques et des démonstrations simples.
            </p>
        
            <h3>Introduction :</h3>
            <p>
                Le processeur (CPU - Central Processing Unit) est souvent décrit comme le cerveau de l'ordinateur. Il exécute les instructions des programmes en manipulant des données. Pour fonctionner efficacement, le processeur utilise les <strong>bus</strong>, qui sont des voies de communication permettant l’échange d’informations avec la mémoire et les périphériques.
            </p>
        
            <h4>Les principaux composants du processeur :</h4>
            <ul>
                <li><strong>Unité de contrôle :</strong> Elle dirige le flux des données et des instructions à travers le processeur.</li>
                <li><strong>Unité arithmétique et logique (ALU) :</strong> Elle exécute les calculs mathématiques et les comparaisons logiques.</li>
                <li><strong>Registres :</strong> Ce sont de petites mémoires ultra-rapides utilisées pour stocker temporairement des données et des instructions.</li>
            </ul>
        
            <h3>Les Bus : Rôles et Types</h3>
            <p>
                Les bus sont des ensembles de lignes de communication utilisées pour transmettre des données, des adresses et des signaux de contrôle entre les composants de l’ordinateur.
            </p>
        
            <h4>Les trois principaux types de bus :</h4>
            <ul>
                <li><strong>Bus de données :</strong> Transporte les données entre le processeur, la mémoire et les périphériques.</li>
                <li><strong>Bus d’adresse :</strong> Indique l’adresse mémoire ou le périphérique à utiliser pour une opération.</li>
                <li><strong>Bus de contrôle :</strong> Transporte les signaux de commande (lecture, écriture, interruption, etc.).</li>
            </ul>
        
            <h4>Illustration :</h4>
            <p>Voici un schéma simplifié d’un système avec un processeur, une mémoire et des bus :</p>
            <pre><code>
        +-------------+       +-------------------+
        |             |       |                   |
        | Processeur  |=======|       Mémoire     |
        |             |       |                   |
        +-------------+       +-------------------+
           ||  ||  ||
           ||  ||  ||    Bus de données
           ||  ||  ||
           ||  ||       Bus d’adresse
           ||           Bus de contrôle
            </code></pre>
        
            <h3>Étape 1 : Comprendre le Cycle Machine (30 min)</h3>
            <p>
                Le cycle machine est le processus par lequel le processeur exécute les instructions. Il est composé de trois phases principales :
            </p>
            <ul>
                <li><strong>Phase 1 : Récupération (Fetch)</strong> – Le processeur récupère l’instruction depuis la mémoire.</li>
                <li><strong>Phase 2 : Décodage (Decode)</strong> – L’instruction est décomposée pour comprendre l’opération à effectuer.</li>
                <li><strong>Phase 3 : Exécution (Execute)</strong> – Le processeur exécute l’instruction (calcul, transfert de données, etc.).</li>
            </ul>
        
            <h4>Exemple Pratique :</h4>
            <p>
                Imaginez une instruction simple : charger la valeur 42 dans un registre. Voici comment le processeur traite cette instruction :
            </p>
            <ol>
                <li><strong>Fetch :</strong> L’instruction est récupérée de la mémoire et placée dans un registre d’instruction.</li>
                <li><strong>Decode :</strong> L’unité de contrôle identifie qu’il s’agit d’une opération de chargement.</li>
                <li><strong>Execute :</strong> La valeur 42 est transférée dans le registre spécifié.</li>
            </ol>
        
            <h3>Étape 2 : Interaction entre Processeur et Bus (40 min)</h3>
        
            <h4>Exemple d’interaction :</h4>
            <p>
                Le processeur souhaite lire une valeur située à une adresse mémoire spécifique. Voici les étapes impliquant les bus :
            </p>
            <ol>
                <li><strong>Bus d’adresse :</strong> Le processeur place l’adresse mémoire sur le bus d’adresse.</li>
                <li><strong>Bus de contrôle :</strong> Le processeur envoie un signal de lecture (READ).</li>
                <li><strong>Bus de données :</strong> La mémoire renvoie la valeur demandée au processeur via le bus de données.</li>
            </ol>
        
            <h4>Exercice :</h4>
            <p>
                Simulez les étapes ci-dessus à l’aide de pseudo-code ou de schémas simples. Par exemple :
            </p>
            <pre><code class="python">
        # Simulation de lecture mémoire
        adresse = 0x10A  # Adresse mémoire
        print(f"Placer l'adresse {adresse} sur le bus d'adresse.")
        print("Envoyer un signal READ sur le bus de contrôle.")
        valeur = memoire[adresse]  # Lecture dans la mémoire simulée
        print(f"La valeur {valeur} est reçue via le bus de données.")
            </code></pre>
        
            <h3>Étape 3 : Défi Pratique (30 min)</h3>
        
            <h4>Exercice :</h4>
            <p>
                Créez une simulation simplifiée d’un processeur, de la mémoire et des bus. Les étapes doivent inclure :
            </p>
            <ul>
                <li>Récupération d’une instruction depuis la mémoire.</li>
                <li>Décodage de l’instruction.</li>
                <li>Exécution d’une opération simple (addition, soustraction, etc.).</li>
            </ul>
        
            <h4>Exemple de Structure Python :</h4>
            <pre><code class="python">
        class Memoire:
            def __init__(self):
                self.stockage = {0x10A: 42, 0x10B: 18}  # Exemple de mémoire
        
            def lire(self, adresse):
                return self.stockage.get(adresse, 0)
        
        class Processeur:
            def __init__(self, memoire):
                self.memoire = memoire
                self.registre = 0  # Registre unique pour cet exemple
        
            def executer(self, adresse):
                print(f"Placer l'adresse {adresse} sur le bus d'adresse.")
                valeur = self.memoire.lire(adresse)
                print(f"Lire la valeur {valeur} via le bus de données.")
                self.registre = valeur
                print(f"Valeur {valeur} stockée dans le registre.")
        
        # Simulation
        memoire = Memoire()
        processeur = Processeur(memoire)
        
        processeur.executer(0x10A)  # Charge la valeur 42
        processeur.executer(0x10B)  # Charge la valeur 18
            </code></pre>
        
            <h3>Conclusion :</h3>
            <p>
                À la fin de cette séance, les élèves auront appris :
            </p>
            <ul>
                <li>Les rôles principaux du processeur (récupération, décodage, exécution).</li>
                <li>Comment les bus permettent la communication entre les composants d’un ordinateur.</li>
                <li>À simuler des interactions processeur-mémoire pour mieux comprendre leur fonctionnement.</li>
            </ul>
            <p>Ce cours constitue une base solide pour comprendre les architectures informatiques et leur fonctionnement interne.</p>
        </section>

        <section id="session71" class="content-section">
            <h2>Séance 71 : Introduction aux Systèmes d’Exploitation</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Cette séance vise à familiariser les élèves avec les concepts de base des systèmes d’exploitation (OS). Ils apprendront :
            </p>
        
            <h3>1. Qu’est-ce qu’un Système d’Exploitation ? (30 min)</h3>
        
            <h4>Définition :</h4>
            <p>
                Un système d’exploitation (Operating System ou OS) est un logiciel qui agit comme une interface entre l’utilisateur, le matériel et les logiciels. Il permet de gérer les ressources matérielles et logicielles de manière efficace.
            </p>
        
            <h4>Rôles principaux :</h4>
            <ul>
                <li><strong>Gestion du matériel :</strong> Coordonne l’utilisation des ressources matérielles comme le processeur, la mémoire, les disques durs et les périphériques.</li>
                <li><strong>Gestion des logiciels :</strong> Exécute les applications et assure la communication entre elles.</li>
                <li><strong>Interface utilisateur :</strong> Fournit un moyen pour les utilisateurs d’interagir avec l’ordinateur (ligne de commande ou interface graphique).</li>
            </ul>
        
            <h4>Exemples de Systèmes d’Exploitation :</h4>
            <ul>
                <li><strong>Pour les ordinateurs :</strong> Windows, macOS, Linux.</li>
                <li><strong>Pour les smartphones :</strong> Android, iOS.</li>
                <li><strong>Pour les systèmes embarqués :</strong> FreeRTOS, VxWorks.</li>
            </ul>
        
            <h4>Diagramme Simplifié :</h4>
            <p>
                Voici une représentation simplifiée des interactions dans un système d’exploitation :
            </p>
            <pre><code>
        Utilisateur ↔ Système d’Exploitation ↔ Matériel
            </code></pre>
        
            <h3>2. Les Principaux Composants d’un OS (40 min)</h3>
        
            <h4>1. Le Kernel :</h4>
            <p>
                Le cœur de l’OS. Il gère directement les ressources matérielles et offre des services de base aux autres parties du système. Il est responsable de :
            </p>
            <ul>
                <li>La gestion des processus (création, planification, terminaison).</li>
                <li>La gestion de la mémoire (allocation et libération).</li>
                <li>Le contrôle des périphériques.</li>
            </ul>
        
            <h4>2. La Gestion des Processus :</h4>
            <p>
                Un processus est un programme en cours d'exécution. L’OS doit :
            </p>
            <ul>
                <li>Créer et planifier les processus.</li>
                <li>Attribuer des ressources (CPU, mémoire).</li>
                <li>Gérer les processus concurrents (multitâche).</li>
            </ul>
        
            <h4>3. La Gestion de la Mémoire :</h4>
            <p>
                L’OS gère l’accès à la mémoire vive (RAM) pour éviter les conflits et optimiser les performances. Principales tâches :
            </p>
            <ul>
                <li>Allocation et libération de mémoire.</li>
                <li>Gestion de la mémoire virtuelle (échange entre RAM et disque).</li>
            </ul>
        
            <h4>4. Le Système de Fichiers :</h4>
            <p>
                L’OS organise les données sur les disques sous forme de fichiers et de dossiers. Principales responsabilités :
            </p>
            <ul>
                <li>Création, lecture, écriture et suppression de fichiers.</li>
                <li>Organisation hiérarchique des fichiers.</li>
                <li>Contrôle des permissions (lecture, écriture, exécution).</li>
            </ul>
        
            <h4>5. Les Périphériques :</h4>
            <p>
                L’OS gère les interactions entre les périphériques (clavier, souris, imprimante) et les logiciels.
            </p>
        
            <h3>3. Activité Pratique : Exploration d’un Système d’Exploitation (40 min)</h3>
        
            <h4>Objectif :</h4>
            <p>
                Les élèves exploreront un OS (Windows, macOS ou Linux) pour observer les concepts vus en théorie.
            </p>
        
            <h4>Étape 1 : Découvrir le Gestionnaire de Tâches ou l’Équivalent</h4>
            <ul>
                <li>Ouvrir le gestionnaire de tâches (Ctrl + Shift + Esc sous Windows, "Activity Monitor" sous macOS, ou <code>top</code> sous Linux).</li>
                <li>Identifier les processus actifs, leur utilisation du processeur et de la mémoire.</li>
                <li>Observer les processus du système vs les processus utilisateur.</li>
            </ul>
        
            <h4>Étape 2 : Explorer le Système de Fichiers</h4>
            <ul>
                <li>Naviguer dans les fichiers via l’explorateur (ou le gestionnaire de fichiers).</li>
                <li>Créer, modifier et supprimer des fichiers/dossiers.</li>
                <li>Observer les permissions (sous Linux : <code>ls -l</code>).</li>
            </ul>
        
            <h4>Étape 3 : Observation des Périphériques</h4>
            <ul>
                <li>Afficher les périphériques connectés (imprimantes, disques, etc.).</li>
                <li>Sous Windows : Gestionnaire de périphériques.</li>
                <li>Sous Linux : Commandes <code>lsblk</code> ou <code>lspci</code>.</li>
            </ul>
        
            <h3>4. Discussion et Réflexion (10 min)</h3>
            <ul>
                <li>Pourquoi est-il important de comprendre le fonctionnement d’un système d’exploitation ?</li>
                <li>Quels aspects du système d’exploitation sont les plus visibles pour un utilisateur ?</li>
                <li>Quels types de problèmes peuvent être évités grâce à une bonne gestion des ressources par l’OS ?</li>
            </ul>
            <hr>
            <h2>Gestion des Processus dans un Système d’Exploitation</h2>

            <h3>1. Qu’est-ce qu’un Processus ?</h3>
            <p>Un processus est une instance d’un programme en cours d’exécution. Lorsqu’un programme est lancé, il devient un processus, c’est-à-dire une entité dynamique qui utilise des ressources matérielles et logicielles.</p>

            <h4>États d’un processus :</h4>
            <ul>
                <li><strong>Nouveau :</strong> Le processus est en cours de création.</li>
                <li><strong>Prêt :</strong> Le processus attend d’être exécuté par le processeur.</li>
                <li><strong>En cours d’exécution :</strong> Le processus utilise actuellement le processeur.</li>
                <li><strong>En attente :</strong> Le processus attend une ressource ou un événement.</li>
                <li><strong>Terminé :</strong> Le processus a fini son exécution.</li>
            </ul>

            <h3>2. Planification des Processus</h3>
            <p>Le système d’exploitation utilise un <strong>ordonnanceur</strong> pour décider quel processus sera exécuté par le processeur. L’objectif est de maximiser l’efficacité et de minimiser le temps d’attente.</p>

            <h4>Exemples d’algorithmes de planification :</h4>
            <ul>
                <li><strong>First-Come, First-Served (FCFS) :</strong> Les processus sont exécutés dans l’ordre où ils arrivent.</li>
                <li><strong>Round-Robin (RR) :</strong> Chaque processus a une "quantum" de temps fixe pour s’exécuter, après quoi il retourne dans la file d’attente.</li>
                <li><strong>Priorité :</strong> Les processus ayant une priorité plus élevée sont exécutés en premier.</li>
            </ul>

            <h3>3. Activité Pratique : Observation des Processus</h3>
            <h4>Étape 1 : Utiliser le Gestionnaire de Tâches (ou Équivalent)</h4>
            <ul>
                <li>Sous Windows : Ouvrir le gestionnaire de tâches (Ctrl + Shift + Esc).</li>
                <li>Sous Linux : Utiliser la commande <code>top</code> ou <code>htop</code>.</li>
                <li>Sous macOS : Utiliser "Activity Monitor".</li>
            </ul>
            <p>Questions pour les élèves :</p>
            <ul>
                <li>Quels sont les processus en cours d’exécution ?</li>
                <li>Quels processus consomment le plus de ressources CPU et mémoire ?</li>
            </ul>

            <h4>Étape 2 : Simulation avec Python</h4>
            <p>
                Créez un script Python qui simule la gestion de plusieurs processus en utilisant des threads.
            </p>
            <pre><code class="python">
        import threading
        import time

        def processus(nom):
            print(f"Le processus {nom} commence.")
            time.sleep(2)
            print(f"Le processus {nom} se termine.")

        # Création de threads pour simuler des processus
        threads = []
        for i in range(3):
            t = threading.Thread(target=processus, args=(f"Processus-{i+1}",))
            threads.append(t)
            t.start()

        # Attendre la fin de tous les processus
        for t in threads:
            t.join()

        print("Tous les processus sont terminés.")
            </code></pre>

            <h3>4. Discussion et Conclusion</h3>
            <ul>
                <li>Comment le système d’exploitation gère-t-il les processus pour éviter les conflits ?</li>
                <li>Quels sont les avantages et les inconvénients des différents algorithmes de planification ?</li>
            </ul>
            <hr>
            <h2>Gestion de la Mémoire dans un Système d’Exploitation</h2>

            <h3>1. Introduction à la Gestion de la Mémoire</h3>
            <p>
                L’un des rôles principaux d’un système d’exploitation est de gérer l’utilisation de la mémoire vive (RAM) par les processus. Chaque processus a besoin de mémoire pour stocker ses données et son code.
            </p>

            <h4>Problèmes à résoudre :</h4>
            <ul>
                <li>Éviter les conflits entre les processus.</li>
                <li>Maximiser l’utilisation de la mémoire disponible.</li>
                <li>Gérer les processus dont la taille dépasse celle de la mémoire physique.</li>
            </ul>

            <h3>2. La Mémoire Virtuelle</h3>
            <p>
                La mémoire virtuelle permet de simuler une mémoire plus grande que la mémoire physique (RAM) en utilisant le disque dur. Cela permet d’exécuter des programmes nécessitant plus de mémoire que ce qui est physiquement disponible.
            </p>

            <h4>Pagination :</h4>
            <p>
                La mémoire est divisée en blocs appelés <strong>pages</strong>. Les pages actives sont chargées en mémoire vive, tandis que les pages inactives restent sur le disque.
            </p>

            <h3>3. Activité Pratique : Simuler la Pagination</h3>
            <p>
                Créez un programme Python qui simule un système de pagination. Vous pouvez utiliser un tableau pour représenter la mémoire physique et une file d’attente pour représenter les pages en attente.
            </p>
            <pre><code class="python">
        from collections import deque

        # Simulation de la mémoire
        taille_memoire = 3  # Nombre maximum de pages en mémoire
        memoire = deque()

        # Fonction pour charger une page
        def charger_page(page):
            if page not in memoire:
                if len(memoire) >= taille_memoire:
                    memoire.popleft()  # Retirer la page la plus ancienne
                memoire.append(page)
            print(f"Mémoire actuelle : {list(memoire)}")

        # Simulation de chargement de pages
        pages = [1, 2, 3, 4, 2, 5, 1, 3]
        for p in pages:
            print(f"Chargement de la page {p}")
            charger_page(p)
            </code></pre>

            <h3>4. Discussion</h3>
            <ul>
                <li>Quels sont les avantages de la mémoire virtuelle ?</li>
                <li>Quelles sont les limites d’un système de pagination ?</li>
            </ul>
        </section>

        <section id="session72" class="content-section">
            <h2>Séance 72 : Bases de l’Utilisation de Linux</h2>

            <h3>Objectifs :</h3>
            <ul>
                <li>Comprendre ce qu’est Linux et pourquoi il est utilisé.</li>
                <li>Découvrir l’interface en ligne de commande (CLI).</li>
                <li>Apprendre les commandes de base pour naviguer, manipuler des fichiers et gérer le système.</li>
            </ul>

            <h3>1. Qu’est-ce que Linux ?</h3>
            <p>
                Linux est un système d’exploitation open-source, souvent utilisé dans les serveurs, l’embarqué, et comme OS principal pour les développeurs.
            </p>

            <h4>Caractéristiques :</h4>
            <ul>
                <li><strong>Open-source :</strong> Le code source est accessible à tous.</li>
                <li><strong>Sécurisé :</strong> Conçu pour être robuste et résistant aux attaques.</li>
                <li><strong>Multi-utilisateur :</strong> Plusieurs utilisateurs peuvent utiliser le système simultanément.</li>
                <li><strong>Personnalisable :</strong> De nombreuses distributions (Ubuntu, Fedora, Debian) existent pour différents besoins.</li>
            </ul>

            <h4>Pourquoi apprendre Linux ?</h4>
            <ul>
                <li>Utilisé dans de nombreux serveurs, appareils IoT, et environnements de développement.</li>
                <li>Offre un contrôle précis grâce à l’interface en ligne de commande (CLI).</li>
                <li>Favorise une compréhension profonde du fonctionnement des systèmes d’exploitation.</li>
            </ul>

            <h3>2. Interface en Ligne de Commande (CLI) (20 min)</h3>
            <p>La ligne de commande est une interface où vous pouvez saisir des instructions textuelles pour interagir avec le système.</p>

            <h4>Premiers Pas :</h4>
            <a href="https://distrosea.com/fr/start/ubuntu-24.10-default/" target="_blank" rel="noopener noreferrer">Allez sur ce site</a>
            <ul>
                <li>Ouvrir un terminal (Ctrl + Alt + T sous Ubuntu).</li>
                <li>Tester une commande simple : <code>ls</code> (liste les fichiers du répertoire courant).</li>
                <li>Affichage de l’invite de commande : <code>user@machine:~$</code> (indique l’utilisateur et le répertoire actuel).</li>
            </ul>

            <h4>Quelques Commandes de Base :</h4>
            <table>
                <thead>
                    <tr>
                        <th>Commande</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>pwd</code></td>
                        <td>Affiche le répertoire courant.</td>
                    </tr>
                    <tr>
                        <td><code>ls</code></td>
                        <td>Liste les fichiers et dossiers du répertoire courant.</td>
                    </tr>
                    <tr>
                        <td><code>cd [dossier]</code></td>
                        <td>Change le répertoire actuel.</td>
                    </tr>
                    <tr>
                        <td><code>touch [fichier]</code></td>
                        <td>Crée un fichier vide.</td>
                    </tr>
                    <tr>
                        <td><code>mkdir [dossier]</code></td>
                        <td>Crée un dossier.</td>
                    </tr>
                    <tr>
                        <td><code>rm [fichier]</code></td>
                        <td>Supprime un fichier.</td>
                    </tr>
                    <tr>
                        <td><code>rmdir [dossier]</code></td>
                        <td>Supprime un dossier vide.</td>
                    </tr>
                </tbody>
            </table>

            <h3>3. Activité Pratique : Manipulation de Fichiers et Répertoires (30 min)</h3>
            <h4>Objectif :</h4>
            <p>Les élèves doivent pratiquer les commandes de base pour naviguer et manipuler des fichiers et dossiers.</p>

            <h4>Étapes :</h4>
            <ol>
                <li>Afficher le répertoire courant avec <code>pwd</code>.</li>
                <li>Créer un répertoire appelé <code>projet</code> avec <code>mkdir projet</code>.</li>
                <li>Naviguer dans ce répertoire avec <code>cd projet</code>.</li>
                <li>Créer un fichier <code>notes.txt</code> avec <code>touch notes.txt</code>.</li>
                <li>Lister les fichiers avec <code>ls</code>.</li>
                <li>Supprimer le fichier avec <code>rm notes.txt</code>.</li>
                <li>Revenir au répertoire parent avec <code>cd ..</code>.</li>
            </ol>

            <h3>4. Gestion des Droits et Permissions (20 min)</h3>
            <p>Linux utilise un système de permissions pour contrôler l’accès aux fichiers et répertoires.</p>

            <h4>Structure des Permissions :</h4>
            <pre><code>
        -rw-r--r--  1 user group 1234 date fichier.txt
            </code></pre>
            <ul>
                <li>Le premier caractère (<code>-</code>, <code>d</code>) indique si c’est un fichier ou un dossier.</li>
                <li>Les 9 caractères suivants indiquent les permissions pour :
                    <ul>
                        <li><strong>Utilisateur :</strong> propriétaire du fichier.</li>
                        <li><strong>Groupe :</strong> groupe auquel appartient le fichier.</li>
                        <li><strong>Autres :</strong> tous les autres utilisateurs.</li>
                    </ul>
                </li>
            </ul>

            <h4>Commandes Utiles :</h4>
            <table>
                <thead>
                    <tr>
                        <th>Commande</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>ls -l</code></td>
                        <td>Affiche les permissions des fichiers et dossiers.</td>
                    </tr>
                    <tr>
                        <td><code>chmod [permissions] [fichier]</code></td>
                        <td>Modifie les permissions.</td>
                    </tr>
                    <tr>
                        <td><code>chown [utilisateur] [fichier]</code></td>
                        <td>Change le propriétaire d’un fichier.</td>
                    </tr>
                </tbody>
            </table>

            <h3>5. Discussion et Réflexion (10 min)</h3>
            <ul>
                <li>Quels sont les avantages de l’utilisation de Linux pour les développeurs ?</li>
                <li>Pourquoi est-il important de comprendre les permissions des fichiers ?</li>
                <li>Quels sont les cas où l’utilisation de la CLI est préférable à une interface graphique ?</li>
            </ul>

            <h3>Conclusion :</h3>
            <p>
                À la fin de cette séance, les élèves auront acquis les bases pour utiliser Linux en ligne de commande. Ils seront capables de naviguer dans les répertoires, manipuler des fichiers et comprendre les permissions, des compétences fondamentales pour travailler dans des environnements de développement ou administrer des serveurs.
            </p>
            <hr>
            <h2>Approfondissement sur Linux</h2>

            <h3>Objectifs :</h3>
            <ul>
                <li>Explorer des concepts avancés, comme la gestion des utilisateurs et des processus.</li>
                <li>Comprendre les permissions, les groupes et les droits d’accès.</li>
                <li>Utiliser des outils courants pour surveiller et administrer un système Linux.</li>
            </ul>

            <h3>1. Gestion des Utilisateurs et Groupes (30 min)</h3>

            <h4>Concepts de Base :</h4>
            <p>
                Linux est un système multi-utilisateurs. Chaque utilisateur a un identifiant unique (UID) et appartient à un ou plusieurs groupes pour gérer ses permissions.
            </p>

            <h4>Commandes Essentielles :</h4>
            <table>
                <thead>
                    <tr>
                        <th>Commande</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>whoami</code></td>
                        <td>Affiche l'utilisateur connecté actuellement.</td>
                    </tr>
                    <tr>
                        <td><code>id</code></td>
                        <td>Affiche les informations de l'utilisateur et de ses groupes.</td>
                    </tr>
                    <tr>
                        <td><code>adduser [nom]</code></td>
                        <td>Ajoute un nouvel utilisateur.</td>
                    </tr>
                    <tr>
                        <td><code>deluser [nom]</code></td>
                        <td>Supprime un utilisateur.</td>
                    </tr>
                    <tr>
                        <td><code>usermod</code></td>
                        <td>Modifie les attributs d’un utilisateur.</td>
                    </tr>
                    <tr>
                        <td><code>groupadd [nom]</code></td>
                        <td>Ajoute un nouveau groupe.</td>
                    </tr>
                </tbody>
            </table>

            <h4>Activité Pratique :</h4>
            <ul>
                <li>Créer un utilisateur <code>testuser</code> avec <code>adduser testuser</code>.</li>
                <li>Attribuer cet utilisateur à un nouveau groupe <code>devs</code>.</li>
                <li>Vérifier ses groupes avec <code>id testuser</code>.</li>
            </ul>

            <h3>2. Permissions et Droits d’Accès (30 min)</h3>

            <h4>Structure des Permissions :</h4>
            <pre><code>
        -rwxr-xr--  1 user group 1234 date fichier.txt
            </code></pre>
            <ul>
                <li>Les trois blocs <code>rwx</code> représentent les permissions pour l’utilisateur, le groupe et les autres.</li>
                <li><code>r</code> : Lecture, <code>w</code> : Écriture, <code>x</code> : Exécution.</li>
            </ul>

            <h4>Commandes pour Modifier les Permissions :</h4>
            <table>
                <thead>
                    <tr>
                        <th>Commande</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>chmod [permissions] [fichier]</code></td>
                        <td>Change les permissions d’un fichier.</td>
                    </tr>
                    <tr>
                        <td><code>chown [utilisateur] [fichier]</code></td>
                        <td>Change le propriétaire d’un fichier.</td>
                    </tr>
                    <tr>
                        <td><code>chgrp [groupe] [fichier]</code></td>
                        <td>Change le groupe d’un fichier.</td>
                    </tr>
                </tbody>
            </table>

            <h4>Activité Pratique :</h4>
            <ul>
                <li>Créer un fichier <code>test.txt</code>.</li>
                <li>Modifier ses permissions pour le rendre accessible en lecture seule à tous les utilisateurs : <code>chmod 444 test.txt</code>.</li>
                <li>Changer le propriétaire du fichier avec <code>chown testuser test.txt</code>.</li>
            </ul>

            <h3>3. Gestion des Processus (30 min)</h3>

            <h4>Commandes Essentielles :</h4>
            <table>
                <thead>
                    <tr>
                        <th>Commande</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>ps</code></td>
                        <td>Affiche les processus en cours d'exécution pour l'utilisateur actuel.</td>
                    </tr>
                    <tr>
                        <td><code>top</code></td>
                        <td>Affiche les processus en temps réel.</td>
                    </tr>
                    <tr>
                        <td><code>kill [PID]</code></td>
                        <td>Termine un processus en utilisant son identifiant.</td>
                    </tr>
                    <tr>
                        <td><code>jobs</code></td>
                        <td>Liste les processus en arrière-plan pour l’utilisateur actuel.</td>
                    </tr>
                    <tr>
                        <td><code>fg</code></td>
                        <td>Ramène un processus en avant-plan.</td>
                    </tr>
                </tbody>
            </table>

            <h4>Activité Pratique :</h4>
            <ul>
                <li>Exécuter un programme en arrière-plan avec <code>sleep 60 &</code>.</li>
                <li>Identifier son PID avec <code>ps</code>.</li>
                <li>Terminer le processus avec <code>kill [PID]</code>.</li>
            </ul>

            <h3>4. Introduction à la Gestion des Paquets (20 min)</h3>

            <h4>Concept :</h4>
            <p>
                Linux utilise des gestionnaires de paquets pour installer, mettre à jour et supprimer des logiciels. Les gestionnaires les plus courants sont :
            </p>
            <ul>
                <li><strong>apt :</strong> Utilisé par les distributions basées sur Debian (ex : Ubuntu).</li>
                <li><strong>yum ou dnf :</strong> Utilisés par Fedora et CentOS.</li>
                <li><strong>pacman :</strong> Utilisé par Arch Linux.</li>
            </ul>

            <h4>Commandes Apt :</h4>
            <table>
                <thead>
                    <tr>
                        <th>Commande</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>sudo apt update</code></td>
                        <td>Met à jour la liste des paquets disponibles.</td>
                    </tr>
                    <tr>
                        <td><code>sudo apt upgrade</code></td>
                        <td>Met à jour les paquets installés.</td>
                    </tr>
                    <tr>
                        <td><code>sudo apt install [paquet]</code></td>
                        <td>Installe un paquet.</td>
                    </tr>
                    <tr>
                        <td><code>sudo apt remove [paquet]</code></td>
                        <td>Supprime un paquet.</td>
                    </tr>
                </tbody>
            </table>

            <h4>Activité Pratique :</h4>
            <ul>
                <li>Mettre à jour la liste des paquets avec <code>sudo apt update</code>.</li>
                <li>Installer un paquet comme <code>htop</code> avec <code>sudo apt install htop</code>.</li>
                <li>Lancer <code>htop</code> pour explorer les processus en temps réel.</li>
            </ul>

            <h3>5. Discussion et Réflexion (10 min)</h3>
            <ul>
                <li>Quels avantages offre Linux par rapport aux autres systèmes d’exploitation ?</li>
                <li>Comment les permissions renforcent-elles la sécurité du système ?</li>
                <li>Pourquoi est-il important de gérer correctement les processus et les utilisateurs ?</li>
            </ul>

            <h3>Conclusion :</h3>
            <p>
                Avec ces bases avancées, les élèves disposent d’un bagage solide pour explorer Linux de manière autonome. Ils comprennent les concepts fondamentaux de gestion des utilisateurs, des processus et des permissions, tout en maîtrisant des outils essentiels pour l’administration système.
            </p>
        </section>

        <section id="session73" class="content-section">
            <h2>Séance 73 : Introduction aux protocoles réseau (TCP, UDP, IP) et modèle OSI</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Cette séance introduit les concepts fondamentaux des réseaux informatiques, notamment les protocoles <strong>TCP</strong>, <strong>UDP</strong>, <strong>IP</strong>, et le <strong>modèle OSI</strong>. Les élèves découvriront le rôle de ces protocoles dans la communication réseau et comprendront comment les données circulent entre ordinateurs.
            </p>
        
            <h3>Plan de la Séance :</h3>
            <ul>
                <li><strong>Partie 1 :</strong> Introduction aux protocoles réseau et au modèle OSI (30 min).</li>
                <li><strong>Partie 2 :</strong> Fonctionnement des protocoles TCP, UDP et IP (40 min).</li>
                <li><strong>Partie 3 :</strong> Activité pratique : Simulation de communications réseau (40 min).</li>
            </ul>
        
            <h3>1. Introduction aux Protocoles Réseau et au Modèle OSI (30 min)</h3>
            <h4>Qu’est-ce qu’un protocole réseau ?</h4>
            <p>
                Un protocole réseau est un ensemble de règles qui définit comment les données sont transmises sur un réseau. Ces règles garantissent que deux ordinateurs ou appareils peuvent communiquer efficacement, peu importe leur fabricant ou leur système d'exploitation.
            </p>
        
            <h4>Le Modèle OSI :</h4>
            <p>
                Le modèle OSI (<strong>Open Systems Interconnection</strong>) est une structure en 7 couches qui décrit comment les données circulent sur un réseau. Chaque couche a une fonction spécifique, et elles travaillent ensemble pour assurer une communication fluide.
            </p>
        
            <h4>Les 7 couches du modèle OSI :</h4>
            <ol>
                <li><strong>Application :</strong> Interface utilisateur (exemple : HTTP, FTP).</li>
                <li><strong>Présentation :</strong> Traduction des données (exemple : cryptage).</li>
                <li><strong>Session :</strong> Gestion des connexions (exemple : ouverture/fermeture de sessions).</li>
                <li><strong>Transport :</strong> Gestion de la fiabilité et de l'ordre des données (exemple : TCP, UDP).</li>
                <li><strong>Réseau :</strong> Routage des paquets (exemple : IP).</li>
                <li><strong>Liaison de données :</strong> Communication directe entre deux nœuds (exemple : Ethernet).</li>
                <li><strong>Physique :</strong> Transmission brute des bits (exemple : câbles, signaux).</li>
            </ol>
        
            <h4>Résumé graphique :</h4>
            <p>Imaginez que vous envoyez une lettre :</p>
            <ul>
                <li>La couche Application écrit le contenu.</li>
                <li>La couche Présentation traduit le contenu dans une langue compréhensible par le destinataire.</li>
                <li>La couche Transport s'assure que toutes les lettres arrivent dans le bon ordre.</li>
                <li>La couche Réseau décide du chemin à emprunter.</li>
                <li>Les couches Liaison et Physique s'occupent de la transmission réelle de la lettre.</li>
            </ul>
        
            <h3>2. Fonctionnement des Protocoles TCP, UDP et IP (40 min)</h3>
        
            <h4>Protocole IP :</h4>
            <p>
                <strong>Internet Protocol (IP)</strong> est responsable de l'adressage et du routage des paquets de données. Chaque appareil sur Internet a une adresse IP unique, comme une adresse postale.
            </p>
            <p><strong>Exemple :</strong> Un ordinateur avec l’adresse IP <code>192.168.1.1</code> envoie des données à un autre appareil avec l’adresse <code>192.168.1.2</code>.</p>
        
            <h4>Protocole TCP :</h4>
            <p>
                <strong>Transmission Control Protocol (TCP)</strong> garantit une communication fiable entre deux appareils. Il vérifie que toutes les données sont envoyées et reçues dans le bon ordre.
            </p>
            <ul>
                <li><strong>Avantages :</strong> Fiabilité, correction des erreurs.</li>
                <li><strong>Inconvénients :</strong> Plus lent à cause des vérifications constantes.</li>
            </ul>
            <p><strong>Exemple :</strong> Télécharger un fichier où chaque partie doit être reçue dans le bon ordre.</p>
        
            <h4>Protocole UDP :</h4>
            <p>
                <strong>User Datagram Protocol (UDP)</strong> est un protocole rapide mais moins fiable. Il n’assure pas que tous les paquets arrivent ni qu’ils soient dans le bon ordre.
            </p>
            <ul>
                <li><strong>Avantages :</strong> Rapidité, faible latence.</li>
                <li><strong>Inconvénients :</strong> Pas de garantie de livraison.</li>
            </ul>
            <p><strong>Exemple :</strong> Streaming vidéo ou jeux en ligne, où la rapidité est plus importante que la fiabilité.</p>
        
            <h4>Comparaison entre TCP et UDP :</h4>
            <table border="1" cellpadding="5">
                <thead>
                    <tr>
                        <th>Caractéristique</th>
                        <th>TCP</th>
                        <th>UDP</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Fiabilité</td>
                        <td>Oui</td>
                        <td>Non</td>
                    </tr>
                    <tr>
                        <td>Vitesse</td>
                        <td>Plus lent</td>
                        <td>Très rapide</td>
                    </tr>
                    <tr>
                        <td>Utilisation</td>
                        <td>Téléchargement de fichiers, emails</td>
                        <td>Streaming, jeux vidéo</td>
                    </tr>
                </tbody>
            </table>
        
            <h3>3. Activité Pratique : Simulation de Communications Réseau (40 min)</h3>
        
            <h4>Exercice 1 : Simulation avec TCP</h4>
            <p>Créez un script Python où un serveur envoie un message à un client en utilisant TCP.</p>
            <pre><code class="python">
        # Serveur TCP
        import socket
        
        serveur = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        serveur.bind(("127.0.0.1", 65432))
        serveur.listen(1)
        print("Serveur en attente de connexion...")
        
        conn, addr = serveur.accept()
        print(f"Connexion établie avec {addr}")
        message = "Bonjour, client !"
        conn.sendall(message.encode())
        conn.close()
            </code></pre>
        
            <pre><code class="python">
        # Client TCP
        import socket
        
        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client.connect(("127.0.0.1", 65432))
        data = client.recv(1024)
        print(f"Message reçu du serveur : {data.decode()}")
        client.close()
            </code></pre>
        
            <h4>Exercice 2 : Simulation avec UDP</h4>
            <p>Créez un script Python où un client envoie un message à un serveur en utilisant UDP.</p>
            <pre><code class="python">
        # Serveur UDP
        import socket
        
        serveur = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        serveur.bind(("127.0.0.1", 65433))
        print("Serveur UDP en attente de message...")
        
        data, addr = serveur.recvfrom(1024)
        print(f"Message reçu de {addr} : {data.decode()}")
            </code></pre>
        
            <pre><code class="python">
        # Client UDP
        import socket
        
        client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        message = "Bonjour, serveur UDP !"
        client.sendto(message.encode(), ("127.0.0.1", 65433))
            </code></pre>
        
            <h3>Conclusion :</h3>
            <p>
                À la fin de cette séance, les élèves auront une compréhension claire des protocoles réseau TCP, UDP, et IP, ainsi que du modèle OSI. Ils auront également pratiqué la création de scripts Python pour simuler des communications réseau.
            </p>
        </section>

        <section id="session74" class="content-section">
            <h2>Séance 74 : Les adresses IP et le routage (avec Filius)</h2>

            <a href="https://www.lernsoftware-filius.de/Herunterladen" target="_blank" rel="noopener noreferrer">Télécharger Filius</a>
        
            <h3>Objectif Global :</h3>
            <p>Les élèves apprendront les concepts fondamentaux des adresses IP, des sous-réseaux et du routage. Ils utiliseront le logiciel <strong>Filius</strong> pour configurer et simuler un réseau avec plusieurs sous-réseaux et routeurs.</p>
        
            <h3>1. Introduction aux Adresses IP</h3>
            <h4>Qu’est-ce qu’une adresse IP ?</h4>
            <p>
                Une adresse IP est une <strong>adresse unique</strong> permettant d’identifier un appareil sur un réseau. Elle est essentielle pour la communication entre appareils.
            </p>
            <p>Exemple : <code>192.168.1.1</code></p>
        
            <h4>Structure d’une adresse IPv4 :</h4>
            <ul>
                <li>4 octets séparés par des points (ex. : <code>192.168.0.1</code>).</li>
                <li>Chaque octet est un nombre compris entre 0 et 255.</li>
            </ul>
        
            <h4>Exercice :</h4>
            <ul>
                <li>Donnez un exemple d’adresse IP valide.</li>
                <li>Indiquez si <code>192.300.1.1</code> est valide.</li>
            </ul>
        
            <h3>2. Les Sous-Réseaux et Masques de Sous-Réseaux</h3>
            <h4>Définition :</h4>
            <p>
                Un sous-réseau divise un réseau plus grand en segments plus petits pour améliorer la gestion et réduire les collisions.
            </p>
            <p>
                Un masque de sous-réseau détermine la partie d’une adresse IP qui correspond au réseau et la partie qui correspond aux appareils.
            </p>
            <ul>
                <li>Exemple de masque : <code>255.255.255.0</code></li>
                <li>Notation CIDR : <code>192.168.1.0/24</code> (24 bits pour le réseau).</li>
            </ul>
        
            <h4>Exercice :</h4>
            <p>
                Divisez le réseau <code>192.168.1.0/24</code> en deux sous-réseaux. Déterminez les plages d’adresses pour chaque sous-réseau.
            </p>
        
            <h3>3. Le Routage</h3>
            <h4>Qu’est-ce que le routage ?</h4>
            <p>
                Le routage est le processus par lequel les données sont envoyées d’un appareil source à un appareil destination. Les routeurs utilisent des tables de routage pour décider où envoyer les paquets.
            </p>
        
            <h4>Types de Routage :</h4>
            <ul>
                <li><strong>Statique :</strong> Configuré manuellement.</li>
                <li><strong>Dynamique :</strong> Apprend automatiquement les routes grâce à des protocoles.</li>
            </ul>
        
            <h3>4. Atelier Pratique avec Filius (1 heure)</h3>
            <h4>Objectif :</h4>
            <p>
                Configurer un réseau simulé dans Filius avec deux sous-réseaux et un routeur pour permettre la communication entre eux.
            </p>
        
            <h4>Étape 1 : Créez un réseau avec Filius</h4>
            <ol>
                <li>
                    Ajoutez deux sous-réseaux :
                    <ul>
                        <li><strong>Sous-réseau 1 :</strong> <code>192.168.1.0/25</code></li>
                        <li><strong>Sous-réseau 2 :</strong> <code>192.168.1.128/25</code></li>
                    </ul>
                </li>
                <li>
                    Ajoutez deux appareils à chaque sous-réseau :
                    <ul>
                        <li>Sous-réseau 1 : <code>192.168.1.10</code> et <code>192.168.1.20</code></li>
                        <li>Sous-réseau 2 : <code>192.168.1.130</code> et <code>192.168.1.140</code></li>
                    </ul>
                </li>
                <li>Ajoutez un routeur pour interconnecter les deux sous-réseaux.</li>
            </ol>
        
            <h4>Étape 2 : Configurez les appareils</h4>
            <ol>
                <li>Attribuez des adresses IP aux appareils et au routeur.</li>
                <li>Configurez les passerelles par défaut des appareils pour pointer vers le routeur.</li>
            </ol>
        
            <h4>Étape 3 : Configurez le routage</h4>
            <p>Ajoutez des routes sur le routeur pour permettre la communication entre les deux sous-réseaux.</p>
            <ul>
                <li>Interface 1 : <code>192.168.1.1</code> (connecté au sous-réseau 1)</li>
                <li>Interface 2 : <code>192.168.1.129</code> (connecté au sous-réseau 2)</li>
            </ul>
        
            <h4>Étape 4 : Testez la connectivité</h4>
            <ul>
                <li>Envoyez un ping entre un appareil du sous-réseau 1 et un appareil du sous-réseau 2.</li>
                <li>Corrigez les erreurs si la communication échoue.</li>
            </ul>
            <hr>
            <h3>Atelier Pratique en Python : Communication entre deux réseaux</h3>
            <h4>Objectif :</h4>
            <p>
                Les élèves doivent créer un simulateur réseau en Python avec deux sous-réseaux interconnectés par un "routeur logiciel". Ils apprendront à simuler le routage et à transmettre des messages entre les deux réseaux.
            </p>

            <h4>Étape 1 : Créez deux sous-réseaux en Python</h4>
            <p>Utilisez des dictionnaires pour représenter les sous-réseaux. Chaque clé représente une adresse IP, et la valeur correspond à un appareil.</p>
            <pre><code class="python">
        # Définition des deux sous-réseaux
        reseau1 = {
            "192.168.1.10": "Appareil A",
            "192.168.1.20": "Appareil B"
        }

        reseau2 = {
            "192.168.2.10": "Appareil C",
            "192.168.2.20": "Appareil D"
        }
            </code></pre>

            <h4>Étape 2 : Implémentez un "routeur logiciel"</h4>
            <p>Le routeur est une fonction qui prend une adresse IP source, une adresse IP destination, et une table de routage pour transmettre les données au bon réseau.</p>
            <pre><code class="python">
        # Table de routage
        table_routage = {
            "192.168.1.0/24": reseau1,
            "192.168.2.0/24": reseau2
        }

        # Routeur logiciel
        def routeur(ip_source, ip_destination, table_routage):
            # Identifier le réseau de destination
            for reseau, appareils in table_routage.items():
                prefixe, masque = reseau.split("/")
                if ip_destination.startswith(prefixe):
                    # Vérifier si l'adresse existe dans le réseau
                    if ip_destination in appareils:
                        print(f"Message de {ip_source} à {ip_destination} : Transmis avec succès !")
                    else:
                        print(f"Erreur : {ip_destination} n'existe pas dans {reseau}.")
                    return
            print(f"Erreur : Réseau pour {ip_destination} introuvable.")
            </code></pre>

            <h4>Étape 3 : Simulez la communication entre les appareils</h4>
            <p>Testez la fonction <code>routeur</code> pour transmettre des messages entre deux appareils de réseaux différents.</p>
            <pre><code class="python">
        # Simulation de communication
        routeur("192.168.1.10", "192.168.2.10", table_routage)  # Succès
        routeur("192.168.1.10", "192.168.3.10", table_routage)  # Erreur : Réseau introuvable
        routeur("192.168.2.20", "192.168.1.20", table_routage)  # Succès
            </code></pre>

            <h4>Étape 4 : Ajoutez des fonctionnalités</h4>
            <p>Proposez aux élèves d’améliorer le programme :</p>
            <ul>
                <li>Ajoutez des messages entre les appareils (par exemple, "Bonjour de Appareil A").</li>
                <li>Ajoutez un troisième réseau et mettez à jour la table de routage.</li>
                <li>Simulez des délais ou des pannes de réseau.</li>
            </ul>
        </section>

        <section id="session75" class="content-section">
            <h2>Séance 75 : Protocole HTTP et API REST</h2>
        
            <h3>Objectif Global :</h3>
            <p>
                Les élèves apprendront les principes fondamentaux du protocole HTTP, la structure des requêtes et des réponses HTTP, et la manière d'interagir avec des API REST. À travers des exemples pratiques, ils comprendront comment consommer des API pour récupérer ou envoyer des données.
            </p>
        
            <h3>Partie 1 : Introduction au Protocole HTTP (30 min)</h3>
        
            <h4>1. Qu’est-ce que HTTP ?</h4>
            <p>
                HTTP (HyperText Transfer Protocol) est un protocole de communication utilisé pour échanger des données sur le web. Les navigateurs utilisent HTTP pour récupérer les pages web, et les applications modernes l’utilisent pour communiquer avec des serveurs via des API.
            </p>
            <p>HTTP fonctionne sur un modèle <strong>client-serveur</strong> :</p>
            <ul>
                <li>Le <strong>client</strong> envoie une requête (exemple : un navigateur ou une application).</li>
                <li>Le <strong>serveur</strong> répond avec des données ou des messages d’état.</li>
            </ul>
        
            <h4>2. Structure d’une Requête HTTP :</h4>
            <p>Une requête HTTP contient :</p>
            <ul>
                <li><strong>Méthode :</strong> Détermine l’action à effectuer (GET, POST, PUT, DELETE).</li>
                <li><strong>URL :</strong> L’adresse de la ressource demandée.</li>
                <li><strong>Headers :</strong> Métadonnées pour la requête (ex. : format des données).</li>
                <li><strong>Corps (Body) :</strong> Contient les données envoyées (utilisé principalement avec POST et PUT).</li>
            </ul>
        
            <h4>Exemple de Requête HTTP GET :</h4>
            <pre><code>
        GET /api/v1/produits HTTP/1.1
        Host: www.example.com
        Authorization: Bearer <token>
            </code></pre>
        
            <h4>3. Structure d’une Réponse HTTP :</h4>
            <p>Une réponse HTTP contient :</p>
            <ul>
                <li><strong>Code de statut :</strong> Indique le résultat de la requête (ex. : 200 pour OK, 404 pour Not Found).</li>
                <li><strong>Headers :</strong> Informations sur la réponse (ex. : type de contenu).</li>
                <li><strong>Corps (Body) :</strong> Contient les données retournées par le serveur.</li>
            </ul>
        
            <h4>Exemple de Réponse HTTP :</h4>
            <pre><code>
        HTTP/1.1 200 OK
        Content-Type: application/json
        
        {
            "produits": [
                {"id": 1, "nom": "Produit A", "prix": 10.0},
                {"id": 2, "nom": "Produit B", "prix": 20.0}
            ]
        }
            </code></pre>
        
            <h3>Partie 2 : Introduction aux API REST (30 min)</h3>
        
            <h4>1. Qu’est-ce qu’une API REST ?</h4>
            <p>
                Une API (Application Programming Interface) REST (REpresentational State Transfer) est une interface qui permet aux applications de communiquer entre elles via HTTP. Elle repose sur des principes simples, tels que :
            </p>
            <ul>
                <li><strong>Ressources :</strong> Tout est traité comme une ressource (ex. : utilisateurs, produits).</li>
                <li><strong>Méthodes HTTP :</strong> Les actions sur les ressources sont définies par les méthodes HTTP (GET, POST, PUT, DELETE).</li>
                <li><strong>Stateless :</strong> Chaque requête est indépendante des autres.</li>
            </ul>
        
            <h4>2. Principales Méthodes HTTP pour REST :</h4>
            <ul>
                <li><strong>GET :</strong> Récupérer des données (lecture).</li>
                <li><strong>POST :</strong> Ajouter de nouvelles données (création).</li>
                <li><strong>PUT :</strong> Mettre à jour des données existantes.</li>
                <li><strong>DELETE :</strong> Supprimer des données.</li>
            </ul>
        
            <h4>3. Exemple d’API REST :</h4>
            <p>Supposons une API pour gérer des utilisateurs. Voici les routes disponibles :</p>
            <ul>
                <li><code>GET /api/v1/utilisateurs</code> : Récupère tous les utilisateurs.</li>
                <li><code>GET /api/v1/utilisateurs/{id}</code> : Récupère un utilisateur par ID.</li>
                <li><code>POST /api/v1/utilisateurs</code> : Ajoute un nouvel utilisateur.</li>
                <li><code>PUT /api/v1/utilisateurs/{id}</code> : Met à jour les informations d’un utilisateur.</li>
                <li><code>DELETE /api/v1/utilisateurs/{id}</code> : Supprime un utilisateur.</li>
            </ul>
        
            <h3>Partie 3 : Pratique - Consommer une API REST en Python (1h)</h3>
        
            <h4>1. Utilisation de la Bibliothèque <code>requests</code> :</h4>
            <p>
                En Python, la bibliothèque <code>requests</code> permet d’envoyer facilement des requêtes HTTP. Voici comment l’installer :
            </p>
            <pre><code>
        pip install requests
            </code></pre>
        
            <h4>2. Exemple Pratique :</h4>
            <p>Récupérez une liste d’utilisateurs depuis une API publique (par exemple : <a href="https://jsonplaceholder.typicode.com">https://jsonplaceholder.typicode.com</a>).</p>
            <pre><code class="python">
        import requests
        
        # Envoi d'une requête GET
        url = "https://jsonplaceholder.typicode.com/users"
        response = requests.get(url)
        
        # Vérification du code de statut
        if response.status_code == 200:
            utilisateurs = response.json()  # Convertir la réponse JSON en objet Python
            for utilisateur in utilisateurs:
                print(f"Nom : {utilisateur['name']}, Email : {utilisateur['email']}")
        else:
            print("Erreur lors de la récupération des utilisateurs.")
            </code></pre>
        
            <h4>3. Exercice Pratique :</h4>
            <p>En groupe, réalisez les tâches suivantes :</p>
            <ul>
                <li>Créez une fonction pour ajouter un nouvel utilisateur (requête POST).</li>
                <li>Créez une fonction pour mettre à jour les informations d’un utilisateur (requête PUT).</li>
                <li>Créez une fonction pour supprimer un utilisateur (requête DELETE).</li>
            </ul>
        
            <h4>Exemple pour POST :</h4>
            <pre><code class="python">
        # Envoi d'une requête POST pour ajouter un utilisateur
        url = "https://jsonplaceholder.typicode.com/users"
        nouvel_utilisateur = {
            "name": "Alice Dupont",
            "email": "alice@example.com",
            "phone": "123-456-7890"
        }
        response = requests.post(url, json=nouvel_utilisateur)
        
        if response.status_code == 201:  # Code de création réussie
            print("Utilisateur ajouté avec succès :", response.json())
        else:
            print("Erreur lors de l'ajout de l'utilisateur.")
            </code></pre>
        
            <h3>Conclusion et Réflexion (10 min)</h3>
            <ul>
                <li>Les élèves auront appris à interagir avec des API REST via des requêtes HTTP.</li>
                <li>Discussion : Comment les API REST sont utilisées dans des applications modernes (ex. : communication entre une application mobile et un serveur) ?</li>
                <li>Extension : Introduction aux API sécurisées avec des jetons d’authentification (Bearer Token).</li>
            </ul>
        </section>
    </main>

    <!-- <footer>
        <p>&copy; 2024 Programme NSI Tle</p>
    </footer> -->

    <script>
        const holidays = {
            '2024-11-11': 'Armistice 1918',
            '2024-12-25': 'Noël',
            '2025-01-01': 'Jour de l\'An',
            '2025-04-21': 'Lundi de Pâques',
            '2025-05-01': 'Fête du Travail',
            '2025-05-08': 'Victoire 1945',
            '2025-05-29': 'Ascension',
            '2025-06-09': 'Lundi de Pentecôte'
        };
    
        const vacations = [
            { start: '2024-10-19', end: '2024-11-03', name: 'Vacances de la Toussaint' },
            { start: '2024-12-21', end: '2025-01-05', name: 'Vacances de Noël' },
            { start: '2025-02-22', end: '2025-03-09', name: 'Vacances d\'hiver' },
            { start: '2025-04-19', end: '2025-05-04', name: 'Vacances de printemps' },
            { start: '2025-07-05', end: '2025-09-02', name: 'Vacances d\'été' }
        ];
    
        const sessions = [
            'Séance 1 : Introduction à la récursivité (concepts de base)',
            'Séance 2 : Pratique - Implémentation d’une fonction récursive pour calculer une suite mathématique',
            'Séance 3 : Applications pratiques de la récursivité (problèmes simples)',
            'Séance 4 : Introduction aux Algorithmes de Recherche Récursive – Recherche Binaire',
            'Séance 5 : Pratique – Recherche d’un Personnage de Manga avec un Algorithme de Recherche Binaire',
            'Séance 6 : Analyse de la Complexité d’un Algorithme de Recherche Récursive',
            'Séance 7 : Introduction au Backtracking (Concepts de Base)',
            'Séance 8 : Pratique - Résolution d\'un Labyrinthe avec Backtracking (Jeu Vidéo)',
            'Séance 9 : Étude des Cas Où le Backtracking Est Utile et de Ses Limitations',
            'Séance 10 : Introduction à la Complexité Algorithmique – Notation Big-O',
            'Séance 11 : Pratique - Comparaison des Algorithmes de Tri Simples (Insertion, Sélection)',
            'Séance 12 : Exercices d’Analyse de la Complexité des Algorithmes dans des Jeux Vidéo et la Vie Réelle',
            'Séance 13 : Introduction aux Graphes et à leurs Applications',
            'Séance 14 : Pratique - Représentation d\'un Réseau de Routes dans un Jeu Vidéo avec des Graphes',
            'Séance 15 : Algorithmes de Parcours de Graphes – DFS et BFS',
            'Séance 16 : Approfondissement sur l’algorithme DFS (Depth-First Search)',
            'Séance 17 : Pratique - Exploration d’un Monde Ouvert (Jeu Vidéo) avec DFS',
            'Séance 18 : Applications Réelles des Graphes (Réseaux Sociaux, Chemins dans les Transports)',
            'Séance 19 : Introduction aux Arbres Binaires et leurs Applications',
            'Séance 20 : Pratique - Utilisation d’arbres pour organiser une base de données de personnages de manga',
            'Séance 21 : Algorithmes de Parcours d’Arbres (Pré-ordre, En-ordre, Post-ordre)',
            'Séance 22 : Approfondissement sur les Algorithmes de Parcours d’Arbres',
            'Séance 23 : Pratique - Création d’un Arbre de Décision pour un Jeu de Rôle (Jeu Vidéo)',
            'Séance 24 : Analyse des performances et avantages des arbres dans la recherche et le tri',
            'Séance 25 : Introduction au Tri Rapide (Quicksort)',
            'Séance 26 : Pratique - Implémentation du Quicksort pour trier des scores de jeu vidéo',
            'Séance 27 : Comparaison de la complexité des différents algorithmes de tri',
            'Séance 28 : Introduction au tri par tas (Heapsort)',
            'Séance 29 : Pratique - Utilisation du Heapsort pour organiser un inventaire dans un jeu vidéo',
            'Séance 30 : Analyse de la Complexité du Heapsort et de ses Applications',
            'Séance 31 : Introduction au Tri Fusion (Merge Sort)',
            'Séance 32 : Pratique - Implémentation du Tri Fusion pour Classer des Mangas par Popularité',
            'Séance 33 : Étude comparative des algorithmes de tri avancés (Quicksort, Heapsort, Merge Sort)',
            'Séance 34 : Optimisation des Algorithmes de Tri dans des Contextes Réels',
            'Séance 35 : Pratique - Choisir et implémenter l’algorithme de tri le plus efficace pour différentes situations',
            'Séance 36 : Révision et consolidation des concepts d\'algorithmes de tri',
            'Séance 37 : Introduction à la Programmation Orientée Objet (POO) – Classes, Objets, Méthodes',
            'Séance 38 : Pratique - Modélisation d’un personnage de jeu vidéo en POO',
            'Séance 39 : Héritage et Polymorphisme (Théorie)',
            'Séance 40 : Pratique - Implémentation d’un Système d’Héritage dans une Application de Gestion de Personnages (Jeu Vidéo)',
            'Séance 41 : Introduction aux Design Patterns - Singleton et Factory',
            'Séance 42 : Pratique - Utilisation de Design Patterns pour Optimiser la Gestion des Niveaux d’un Jeu Vidéo',
            'Séance 43 : Théorie - Encapsulation, Accès aux Attributs, Getters et Setters',
            'Séance 44 : Pratique - Gestion d’attributs privés dans une application',
            'Séance 45 : Gestion de la mémoire en POO',
            'Séance 46 : Optimisation d’une application POO (jeu vidéo).',
            'Séance 47 : Pratique - Réorganisation d’un projet pour améliorer l’efficacité et la gestion des ressources',
            'Séance 48 : Analyse des performances dans des projets orientés objet',
            'Séance 49 : Introduction aux bases de données relationnelles et SQL',
            'Séance 50 : Pratique - Création d’une base de données pour gérer des scores de jeu vidéo',
            'Séance 51 : Requêtes SQL de base (SELECT, INSERT, UPDATE, DELETE)',
            'Séance 52 : Requêtes SQL avancées (JOIN, GROUP BY)',
            'Séance 53 : Pratique - Interrogation complexe d\'une base de données pour récupérer des données sur les personnages d’un manga',
            'Séance 54 : Optimisation des requêtes SQL',
            'Séance 55 : Introduction à la normalisation (1NF, 2NF, 3NF)',
            'Séance 56 : Pratique - Réorganisation d’une base de données pour une meilleure gestion des données',
            'Séance 57 : Cas pratiques de normalisation dans des projets réels (jeu vidéo, actualité)',
            'Séance 58 : Introduction à l’indexation et optimisation des bases de données',
            'Séance 59 : Pratique - Amélioration de la performance des requêtes SQL avec indexation',
            'Séance 60 : Étude de cas sur les performances des bases de données dans un projet',
            'Séance 61 : Introduction à la cryptographie (chiffrement symétrique)',
            'Séance 62 : Pratique - Implémentation d’un chiffrement simple pour protéger les données d’un jeu vidéo',
            'Séance 63 : Algorithmes de chiffrement asymétrique (RSA)',
            'Séance 64 : Introduction aux protocoles de sécurité (SSL, HTTPS)',
            'Séance 65 : Pratique - Sécurisation des échanges entre un serveur de jeu et un client',
            'Séance 66 : Algorithmes de hachage et intégrité des données',
            'Séance 67 : Signature numérique et validation de l’intégrité des données',
            'Séance 68 : Pratique - Protection des données d’une application de gestion d’actualité',
            'Séance 69 : Révision des concepts de sécurité et cryptographie',
            'Séance 70 : Introduction aux Architectures Matérielles, fonctionnement du Processeur et des Bus',
            'Séance 71 : Introduction aux Systèmes d’Exploitation',
            'Séance 72 : Bases de l’Utilisation de Linux',
            'Séance 73 : Introduction aux protocoles réseau (TCP, UDP, IP) et modèle OSI',
            'Séance 74 : Les adresses IP et le routage',
            'Séance 75 : Protocole HTTP et API REST',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            ''
        ];
    
        function isHoliday(date) {
            return holidays[date] !== undefined;
        }
    
        function isInVacation(date) {
            const parsedDate = new Date(date);
            return vacations.some(vacation => {
                const startDate = new Date(vacation.start);
                const endDate = new Date(vacation.end);
                return parsedDate >= startDate && parsedDate <= endDate;
            });
        }
    
        function getVacationName(date) {
            const parsedDate = new Date(date);
            const vacation = vacations.find(vacation => {
                const startDate = new Date(vacation.start);
                const endDate = new Date(vacation.end);
                return parsedDate >= startDate && parsedDate <= endDate;
            });
            return vacation ? vacation.name : '';
        }
    
        function formatFrenchDate(date) {
            const options = { year: 'numeric', month: '2-digit', day: '2-digit' };
            return new Date(date).toLocaleDateString('fr-FR', options);
        }
    
        function isCurrentWeek(date) {
            const currentDate = new Date();
            const firstDayOfWeek = new Date(date);
            const lastDayOfWeek = new Date(firstDayOfWeek);
            lastDayOfWeek.setDate(firstDayOfWeek.getDate() + 6);
            return currentDate >= firstDayOfWeek && currentDate <= lastDayOfWeek;
        }

        function isToday(date) {
            const today = new Date().toISOString().split('T')[0];
            return today === date;
        }
    
        function generateCalendar() {
            const calendarBody = document.getElementById('calendar-body');
            const startDate = new Date('2024-09-04');  // Premier mercredi de septembre 2024
            const endDate = new Date('2025-07-12');
            
            let currentDate = startDate;
            let sessionIndex = 0;

            while (currentDate <= endDate) {
                const row = document.createElement('tr');

                // Génération des jours (mercredi, jeudi, vendredi)
                ['Mercredi', 'Jeudi', 'Vendredi'].forEach(() => {
                    const currentDateString = currentDate.toISOString().split('T')[0];
                    
                    // Date (colonne de la date)
                    const dateCell = document.createElement('td');
                    dateCell.textContent = formatFrenchDate(currentDateString);

                    // Description ou séance (colonne des descriptions)
                    const descCell = document.createElement('td');
                    if (isHoliday(currentDateString)) {
                        descCell.textContent = holidays[currentDateString];
                        dateCell.classList.add('holiday');
                        descCell.classList.add('holiday');
                    } else if (isInVacation(currentDateString)) {
                        descCell.textContent = getVacationName(currentDateString);
                        row.classList.add('vacation');
                    } else {
                        const sessionName = sessions[sessionIndex] || 'Séance à définir';
                        sessionIndex++;

                        // Création d'un lien cliquable pour les séances
                        const link = document.createElement('a');
                        link.textContent = sessionName;
                        link.href = `#`; // Génère un ID basé sur le nom de la séance
                        link.setAttribute("onclick","showSession('session"+sessionIndex+"')");

                        descCell.appendChild(link);
                    }

                    // Mise en évidence du jour actuel
                    if (isToday(currentDateString)) {
                        dateCell.classList.add('today');
                        descCell.classList.add('today');
                    }

                    // Ajout des cellules à la ligne
                    row.appendChild(dateCell);
                    row.appendChild(descCell);

                    // Passer au jour suivant
                    currentDate.setDate(currentDate.getDate() + 1);
                });

                // Ajouter la ligne au tableau
                calendarBody.appendChild(row);

                // Passer au mercredi suivant
                currentDate.setDate(currentDate.getDate() + 4); // Sauter au mercredi suivant
            }
        }
    
        // Générer le calendrier au chargement de la page
        generateCalendar();    

        // Toggle menu visibility
        function toggleMenu() {
            const menu = document.getElementById("session-nav");
            menu.style.display = menu.style.display === "block" ? "none" : "block";
        }

        // Show selected session content
        function showSession(sessionId) {
            const sessions = document.querySelectorAll('.content-section');
            sessions.forEach(session => {
                session.classList.remove('active');
                if (session.id === sessionId) {
                    session.classList.add('active');
                }
            });

            // Mettre en évidence la séance active dans le menu
            const menuLinks = document.querySelectorAll('#session-nav a');
            menuLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('onclick').includes(sessionId)) {
                    link.classList.add('active');
                }
            });
        }

        // Display the first session by default when page loads
        document.addEventListener('DOMContentLoaded', () => {
            showSession('calendar');
        });
    </script>

</body>
</html>
