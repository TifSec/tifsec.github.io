<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programme NSI Tle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Calibri, sans-serif;
            line-height: 1.6;
            background-color: #f4f4f4;
        }

        header {
            background-color: #4CAF50;
            color: white;
            text-align: center;
            padding: 1rem;
        }

        main {
            margin-left: 200px;
            padding: 20px;
            min-height: 80vh;
        }

        .content-section {
            display: none;
        }

        .content-section.active {
            display: block;
        }

        aside {
            position: fixed;
            left: 0;
            top: 0;
            height: 100%;
            width: 200px;
            background-color: #333;
            color: white;
            padding-top: 20px;
            transition: width 0.3s ease;
            overflow-y: auto;
            scrollbar-width: none; /* Masque la barre de défilement pour Firefox */
        }

        aside::-webkit-scrollbar {
            display: none; /* Masque la barre de défilement pour Chrome, Safari, et Opera */
        }

        aside ul {
            list-style: none;
            padding: 0;
        }

        aside ul li {
            padding: 10px;
        }

        aside ul li a {
            color: white;
            text-decoration: none;
            display: block;
            padding: 10px;
        }

        /* Style pour l'élément de menu actif (séance en cours) */
        aside ul li a.active {
            background-color: #4CAF50; /* Couleur pour l'élément actif */
            color: white;
            font-weight: bold;
        }

        aside ul li a:hover {
            background-color: #555;
        }

        .hamburger {
            background-color: #4CAF50;
            color: white;
            border: none;
            width: 100%;
            padding: 15px;
            text-align: left;
            cursor: pointer;
        }

        footer {
            background-color: #4CAF50;
            color: white;
            text-align: center;
            padding: 10px 0;
            position: fixed;
            bottom: 0;
            width: 100%;
        }

        h2, h3, h4, h5{
            text-align: center;
        }

        h2 {
            color: #333;
            margin-bottom: 15px;
        }

        h4, h5, p, ul{
            margin-top: 10px;
            margin-bottom: 10px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }

        table, th, td {
            border: 1px solid black;
        }

        th, td {
            padding: 10px;
            text-align: center;
        }

        img {
            max-width: 100%;
            height: auto;
        }

        /* Styles spécifiques pour le calendrier */
        table.calendar {
            margin: 20px auto;
            border-collapse: collapse;
            width: 80%;
        }

        th, td {
            padding: 10px;
            text-align: center;
            border: 1px solid #ccc;
        }

        .current-week {
            background-color: #add8e6; /* Couleur bleue clair pour la semaine en cours */
        }

        pre{
            background-color: black;
            color: white;
        }

        .today {
            background-color: #007BFF; /* Bleu vif pour le jour actuel */
            color: white; /* Texte blanc pour le contraste */
        }

        .vacation {
            background-color: #B2E4A6; /* Vert pastel pour les vacances */
            color: black; /* Texte noir ou foncé pour la lisibilité */
        }

        .holiday {
            background-color: #FF6B6B; /* Rouge clair pour les jours fériés */
            color: white; /* Texte blanc ou clair */
        }

        iframe{
            width: 80vw;
            height: 80vw;
        }
    </style>
</head>
<body>

    <header>
        <h1>Programme NSI Tle</h1>
    </header>

    <!-- Menu hamburger sur la gauche -->
    <aside id="menu">
        <button class="hamburger" onclick="toggleMenu()">☰ Séances</button>
        <nav id="session-nav">
            <ul>
                <!-- PROGRAMME -->
                <li><a href="#" onclick="showSession('programme-nsi')">Programme de l'année</a></li>

                <!-- CALENDRIER -->
                <li><a href="#" onclick="showSession('calendar')">Calendrier de cours</a></li>

                <!-- Actus -->
                <!-- <li><a href="#" onclick="showSession('session0')">Actus</a></li> -->

                <!-- COURS -->
                <li><a href="#" onclick="showSession('session1')">Séance 1 : Introduction à la récursivité (concepts de base)</a></li>
                <li><a href="#" onclick="showSession('session2')">Séance 2 : Pratique - Implémentation d’une fonction récursive pour calculer une suite mathématique</a></li>
                <li><a href="#" onclick="showSession('session3')">Séance 3 : Applications pratiques de la récursivité (problèmes simples)</a></li>
                <li><a href="#" onclick="showSession('session4')">Séance 4 : Introduction aux Algorithmes de Recherche Récursive – Recherche Binaire</a></li>
                <li><a href="#" onclick="showSession('session5')">Séance 5 : Pratique – Recherche d’un Personnage de Manga avec un Algorithme de Recherche Binaire</a></li>
                <li><a href="#" onclick="showSession('session6')">Séance 6 : Analyse de la Complexité d’un Algorithme de Recherche Récursive</a></li>
                <li><a href="#" onclick="showSession('session7')">Séance 7 : Introduction au Backtracking (Concepts de Base)</a></li>
                <li><a href="#" onclick="showSession('session8')">Séance 8 : Pratique - Résolution d'un Labyrinthe avec Backtracking (Jeu Vidéo)</a></li>
                <li><a href="#" onclick="showSession('session9')">Séance 9 : Étude des Cas Où le Backtracking Est Utile et de Ses Limitations</a></li>
                <li><a href="#" onclick="showSession('session10')">Séance 10 : Introduction à la Complexité Algorithmique – Notation Big-O</a></li>
                <li><a href="#" onclick="showSession('session11')">Séance 11 : Pratique - Comparaison des Algorithmes de Tri Simples (Insertion, Sélection)</a></li>
                <li><a href="#" onclick="showSession('session12')">Séance 12 : Exercices d’Analyse de la Complexité des Algorithmes dans des Jeux Vidéo et la Vie Réelle</a></li>
                <li><a href="#" onclick="showSession('session13')">Séance 13 : Introduction aux Graphes et à leurs Applications</a></li>
                <li><a href="#" onclick="showSession('session14')">Séance 14 : Pratique - Représentation d'un Réseau de Routes dans un Jeu Vidéo avec des Graphes</a></li>
                <li><a href="#" onclick="showSession('session15')">Séance 15 : Algorithmes de Parcours de Graphes – DFS et BFS</a></li>
                <li><a href="#" onclick="showSession('session16')">Séance 16 : Approfondissement sur l’algorithme DFS (Depth-First Search)</a></li>
                <li><a href="#" onclick="showSession('session17')">Séance 17 : Pratique - Exploration d’un Monde Ouvert (Jeu Vidéo) avec DFS</a></li>
                <li><a href="#" onclick="showSession('session18')">Séance 18 : Applications Réelles des Graphes (Réseaux Sociaux, Chemins dans les Transports)</a></li>
                <li><a href="#" onclick="showSession('session19')">Séance 19 : Introduction aux Arbres Binaires et leurs Applications</a></li>
                <li><a href="#" onclick="showSession('session20')">Séance 20 : Pratique - Utilisation d’arbres pour organiser une base de données de personnages de manga</a></li>
                <li><a href="#" onclick="showSession('session21')">Séance 21 : Algorithmes de Parcours d’Arbres (Pré-ordre, En-ordre, Post-ordre)</a></li>
                <li><a href="#" onclick="showSession('session22')">Séance 22 : Approfondissement sur les Algorithmes de Parcours d’Arbres</a></li>
                <li><a href="#" onclick="showSession('session23')">Séance 23 : Pratique - Création d’un Arbre de Décision pour un Jeu de Rôle (Jeu Vidéo)</a></li>
                <li><a href="#" onclick="showSession('session24')">Séance 24 : Analyse des performances et avantages des arbres dans la recherche et le tri</a></li>
                <li><a href="#" onclick="showSession('session25')">Séance 25 : Introduction au Tri Rapide (Quicksort)</a></li>
                <li><a href="#" onclick="showSession('session26')">Séance 26 : Pratique - Implémentation du Quicksort pour trier des scores de jeu vidéo</a></li>
                <li><a href="#" onclick="showSession('session27')">Séance 27 : Comparaison de la complexité des différents algorithmes de tri</a></li>
                <li><a href="#" onclick="showSession('session28')">Séance 28 : Introduction au tri par tas (Heapsort)</a></li>
                <li><a href="#" onclick="showSession('session29')">Séance 29 : Pratique - Utilisation du Heapsort pour organiser un inventaire dans un jeu vidéo</a></li>
                <li><a href="#" onclick="showSession('session30')">Séance 30 : Analyse de la Complexité du Heapsort et de ses Applications</a></li>
                <li><a href="#" onclick="showSession('session31')">Séance 31 : Introduction au Tri Fusion (Merge Sort)</a></li>
                <li><a href="#" onclick="showSession('session32')">Séance 32 : Pratique - Implémentation du Tri Fusion pour Classer des Mangas par Popularité</a></li>
                <li><a href="#" onclick="showSession('session33')">Séance 33 : Étude comparative des algorithmes de tri avancés (Quicksort, Heapsort, Merge Sort)</a></li>
                <li><a href="#" onclick="showSession('session34')">Séance 34 : Optimisation des Algorithmes de Tri dans des Contextes Réels</a></li>
                <li><a href="#" onclick="showSession('session35')">Séance 35 : Pratique - Choisir et implémenter l’algorithme de tri le plus efficace pour différentes situations</a></li>
                <li><a href="#" onclick="showSession('session36')">Séance 36 : Révision et consolidation des concepts d'algorithmes de tri</a></li>
                <li><a href="#" onclick="showSession('session37')">Séance 37 : Introduction à la Programmation Orientée Objet (POO) – Classes, Objets, Méthodes</a></li>
                <li><a href="#" onclick="showSession('session38')">Séance 38 : Pratique - Modélisation d’un personnage de jeu vidéo en POO</a></li>
                <li><a href="#" onclick="showSession('session39')">Séance 39 : Héritage et Polymorphisme (Théorie)</a></li>
                <li><a href="#" onclick="showSession('session40')">Séance 40 : Pratique - Implémentation d’un Système d’Héritage dans une Application de Gestion de Personnages (Jeu Vidéo)</a></li>
                <li><a href="#" onclick="showSession('session41')">Séance 41 : Introduction aux Design Patterns - Singleton et Factory</a></li>
                <li><a href="#" onclick="showSession('session42')">Séance 42 : Pratique - Utilisation de Design Patterns pour Optimiser la Gestion des Niveaux d’un Jeu Vidéo</a></li>
                <li><a href="#" onclick="showSession('session43')"></a></li>
                <li><a href="#" onclick="showSession('session44')"></a></li>
                <li><a href="#" onclick="showSession('session45')"></a></li>
                <li><a href="#" onclick="showSession('session46')"></a></li>
                <li><a href="#" onclick="showSession('session47')"></a></li>
                <li><a href="#" onclick="showSession('session48')"></a></li>
                <li><a href="#" onclick="showSession('session49')"></a></li>
                <li><a href="#" onclick="showSession('session50')"></a></li>
                <li><a href="#" onclick="showSession('session51')"></a></li>
                <li><a href="#" onclick="showSession('session52')"></a></li>
                <li><a href="#" onclick="showSession('session53')"></a></li>
                <li><a href="#" onclick="showSession('session54')"></a></li>
                <li><a href="#" onclick="showSession('session55')"></a></li>
                <li><a href="#" onclick="showSession('session56')"></a></li>
                <li><a href="#" onclick="showSession('session57')"></a></li>
                <li><a href="#" onclick="showSession('session58')"></a></li>
                <li><a href="#" onclick="showSession('session59')"></a></li>
                <li><a href="#" onclick="showSession('session60')"></a></li>
                <li><a href="#" onclick="showSession('session61')"></a></li>
                <li><a href="#" onclick="showSession('session62')"></a></li>
                <li><a href="#" onclick="showSession('session63')"></a></li>
                <li><a href="#" onclick="showSession('session64')"></a></li>
                <li><a href="#" onclick="showSession('session65')"></a></li>
                <li><a href="#" onclick="showSession('session66')"></a></li>
                <li><a href="#" onclick="showSession('session67')"></a></li>
                <li><a href="#" onclick="showSession('session68')"></a></li>
                <li><a href="#" onclick="showSession('session69')"></a></li>
                <li><a href="#" onclick="showSession('session70')"></a></li>
                <li><a href="#" onclick="showSession('session71')"></a></li>
                <li><a href="#" onclick="showSession('session72')"></a></li>
                <li><a href="#" onclick="showSession('session73')"></a></li>
                <li><a href="#" onclick="showSession('session74')"></a></li>
                <li><a href="#" onclick="showSession('session75')"></a></li>
                <li><a href="#" onclick="showSession('session76')"></a></li>
                <li><a href="#" onclick="showSession('session77')"></a></li>
                <li><a href="#" onclick="showSession('session78')"></a></li>
                <li><a href="#" onclick="showSession('session79')"></a></li>
                <li><a href="#" onclick="showSession('session80')"></a></li>
                <li><a href="#" onclick="showSession('session81')"></a></li>
                <li><a href="#" onclick="showSession('session82')"></a></li>
                <li><a href="#" onclick="showSession('session83')"></a></li>
                <li><a href="#" onclick="showSession('session84')"></a></li>
                <li><a href="#" onclick="showSession('session85')"></a></li>
                <li><a href="#" onclick="showSession('session86')"></a></li>
                <li><a href="#" onclick="showSession('session87')"></a></li>
                <li><a href="#" onclick="showSession('session88')"></a></li>
                <li><a href="#" onclick="showSession('session89')"></a></li>
                <li><a href="#" onclick="showSession('session90')"></a></li>
                <li><a href="#" onclick="showSession('session91')"></a></li>
                <li><a href="#" onclick="showSession('session92')"></a></li>
                <li><a href="#" onclick="showSession('session93')"></a></li>
                <li><a href="#" onclick="showSession('session94')"></a></li>
                <li><a href="#" onclick="showSession('session95')"></a></li>
                <li><a href="#" onclick="showSession('session96')"></a></li>
                <li><a href="#" onclick="showSession('session97')"></a></li>
                <li><a href="#" onclick="showSession('session98')"></a></li>
                <li><a href="#" onclick="showSession('session99')"></a></li>
                <li><a href="#" onclick="showSession('session100')"></a></li>
                <li><a href="#" onclick="showSession('session101')"></a></li>
                <li><a href="#" onclick="showSession('session102')"></a></li>
                <li><a href="#" onclick="showSession('session103')"></a></li>
                <li><a href="#" onclick="showSession('session104')"></a></li>
                <li><a href="#" onclick="showSession('session105')"></a></li>
                <li><a href="#" onclick="showSession('session106')"></a></li>
                <li><a href="#" onclick="showSession('session107')"></a></li>
                <li><a href="#" onclick="showSession('session108')"></a></li>
            </ul>
        </nav>
    </aside>

    <main id="content">
        <!-- Programme -->
        <section id="programme-nsi" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Programme Terminale NSI</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 1 : Récursivité</h3>
            <ul>
                <li><strong>Séance 1 :</strong> Introduction à la récursivité (concepts de base).</li>
                <li><strong>Séance 2 :</strong> Pratique - Implémentation d’une fonction récursive pour calculer une suite mathématique.</li>
                <li><strong>Séance 3 :</strong> Applications pratiques de la récursivité (problèmes simples).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 2 : Recherche Récursive</h3>
            <ul>
                <li><strong>Séance 4 :</strong> Introduction aux algorithmes de recherche récursive (recherche binaire).</li>
                <li><strong>Séance 5 :</strong> Pratique - Recherche d’un élément dans une liste de personnages de manga avec un algorithme de recherche binaire.</li>
                <li><strong>Séance 6 :</strong> Analyse de la complexité d'un algorithme de recherche récursive.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 3 : Backtracking</h3>
            <ul>
                <li><strong>Séance 7 :</strong> Introduction au backtracking (concepts de base).</li>
                <li><strong>Séance 8 :</strong> Pratique - Résolution d’un labyrinthe avec backtracking (jeu vidéo).</li>
                <li><strong>Séance 9 :</strong> Étude des cas où le backtracking est utile et de ses limitations.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 4 : Complexité Algorithmique</h3>
            <ul>
                <li><strong>Séance 10 :</strong> Introduction à la complexité algorithmique (notation Big-O).</li>
                <li><strong>Séance 11 :</strong> Pratique - Comparaison des algorithmes de tri simples (insertion, sélection).</li>
                <li><strong>Séance 12 :</strong> Exercices d’analyse de la complexité d’algorithmes dans des jeux vidéos et la vie réelle.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 5 : Structures de Données - Graphes</h3>
            <ul>
                <li><strong>Séance 13 :</strong> Introduction aux graphes et à leurs applications (théorie des graphes).</li>
                <li><strong>Séance 14 :</strong> Pratique - Représentation d'un réseau de routes dans un jeu vidéo avec des graphes.</li>
                <li><strong>Séance 15 :</strong> Algorithmes de parcours de graphes (DFS et BFS).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 6 : Algorithmes de Parcours de Graphes</h3>
            <ul>
                <li><strong>Séance 16 :</strong> Approfondissement sur l’algorithme DFS (Depth-First Search).</li>
                <li><strong>Séance 17 :</strong> Pratique - Exploration d'un monde ouvert (jeu vidéo) avec DFS.</li>
                <li><strong>Séance 18 :</strong> Applications réelles des graphes (réseaux sociaux, chemins dans les transports).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 7 : Arbres Binaires</h3>
            <ul>
                <li><strong>Séance 19 :</strong> Introduction aux arbres binaires et leurs applications.</li>
                <li><strong>Séance 20 :</strong> Pratique - Utilisation d’arbres pour organiser une base de données de personnages de manga.</li>
                <li><strong>Séance 21 :</strong> Algorithmes de parcours d’arbres (pré-ordre, en-ordre, post-ordre).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 8 : Algorithmes sur les Arbres</h3>
            <ul>
                <li><strong>Séance 22 :</strong> Approfondissement sur les algorithmes de parcours d’arbres.</li>
                <li><strong>Séance 23 :</strong> Pratique - Création d’un arbre de décision pour un jeu de rôle (jeu vidéo).</li>
                <li><strong>Séance 24 :</strong> Analyse des performances et avantages des arbres dans la recherche et le tri.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 9 : Algorithmes de Tri Avancés</h3>
            <ul>
                <li><strong>Séance 25 :</strong> Introduction au tri rapide (Quicksort).</li>
                <li><strong>Séance 26 :</strong> Pratique - Implémentation du Quicksort pour trier des scores de jeu vidéo.</li>
                <li><strong>Séance 27 :</strong> Comparaison de la complexité des différents algorithmes de tri.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 10 : Heapsort</h3>
            <ul>
                <li><strong>Séance 28 :</strong> Introduction au tri par tas (Heapsort).</li>
                <li><strong>Séance 29 :</strong> Pratique - Utilisation du Heapsort pour organiser un inventaire dans un jeu vidéo.</li>
                <li><strong>Séance 30 :</strong> Analyse de la complexité du Heapsort et de ses applications.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 11 : Tri Fusion</h3>
            <ul>
                <li><strong>Séance 31 :</strong> Introduction au tri fusion (Merge Sort).</li>
                <li><strong>Séance 32 :</strong> Pratique - Implémentation du tri fusion pour classer des mangas par popularité.</li>
                <li><strong>Séance 33 :</strong> Étude comparative des algorithmes de tri avancés (Quicksort, Heapsort, Merge Sort).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 12 : Optimisation des Algorithmes de Tri</h3>
            <ul>
                <li><strong>Séance 34 :</strong> Optimisation des algorithmes de tri dans des contextes réels.</li>
                <li><strong>Séance 35 :</strong> Pratique - Choisir et implémenter l’algorithme de tri le plus efficace pour différentes situations (jeu vidéo, actualité).</li>
                <li><strong>Séance 36 :</strong> Révision et consolidation des concepts d'algorithmes de tri.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 13 : Programmation Orientée Objet (POO)</h3>
            <ul>
                <li><strong>Séance 37 :</strong> Introduction à la POO (classes, objets, méthodes).</li>
                <li><strong>Séance 38 :</strong> Pratique - Modélisation d’un personnage de jeu vidéo en POO.</li>
                <li><strong>Séance 39 :</strong> Héritage et polymorphisme (théorie).</li>
            </ul>
        
            <!-- Continuez d'ajouter les semaines suivantes en suivant cette structure -->
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 14 : Héritage et Polymorphisme</h3>
            <ul>
                <li><strong>Séance 40 :</strong> Pratique - Implémentation d’un système d’héritage dans une application de gestion de personnages (jeu vidéo).</li>
                <li><strong>Séance 41 :</strong> Design patterns (Singleton, Factory).</li>
                <li><strong>Séance 42 :</strong> Pratique - Utilisation de design patterns pour optimiser la gestion des niveaux d’un jeu vidéo.</li>
            </ul>
        
            <!-- Ajoutez plus de semaines ici -->
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 36 : Bilan et Clôture</h3>
            <ul>
                <li><strong>Séance 106 :</strong> Bilan de l’année et retour sur les projets.</li>
                <li><strong>Séance 107 :</strong> Clôture et perspectives pour le futur.</li>
                <li><strong>Séance 108 :</strong> Journée de détente (activité créative, jeux de programmation).</li>
            </ul>
        </section>

        <!-- Calendrier -->
        <section id="calendar" class="content-section">
            <h2>Calendrier de cours des Tle NSI - 2024/2025</h2>
            <table class="calendar">
                <thead>
                    <tr>
                        <th>Date Mercredi</th>
                        <th>Cours Mercredi</th>
                        <th>Date Jeudi</th>
                        <th>Cours Jeudi</th>
                        <th>Date Vendredi</th>
                        <th>Cours Vendredi</th>
                    </tr>
                </thead>
                <tbody id="calendar-body">
                    <!-- Les lignes du calendrier seront générées ici par JavaScript -->
                </tbody>
            </table>
        </section>

        <!-- <section id="session0" class="content-section">
            <iframe src="../pass_ton_hack.pdf" frameborder="0"></iframe>
        </section> -->

        <!-- Cours -->
        <section id="session1" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 1 : Introduction à la Récursivité (Concepts de Base)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectifs de la séance :</h3>
            <ul>
                <li>Comprendre le concept de récursivité (cas de base et cas récursif).</li>
                <li>Savoir identifier et écrire des fonctions récursives.</li>
                <li>Appliquer la récursivité dans un problème lié aux jeux vidéo.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte : Sauver le héros d’un labyrinthe</h3>
            <p>L’objectif est d'aider un héros à sortir d’un labyrinthe en utilisant la récursivité. Chaque étape dans le labyrinthe représente une décision à prendre pour avancer ou reculer. Le labyrinthe est un tableau 2D où chaque cellule peut être un mur, un chemin ou la sortie.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Introduction au concept de récursivité</h3>
            <p>Qu’est-ce que la récursivité ?</p>
            <p>Une fonction récursive est une fonction qui s'appelle elle-même pour résoudre une version plus simple d’un problème.</p>
        
            <p>Une fonction récursive suit deux règles :</p>
            <ul>
                <li><strong>Cas de base :</strong> Condition d’arrêt pour éviter que la fonction ne s'appelle indéfiniment.</li>
                <li><strong>Cas récursif :</strong> Un appel à la fonction elle-même avec une version réduite du problème.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple simple : La Factorielle</h4>
            <pre><code>
    def factorielle(n):
        if n == 0:  # Cas de base
            return 1
        else:
            return n * factorielle(n - 1)  # Cas récursif
            </code></pre>
        
            <p>Explication du fonctionnement :</p>
            <p>Si <code>n = 3</code>, la fonction va appeler <code>factorielle(2)</code>, puis <code>factorielle(1)</code>, puis <code>factorielle(0)</code> qui est le cas de base, et renverra le résultat en remontant.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Application : Sauver un Héros Coincé dans un Labyrinthe</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Problème</h4>
            <p>Le héros est piégé dans un labyrinthe modélisé par une grille 2D. Il peut se déplacer à gauche, à droite, en haut ou en bas. L'objectif est de trouver la sortie (marquée par un "E") en utilisant une approche récursive.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Modélisation du labyrinthe</h4>
            <p>Nous représentons le labyrinthe comme une liste de listes en Python :</p>
        
            <pre><code>
    labyrinthe = [
        ['S', 1, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0]
    ]
            </code></pre>
        
            <ul>
                <li><strong>'S' :</strong> Point de départ (start).</li>
                <li><strong>'E' :</strong> Sortie.</li>
                <li><strong>0 :</strong> Chemin libre.</li>
                <li><strong>1 :</strong> Mur.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exploration récursive du labyrinthe</h4>
            <p>Le héros doit explorer toutes les directions possibles. Pour cela, nous allons créer une fonction récursive qui essaie toutes les directions (haut, bas, gauche, droite).</p>
        
            <pre><code>
    def explorer_labyrinthe(labyrinthe, x, y, visitees):
        # Vérifier les limites du labyrinthe
        if x < 0 or x >= len(labyrinthe) or y < 0 or y >= len(labyrinthe[0]):
            return False
        
        # Vérifier si la case est un mur ou déjà visitée
        if labyrinthe[x][y] == 1 or (x, y) in visitees:
            return False
        
        # Si on a trouvé la sortie
        if labyrinthe[x][y] == 'E':
            print(f"Sortie trouvée à la position ({x}, {y})")
            return True
        
        # Marquer la case comme visitée
        visitees.add((x, y))
        
        # Appeler la fonction récursive dans les 4 directions
        if (explorer_labyrinthe(labyrinthe, x+1, y, visitees) or  # Bas
            explorer_labyrinthe(labyrinthe, x-1, y, visitees) or  # Haut
            explorer_labyrinthe(labyrinthe, x, y+1, visitees) or  # Droite
            explorer_labyrinthe(labyrinthe, x, y-1, visitees)):   # Gauche
            return True
        
        # Si aucune direction ne fonctionne, on retourne False
        return False
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Explication du Code</h4>
            <ul>
                <li><strong>Cas de base :</strong> Si le héros sort du labyrinthe ou rencontre un mur (<code>1</code>), la fonction retourne <code>False</code>. Si le héros atteint la sortie (<code>'E'</code>), la fonction retourne <code>True</code>.</li>
                <li><strong>Cas récursif :</strong> Le héros essaie chaque direction (bas, haut, gauche, droite) en appelant la fonction récursive pour continuer à explorer le labyrinthe.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Mise en Pratique</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Tester l’exploration du labyrinthe</h4>
            <p>Les élèves doivent modifier et exécuter la fonction pour que le héros puisse trouver la sortie.</p>
        
            <pre><code>
    # Position de départ (0, 0)
    position_depart = (0, 0)
    
    # Ensemble des cases visitées
    cases_visitees = set()
    
    # Lancer la recherche de la sortie
    explorer_labyrinthe(labyrinthe, position_depart[0], position_depart[1], cases_visitees)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Améliorations</h4>
            <ul>
                <li><strong>Marquer le chemin parcouru :</strong> Ajouter une fonctionnalité pour afficher le chemin que le héros a pris jusqu'à la sortie.</li>
                <li><strong>Compter les mouvements :</strong> Ajouter un compteur pour afficher combien de mouvements le héros a effectués avant de trouver la sortie.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Conclusion et Récapitulatif</h3>
        
            <p><strong>Ce qu’ils ont appris :</strong></p>
            <ul>
                <li>Comprendre les concepts de récursivité avec un cas de base et un cas récursif.</li>
                <li>Appliquer la récursivité pour résoudre des problèmes complexes, comme un labyrinthe.</li>
            </ul>
        
            <p><strong>Défis à venir :</strong></p>
            <ul>
                <li>D'autres applications de la récursivité dans les jeux vidéo et les structures de données (arbres, tri récursif).</li>
                <li>Combiner récursivité et optimisations (mémoïsation) pour rendre les algorithmes plus efficaces.</li>
            </ul>
        </section>

        <section id="session2" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 2 : Pratique - Implémentation d’une Fonction Récursive pour Calculer une Suite Mathématique</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif :</h3>
            <ul>
                <li>Comprendre et implémenter une fonction récursive.</li>
                <li>Appliquer la récursivité pour résoudre un problème pratique, inspiré des mécanismes de jeux vidéo.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte :</h3>
            <p>Dans un jeu vidéo, un personnage accumule des points d'attaque supplémentaires au fil du temps à chaque coup porté à l'ennemi, mais les points bonus diminuent à chaque itération jusqu'à atteindre un seuil minimum. Cela peut être représenté par une suite mathématique où le bonus d'attaque à chaque coup est calculé récursivement.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple Concret :</h4>
            <p>Le personnage gagne 10 points d'attaque lors du premier coup, puis le bonus diminue de 1 point à chaque coup suivant. Cela forme une série mathématique décrite par :</p>
            <pre><code>Attaque(n) = Attaque(n−1) + (bonus initial − n)</code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 1 : Introduction à la Récursivité</h3>
            <p><strong>Concept de la récursivité :</strong></p>
            <p>Une fonction récursive s'appelle elle-même pour résoudre un problème plus simple à chaque étape, jusqu'à atteindre une condition de fin (ou cas de base).</p>
            
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple théorique :</h4>
            <p>Calcul de la suite de Fibonacci ou de la factorielle pour illustrer la récursivité.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 2 : Implémentation d'une Fonction Récursive</h3>
            <p><strong>Problème :</strong> Dans le jeu, à chaque attaque, le personnage accumule des points bonus. Le premier coup ajoute 10 points, puis chaque coup suivant ajoute 1 point de moins que le précédent jusqu'à atteindre 0. L'objectif est de calculer combien de points d'attaque sont accumulés après un certain nombre de coups.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Fonction récursive pour calculer le bonus d'attaque :</h4>
            <pre><code>
    def attaque_bonus(n):
        # Cas de base : quand le bonus atteint 0
        if n == 0:
            return 0
        else:
            # Récursion : bonus initial (10) - n + bonus précédent
            return (10 - n) + attaque_bonus(n - 1)
    
    # Exemple d'utilisation :
    coups = 5  # Le personnage donne 5 coups
    total_bonus = attaque_bonus(coups)
    print(f"Le total des points d'attaque après {coups} coups est de : {total_bonus}")
            </code></pre>
        
            <p><strong>Explication :</strong></p>
            <ul>
                <li>La fonction se base sur un cas de base où aucun coup n'est porté (0 bonus).</li>
                <li>À chaque appel récursif, le nombre de coups diminue de 1, et le bonus est calculé en fonction du coup précédent.</li>
                <li>Le bonus d’attaque diminue jusqu'à ce que la fonction atteigne le cas de base (0).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 3 : Étendre la Fonctionnalité</h3>
            <p>Amélioration du jeu : Proposer aux élèves d’ajouter des conditions supplémentaires :</p>
            <ul>
                <li>Le bonus ne peut pas descendre en dessous de 0.</li>
                <li>Ajouter un effet multiplicateur pour chaque coup critique (par exemple, multiplier par 2 si c’est un coup critique).</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple d’amélioration :</h4>
            <pre><code>
    def attaque_bonus(n, critique=False):
        if n == 0:
            return 0
        else:
            bonus = (10 - n)  # Le bonus diminue avec chaque coup
            if critique and n % 3 == 0:
                bonus *= 2  # Coup critique tous les 3 coups
            return bonus + attaque_bonus(n - 1, critique)
    
    # Exemple d'utilisation :
    coups = 5
    total_bonus = attaque_bonus(coups, critique=True)
    print(f"Le total des points d'attaque avec coups critiques est de : {total_bonus}")
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 4 : Exercices Pratiques</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Calcul d'attaque simple :</h4>
            <p>Modifier le nombre de coups portés et afficher le total des points d'attaque.</p>
            <p><strong>Exercice :</strong> Demander aux élèves de tester avec 3, 5 et 10 coups pour voir comment la récursivité calcule le total.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">2. Scénario avancé : Combats de boss :</h4>
            <p>Simuler un combat contre un boss où chaque coup critique donne des points bonus supplémentaires.</p>
            <p><strong>Exercice :</strong> Les élèves doivent implémenter une version du programme où tous les 5 coups, le personnage inflige un coup critique (multiplication du bonus par 3).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion</h3>
            <p><strong>Retour sur la notion de récursivité :</strong></p>
            <ul>
                <li><strong>Avantage :</strong> La récursivité permet de simplifier des calculs répétitifs en divisant le problème en sous-problèmes.</li>
                <li><strong>Inconvénient :</strong> Elle peut entraîner des problèmes de performance si elle est mal utilisée (pile d'appels récursifs trop grande).</li>
            </ul>
        
            <p><strong>Lien avec le jeu vidéo :</strong> La récursivité est un outil puissant pour modéliser des mécanismes de jeu où des actions répétitives évoluent à chaque itération, comme la gestion des dégâts dans les combats.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice final :</h4>
            <p>Les élèves devront créer une version améliorée de la fonction récursive qui inclut plusieurs types de coups (coup normal, coup critique, coup spécial) avec des bonus différents et implémenter une stratégie pour battre un boss avec un nombre limité de coups.</p>
        </section>

        <section id="session3" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 3 : Applications Pratiques de la Récursivité - Problèmes Simples</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectifs de la séance :</h3>
            <ul>
                <li>Comprendre la récursivité à travers des exemples simples.</li>
                <li>Appliquer la récursivité pour résoudre des problèmes inspirés des jeux vidéo.</li>
                <li>Créer des programmes interactifs et ludiques en utilisant la récursivité.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Rappel des concepts de base de la récursivité</h3>
            <p><strong>Cas de base :</strong> Condition qui permet d'arrêter la récursivité.</p>
            <p><strong>Cas récursif :</strong> La fonction qui s'appelle elle-même avec une version simplifiée du problème.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple théorique :</h4>
            <p>Calcul de la factorielle d’un nombre.</p>
            <pre><code>
    def factorielle(n):
        if n == 0:
            return 1  # Cas de base
        else:
            return n * factorielle(n - 1)  # Cas récursif
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Application : Exploration d'un Donjon Récursif</h3>
            <p>Dans ce projet, nous allons simuler un héros explorant un donjon. Le donjon est représenté par un labyrinthe (sous forme de matrice 2D), où le héros doit trouver la sortie. La récursivité sera utilisée pour explorer toutes les directions possibles à chaque intersection du labyrinthe.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Modélisation du donjon</h4>
            <p>Le donjon est représenté par une matrice où :</p>
            <ul>
                <li>1 représente un mur,</li>
                <li>0 représente un chemin libre,</li>
                <li><strong>S</strong> la position de départ,</li>
                <li><strong>E</strong> la sortie à atteindre.</li>
            </ul>
            <pre><code>
    donjon = [
        ['S', 1, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0]
    ]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Création de la fonction récursive d’exploration</h4>
            <p>On écrit une fonction récursive pour explorer le donjon. À chaque étape, le héros explore les cases adjacentes (haut, bas, gauche, droite) jusqu'à trouver la sortie.</p>
            <pre><code>
    def explorer_donjon(donjon, x, y, visitees):
        # Vérifier les limites du donjon
        if x < 0 or x >= len(donjon) or y < 0 or y >= len(donjon[0]):
            return False
        
        # Vérifier si c'est un mur ou une case déjà visitée
        if donjon[x][y] == 1 or (x, y) in visitees:
            return False
        
        # Si on a trouvé la sortie
        if donjon[x][y] == 'E':
            print(f"Sortie trouvée à la position ({x}, {y})")
            return True
        
        # Marquer la case comme visitée
        visitees.add((x, y))
        
        # Exploration récursive des 4 directions
        if (explorer_donjon(donjon, x+1, y, visitees) or  # Bas
            explorer_donjon(donjon, x-1, y, visitees) or  # Haut
            explorer_donjon(donjon, x, y+1, visitees) or  # Droite
            explorer_donjon(donjon, x, y-1, visitees)):   # Gauche
            return True
        
        # Si aucune direction ne permet d’avancer, retour en arrière
        return False
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Lancement de l'exploration</h4>
            <p>L’appel de la fonction d'exploration depuis la position de départ :</p>
            <pre><code>
    visitees = set()
    explorer_donjon(donjon, 0, 0, visitees)
            </code></pre>
            <p>Les élèves peuvent visualiser comment la récursivité permet au héros de tester différentes directions jusqu'à trouver la sortie du donjon.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Application : Génération de Terrains Fractals avec la Récursivité</h3>
            <p>Un autre exemple ludique pour explorer la récursivité est la génération de terrains fractals. C’est un algorithme utilisé dans certains jeux vidéo pour générer des paysages ou des environnements de manière procédurale.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Introduction au concept des fractals</h4>
            <p>Explication de la notion de fractal : une figure qui se divise en parties similaires à l'ensemble.</p>
            <p>On montre un exemple simple, tel que le triangle de Sierpinski ou un arbre fractal, qui est un arbre où chaque branche se divise en deux sous-branches plus petites.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Génération d’un arbre fractal</h4>
            <p>Nous allons utiliser la récursivité pour dessiner un arbre où chaque branche se divise en deux sous-branches plus petites. Pour simplifier, on peut utiliser la bibliothèque turtle de Python, qui permet de dessiner facilement.</p>
            <pre><code>
    import turtle

    def dessiner_arbre(longueur, angle):
        if longueur > 5:
            turtle.forward(longueur)
            turtle.right(angle)
            dessiner_arbre(longueur - 15, angle)
            turtle.left(angle * 2)
            dessiner_arbre(longueur - 15, angle)
            turtle.right(angle)
            turtle.backward(longueur)
    
    # Initialisation de Turtle
    turtle.speed("fastest")
    turtle.left(90)  # Faire pointer la tortue vers le haut
    dessiner_arbre(100, 30)  # Commence avec une longueur de 100
    turtle.done()
            </code></pre>
            <p>Les élèves pourront voir comment la récursivité permet de générer une figure qui se répète de manière auto-similaire.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Conclusion et Améliorations</h3>
            <p><strong>Extension de l’exploration du donjon :</strong> Les élèves peuvent être encouragés à ajouter des obstacles, des trésors ou d'autres éléments interactifs dans le donjon pour rendre l'exploration plus intéressante.</p>
            <p><strong>Améliorations sur l’arbre fractal :</strong> Les élèves peuvent modifier l’angle de l’arbre fractal ou ajouter des couleurs pour rendre le dessin plus complexe et esthétique.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Discussion :</h4>
            <ul>
                <li>Quand utiliser la récursivité vs les boucles ?</li>
                <li>Les limites de la récursivité (profondeur maximale de récursion, efficacité).</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice :</h4>
            <p>Modifier le code de l’exploration du donjon pour ajouter des monstres ou des pièges à éviter pendant l'exploration.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion de la Séance</h3>
            <p>À la fin de cette séance, les élèves auront appris à utiliser la récursivité pour résoudre des problèmes d’exploration et de génération d’environnements, avec des exemples concrets tirés des jeux vidéo. Cela les prépare à appliquer la récursivité dans des projets plus complexes à l'avenir.</p>
        </section>

        <section id="session4" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 4 : Introduction aux Algorithmes de Recherche Récursive – Recherche Binaire</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre et implémenter un algorithme de recherche binaire en utilisant une approche récursive. Ils doivent également l'appliquer à un contexte ludique (jeu vidéo) pour renforcer la compréhension par la pratique.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction à la Recherche Binaire</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Le Contexte :</h4>
            <p>Dans un jeu vidéo de chasse au trésor, le joueur doit trouver un trésor caché sur une île divisée en 100 sections numérotées de 1 à 100. Le joueur ne sait pas où le trésor est caché et doit le retrouver en posant des questions.</p>
            <p><strong>Problème initial :</strong> Si le joueur cherche le trésor en vérifiant chaque section, cela peut prendre beaucoup de temps. On appelle cela une recherche linéaire. Si le trésor est dans la dernière section, il devra vérifier toutes les sections avant d'arriver à la bonne, ce qui est peu efficace.</p>
            <p><strong>Solution optimisée :</strong> Utiliser la recherche binaire pour diviser l’espace de recherche en deux à chaque étape. Cela permet de réduire le nombre de vérifications nécessaires.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">L'idée de la Recherche Binaire :</h4>
            <p>La recherche binaire est un algorithme qui repose sur le principe de diviser pour régner (divide and conquer). Voici les étapes :</p>
            <ul>
                <li>Le joueur divise la zone de recherche en deux parties égales.</li>
                <li>Le joueur demande si le trésor se trouve dans la partie supérieure ou inférieure.</li>
                <li>À chaque étape, l’algorithme divise à nouveau la zone en deux et répète le processus jusqu’à ce que la section contenant le trésor soit trouvée.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple Concret :</h4>
            <p>Imaginons que le trésor soit dans la section 75.</p>
            <ol>
                <li>Étape 1 : Le joueur commence par diviser la zone en deux et vérifie la section du milieu (50).</li>
                <li>Est-ce que le trésor est dans la section 50 ? Non.</li>
                <li>Le trésor est-il dans une section plus haute ou plus basse que 50 ? Le trésor est dans une section plus haute.</li>
                <li>Étape 2 : Le joueur cherche donc dans les sections 51 à 100. La nouvelle section du milieu est 75.</li>
                <li>Est-ce que le trésor est dans la section 75 ? Oui !</li>
                <li>Le trésor est trouvé.</li>
            </ol>
            <p><strong>Avantage :</strong> En seulement 2 étapes, le joueur a trouvé le trésor, alors qu'une recherche linéaire aurait pris 75 étapes.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Explication Théorique de la Recherche Binaire</h3>
            <p>Comment ça fonctionne en termes d’algorithme :</p>
            <ol>
                <li><strong>Début :</strong> L’algorithme commence avec une liste triée de sections (de 1 à 100).</li>
                <li><strong>Milieu :</strong> Il trouve la section au milieu de la liste.</li>
                <li><strong>Comparaison :</strong> Il compare la section du milieu avec la section où le trésor est caché :
                    <ul>
                        <li>Si le trésor est dans la section du milieu, il s’arrête là.</li>
                        <li>Si le trésor est dans une section plus petite, il continue à chercher dans la moitié inférieure.</li>
                        <li>Si le trésor est dans une section plus grande, il continue à chercher dans la moitié supérieure.</li>
                    </ul>
                </li>
                <li><strong>Récursion :</strong> L’algorithme répète ce processus jusqu’à ce qu’il trouve le trésor.</li>
            </ol>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple de Pseudo-code :</h4>
            <pre><code>
    recherche_binaire(liste, debut, fin, cible):
    Si debut > fin, retourner -1 (le trésor n'est pas dans la liste)
    
    milieu = (debut + fin) // 2
    
    Si liste[milieu] == cible, retourner milieu (le trésor est trouvé)
    
    Si liste[milieu] < cible:
        Rechercher dans la moitié supérieure (milieu + 1 à fin)
    Sinon:
        Rechercher dans la moitié inférieure (debut à milieu - 1)
            </code></pre>
        
            <p><strong>Cas de base :</strong> Si la liste est vide (début > fin), le trésor n’est pas dans la liste.</p>
            <p><strong>Cas récursif :</strong> À chaque étape, la liste est divisée en deux, et l’algorithme est rappelé sur la moitié pertinente (supérieure ou inférieure).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique dans le Contexte du Jeu Vidéo</h3>
            
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Créer la Liste des Sections</h4>
            <p>Tout d’abord, nous allons représenter l’île avec une liste de sections numérotées de 1 à 100 :</p>
            <pre><code>
    sections = list(range(1, 101))
            </code></pre>
            <p>Ensuite, nous allons choisir une section aléatoire pour cacher le trésor :</p>
            <pre><code>
    import random
    section_tresor = random.choice(sections)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Implémenter la Recherche Binaire</h4>
            <p>Nous allons maintenant implémenter l'algorithme de recherche binaire récursive pour chercher le trésor. À chaque étape, le programme indiquera si le trésor est dans la moitié supérieure ou inférieure :</p>
            <pre><code>
    def recherche_binaire(liste, debut, fin, cible):
        if debut > fin:
            print("Le trésor n'est pas sur cette île !")
            return -1
        
        milieu = (debut + fin) // 2
        print(f"Vous cherchez dans la section {milieu}...")
        
        if liste[milieu] == cible:
            print(f"Félicitations ! Vous avez trouvé le trésor dans la section {milieu} !")
            return milieu
        elif liste[milieu] < cible:
            print("Le trésor est dans une section plus haute.")
            return recherche_binaire(liste, milieu + 1, fin, cible)
        else:
            print("Le trésor est dans une section plus basse.")
            return recherche_binaire(liste, debut, milieu - 1, cible)
    
    # Appel de la fonction
    recherche_binaire(sections, 0, len(sections) - 1, section_tresor)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Extension et Challenge : Limite de Tentatives</h4>
            <p>Pour ajouter un défi supplémentaire, introduisez une limite de tentatives. Comme la recherche binaire divise la zone par deux à chaque étape, le nombre maximum de tentatives pour trouver le trésor dans une liste de 100 éléments est de 7 (car log2(100) ≈ 7).</p>
            <p>Modifiez l'algorithme pour limiter le nombre de tentatives à 7. Si le joueur dépasse ce nombre, il échoue à trouver le trésor.</p>
        
            <pre><code>
    def recherche_binaire(liste, debut, fin, cible, tentatives=7):
        if debut > fin or tentatives == 0:
            print("Le trésor n'a pas été trouvé, vous avez épuisé vos tentatives.")
            return -1
        
        milieu = (debut + fin) // 2
        print(f"Vous cherchez dans la section {milieu}... Tentatives restantes : {tentatives}")
        
        if liste[milieu] == cible:
            print(f"Félicitations ! Vous avez trouvé le trésor dans la section {milieu} !")
            return milieu
        elif liste[milieu] < cible:
            print("Le trésor est dans une section plus haute.")
            return recherche_binaire(liste, milieu + 1, fin, cible, tentatives - 1)
        else:
            print("Le trésor est dans une section plus basse.")
            return recherche_binaire(liste, debut, milieu - 1, cible, tentatives - 1)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Réflexion</h3>
            <p>À la fin de cette séance :</p>
            <ul>
                <li>Les élèves auront compris le concept de récursivité et comment elle peut être utilisée pour diviser un problème en sous-problèmes plus petits.</li>
                <li>Ils auront appris à implémenter un algorithme de recherche binaire pour améliorer l’efficacité de la recherche par rapport à une recherche linéaire.</li>
            </ul>
        
            <p><strong>Discussion sur la complexité temporelle :</strong> La recherche linéaire prend O(n) opérations, tandis que la recherche binaire prend O(log n) opérations, ce qui est bien plus rapide pour de grandes listes.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice complémentaire :</h4>
            <p>Comparer la recherche linéaire et la recherche binaire : Demander aux élèves d’implémenter une recherche linéaire et de compter combien de tentatives elle nécessite en moyenne pour trouver le trésor.</p>
        </section>

        <section id="session5" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 5 : Pratique – Recherche d’un Personnage de Manga avec un Algorithme de Recherche Binaire</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent utiliser l’algorithme de recherche binaire pour retrouver un personnage de manga dans une liste triée. Cela permettra de consolider les notions de recherche efficace et d’appliquer la récursivité dans un contexte concret.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte Manga :</h3>
            <p>Dans cette séance, vous allez simuler une recherche dans une base de données de personnages de manga. Imaginez une application où les utilisateurs peuvent rechercher un personnage de manga par son nom. Comme la base de données contient de nombreux personnages, une recherche linéaire serait inefficace. La solution ? Utiliser un algorithme de recherche binaire pour accélérer la recherche.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Introduction au Problème</h3>
            <p><strong>Problème :</strong> Vous avez une liste triée de personnages de manga et vous devez trouver un personnage spécifique rapidement. Plutôt que de chercher chaque nom un par un (recherche linéaire), vous allez utiliser un algorithme de recherche binaire pour optimiser le processus.</p>
            <ul>
                <li><strong>Recherche linéaire :</strong> Il faut potentiellement parcourir tous les éléments de la liste pour trouver le bon personnage. Si la liste contient 100 personnages, il pourrait falloir jusqu'à 100 comparaisons dans le pire des cas.</li>
                <li><strong>Recherche binaire :</strong> La liste est triée, donc à chaque étape, vous pouvez diviser la liste en deux, ce qui accélère la recherche de manière exponentielle.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Explication du Contexte et de la Recherche Binaire</h3>
            <p><strong>Contexte Manga :</strong> Imaginez une application de fans de manga où les utilisateurs peuvent rechercher des personnages. Chaque personnage a un nom, et la liste de personnages est déjà triée alphabétiquement.</p>
            <p><strong>Exemple :</strong> Voici une liste simplifiée de personnages de mangas (cette liste est triée) :</p>
        
            <pre><code>["Asta", "Edward", "Goku", "Luffy", "Naruto", "Sasuke", "Tanjiro", "Vegeta", "Zoro"]</code></pre>
        
            <p>Si vous cherchez "Luffy", au lieu de commencer à chercher depuis le début de la liste et d’aller un par un (recherche linéaire), vous pouvez commencer au milieu et diviser la recherche en deux.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Recherche Binaire : Principe et Explication</h3>
            <p>La recherche binaire consiste à diviser la liste en deux parties égales, à comparer l’élément du milieu avec le nom que vous cherchez, puis à continuer à diviser la moitié pertinente jusqu'à ce que vous trouviez l'élément, ou que vous déterminiez qu'il n'est pas dans la liste.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple Concret :</h4>
            <p>Si vous cherchez "Luffy", voici les étapes :</p>
            <ol>
                <li>La liste contient 9 personnages, l’élément du milieu est à la position 4 (index 4, c’est "Naruto").</li>
                <li>"Luffy" est plus petit que "Naruto" dans l’ordre alphabétique, donc on cherche dans la première moitié de la liste (éléments [0, 3]).</li>
                <li>Dans cette nouvelle sous-liste, l’élément du milieu est à la position 1 (index 1, c’est "Edward").</li>
                <li>"Luffy" est plus grand que "Edward", donc on cherche dans la moitié supérieure de cette sous-liste.</li>
                <li>On trouve "Luffy" à l’index 3.</li>
            </ol>
        
            <p>Conclusion : La recherche binaire a permis de trouver "Luffy" en seulement 3 comparaisons, au lieu de 5 comparaisons en recherche linéaire.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Explication Théorique de l'Algorithme</h4>
            <pre><code>
    recherche_binaire(liste, debut, fin, cible):
    Si debut > fin, retourner -1 (le personnage n'est pas dans la liste)
    
    milieu = (debut + fin) // 2
    
    Si liste[milieu] == cible, retourner milieu (personnage trouvé)
    
    Si liste[milieu] < cible:
        Rechercher dans la moitié supérieure (milieu + 1 à fin)
    Sinon:
        Rechercher dans la moitié inférieure (debut à milieu - 1)
            </code></pre>
        
            <p><strong>Cas de base :</strong> Si la sous-liste est vide (debut > fin), le personnage n'est pas dans la liste.</p>
            <p><strong>Cas récursif :</strong> La fonction appelle récursivement la recherche binaire sur la moitié supérieure ou inférieure selon la comparaison du personnage du milieu avec celui recherché.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique : Recherche Binaire sur une Liste de Personnages de Manga</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Créer la Liste des Personnages de Manga</h4>
            <p>On va d’abord créer une liste de personnages triée alphabétiquement.</p>
        
            <pre><code>
    personnages_manga = ["Asta", "Edward", "Goku", "Luffy", "Naruto", "Sasuke", "Tanjiro", "Vegeta", "Zoro"]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Implémenter la Recherche Binaire</h4>
            <p>On implémente l’algorithme de recherche binaire pour chercher un personnage dans cette liste. L’algorithme prend la liste de personnages, les indices de début et de fin, et le nom du personnage à chercher.</p>
        
            <pre><code>
    def recherche_binaire(liste, debut, fin, cible):
        if debut > fin:
            print(f"{cible} n'est pas dans la liste.")
            return -1
        
        milieu = (debut + fin) // 2
        print(f"Vérification du personnage au milieu : {liste[milieu]}")
    
        if liste[milieu] == cible:
            print(f"Félicitations ! {cible} a été trouvé à la position {milieu}.")
            return milieu
        elif liste[milieu] < cible:
            print(f"{cible} est après {liste[milieu]}. Recherche dans la moitié supérieure.")
            return recherche_binaire(liste, milieu + 1, fin, cible)
        else:
            print(f"{cible} est avant {liste[milieu]}. Recherche dans la moitié inférieure.")
            return recherche_binaire(liste, debut, milieu - 1, cible)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Recherche d’un Personnage</h4>
            <p>Invitez les élèves à tester cette fonction en recherchant des personnages comme Luffy, Naruto, ou d'autres dans la liste.</p>
        
            <pre><code>
    # Appel de la fonction de recherche
    recherche_binaire(personnages_manga, 0, len(personnages_manga) - 1, "Luffy")
            </code></pre>
        
            <p><strong>Exemple de sortie :</strong></p>
            <pre><code>
    Vérification du personnage au milieu : Naruto
    Luffy est avant Naruto. Recherche dans la moitié inférieure.
    Vérification du personnage au milieu : Edward
    Luffy est après Edward. Recherche dans la moitié supérieure.
    Vérification du personnage au milieu : Luffy
    Félicitations ! Luffy a été trouvé à la position 3.
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Extension : Limite de Tentatives</h3>
            <p>Ajoutez une fonctionnalité pour limiter le nombre de tentatives à un certain nombre, comme 4 tentatives, pour rendre l'exercice plus difficile et montrer comment l’algorithme optimise les recherches.</p>
        
            <pre><code>
    def recherche_binaire(liste, debut, fin, cible, tentatives):
        if debut > fin or tentatives == 0:
            print(f"{cible} n'a pas été trouvé ou les tentatives sont épuisées.")
            return -1
        
        milieu = (debut + fin) // 2
        print(f"Vérification du personnage au milieu : {liste[milieu]} - Tentatives restantes : {tentatives}")
    
        if liste[milieu] == cible:
            print(f"Félicitations ! {cible} a été trouvé à la position {milieu}.")
            return milieu
        elif liste[milieu] < cible:
            print(f"{cible} est après {liste[milieu]}. Recherche dans la moitié supérieure.")
            return recherche_binaire(liste, milieu + 1, fin, cible, tentatives - 1)
        else:
            print(f"{cible} est avant {liste[milieu]}. Recherche dans la moitié inférieure.")
            return recherche_binaire(liste, debut, milieu - 1, cible, tentatives - 1)
    
    # Lancer la recherche avec une limite de tentatives
    recherche_binaire(personnages_manga, 0, len(personnages_manga) - 1, "Luffy", tentatives=4)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Réflexion</h3>
            <ul>
                <li><strong>Discussion sur l’efficacité :</strong> Demandez aux élèves de comparer le nombre de tentatives nécessaires pour une recherche binaire par rapport à une recherche linéaire. Pour une liste de 9 éléments, la recherche binaire prend généralement 3 comparaisons, contre 9 dans le pire des cas pour une recherche linéaire.</li>
                <li><strong>Introduction à la complexité algorithmique :</strong> La recherche binaire a une complexité de O(log n), ce qui la rend beaucoup plus rapide que la recherche linéaire O(n) pour de grandes listes.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif de la Séance :</h3>
            <ul>
                <li>Utiliser l'algorithme de recherche binaire dans un contexte de liste de personnages de manga.</li>
                <li>Appliquer des concepts de récursivité pour diviser un problème complexe en sous-problèmes plus simples.</li>
                <li>Comparer les performances entre une recherche linéaire et une recherche binaire, notamment en termes de nombre de comparaisons.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exercice Complémentaire :</h3>
            <ul>
                <li>Implémenter une recherche linéaire et la comparer à la recherche binaire.</li>
                <li>Ajouter d’autres fonctionnalités à l’application, comme la possibilité de rechercher par d'autres attributs (ex : force, univers d’origine des personnages).</li>
            </ul>
        </section>

        <section id="session6" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 6 : Analyse de la Complexité d’un Algorithme de Recherche Récursive</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre comment analyser la complexité d’un algorithme récursif en termes de temps d’exécution. Ils découvriront la différence entre la complexité linéaire et la complexité logarithmique, et appliqueront ces concepts à un contexte de jeu vidéo.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte :</h3>
            <p>Dans un jeu vidéo, le joueur doit rechercher des objets cachés dans une carte divisée en sections. Vous avez déjà appris à implémenter des algorithmes de recherche récursive comme la recherche binaire. Maintenant, nous allons voir comment mesurer et analyser la complexité de cet algorithme, c’est-à-dire, combien de temps il prend en fonction du nombre de sections à explorer.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Introduction à la Notion de Complexité d’un Algorithme</h3>
            <p><strong>Qu’est-ce que la complexité d’un algorithme ?</strong></p>
            <p>La complexité d’un algorithme est une manière de mesurer combien de temps ou combien de ressources (comme la mémoire) un algorithme va utiliser en fonction de la taille du problème à résoudre. En général, la complexité est exprimée en termes de nombre d’opérations que l’algorithme doit effectuer, et elle est souvent notée à l’aide de la notation Big-O.</p>
            
            <p><strong>Big-O :</strong> Il s'agit d'une notation utilisée pour décrire comment le temps d’exécution ou l’utilisation de la mémoire d’un algorithme augmente lorsque la taille de l’entrée (comme le nombre de sections sur la carte) augmente.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemples de complexités communes :</h4>
            <ul>
                <li><strong>Complexité linéaire (O(n)) :</strong> Si l’algorithme doit effectuer une opération pour chaque élément de la liste, le temps d'exécution augmente en ligne droite avec la taille du problème. Exemple : Recherche linéaire.</li>
                <li><strong>Complexité logarithmique (O(log n)) :</strong> Si l’algorithme divise le problème en deux à chaque étape, le temps d'exécution augmente beaucoup plus lentement que la taille du problème. Exemple : Recherche binaire.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Pourquoi c'est important ?</h4>
            <ul>
                <li>Dans un jeu vidéo, si un algorithme est trop lent (complexité élevée), il pourrait ralentir le jeu.</li>
                <li>Un algorithme plus rapide permet de rechercher des objets ou des ennemis sur de grandes cartes sans affecter les performances du jeu.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Revue des Algorithmes de Recherche</h3>
            <p>Nous avons déjà implémenté deux algorithmes de recherche :</p>
            <ul>
                <li><strong>Recherche linéaire :</strong> Le joueur vérifie chaque section de la carte une à une jusqu’à trouver l’objet. Cet algorithme prend du temps, surtout si l’objet est dans la dernière section.</li>
                <li><strong>Recherche binaire :</strong> Le joueur divise la carte en deux à chaque étape, réduisant le nombre de sections à chercher. Cet algorithme est beaucoup plus rapide.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple Visuel :</h4>
            <p>Prenons l’exemple d’une carte divisée en 32 sections. Le joueur doit chercher un objet caché quelque part.</p>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">1. Recherche linéaire :</h5>
            <p>Si l'objet est dans la 32e section, il faudra vérifier 32 sections avant de trouver l'objet.</p>
            <p><strong>Nombre d’opérations =</strong> 32 (pour une carte de 32 sections).</p>
            <p><strong>Complexité :</strong> O(n) (linéaire).</p>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">2. Recherche binaire :</h5>
            <p>Avec cet algorithme, on divise par deux à chaque étape. Pour 32 sections, il ne faudra que 5 vérifications pour trouver l’objet.</p>
            <p><strong>Nombre d’opérations ≈</strong> log2(32) = 5 (car 2^5 = 32).</p>
            <p><strong>Complexité :</strong> O(log n) (logarithmique).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Analyse de la Recherche Linéaire</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Algorithme de recherche linéaire :</h4>
        
            <pre><code>
    def recherche_lineaire(liste, cible):
        for i in range(len(liste)):
            print(f"Vérification de la section {liste[i]}")
            if liste[i] == cible:
                print(f"Objet trouvé dans la section {liste[i]}")
                return i
        print("Objet non trouvé")
        return -1
    
    # Création d'une liste de sections
    sections = list(range(1, 33))  # Carte avec 32 sections
    
    # Appel de la fonction de recherche
    recherche_lineaire(sections, 32)
            </code></pre>
        
            <p><strong>Analyse :</strong></p>
            <p>Dans le pire des cas (l’objet est dans la dernière section), l’algorithme doit parcourir 32 sections.</p>
            <p>Le nombre d’opérations nécessaires est donc directement proportionnel au nombre de sections : O(n).</p>
            <p><strong>Question pour les élèves :</strong> Que se passe-t-il si on augmente le nombre de sections à 100 ? Combien d’opérations faudra-t-il faire ?</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Analyse de la Recherche Binaire</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Rappel de l'algorithme de recherche binaire :</h4>
        
            <pre><code>
    def recherche_binaire(liste, debut, fin, cible):
        if debut > fin:
            print("Objet non trouvé")
            return -1
        
        milieu = (debut + fin) // 2
        print(f"Vérification de la section {liste[milieu]}...")
        
        if liste[milieu] == cible:
            print(f"Objet trouvé dans la section {liste[milieu]}")
            return milieu
        elif liste[milieu] < cible:
            return recherche_binaire(liste, milieu + 1, fin, cible)
        else:
            return recherche_binaire(liste, debut, milieu - 1, cible)
    
    # Appel de la fonction de recherche binaire
    sections = list(range(1, 33))  # Carte avec 32 sections
    recherche_binaire(sections, 0, len(sections) - 1, 32)
            </code></pre>
        
            <p><strong>Analyse :</strong></p>
            <p>À chaque étape, l'algorithme divise la liste en deux. Cela signifie que le nombre d’opérations est proportionnel à log2(n).</p>
            <p>Pour 32 sections, il faut au maximum 5 vérifications (car 2^5 = 32).</p>
            <p><strong>Complexité :</strong> O(log n).</p>
            <p><strong>Question pour les élèves :</strong> Que se passe-t-il si la carte contient 100 sections ?</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">5. Conclusion et Discussion</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Discussion finale :</h4>
            <p>Les élèves doivent comprendre que la recherche binaire est bien plus rapide que la recherche linéaire, surtout lorsque le nombre de sections devient très grand.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Résumé des points clés :</h4>
            <ul>
                <li><strong>Recherche linéaire :</strong> Complexité O(n), ce qui signifie que le nombre d’opérations augmente linéairement avec la taille du problème.</li>
                <li><strong>Recherche binaire :</strong> Complexité O(log n), ce qui signifie que le nombre d’opérations augmente beaucoup plus lentement, même pour de grandes tailles de problèmes.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice de réflexion :</h4>
            <p>Demander aux élèves d’expliquer pourquoi un jeu vidéo qui utilise des cartes énormes aurait intérêt à utiliser des algorithmes comme la recherche binaire plutôt que la recherche linéaire.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Extension : Exercice complémentaire :</h4>
            <p><strong>Challenge :</strong> Demandez aux élèves d’ajouter un chronomètre dans le programme pour mesurer le temps réel que prend chaque algorithme pour trouver l’objet dans une liste de 1 000 sections. Ils devront comparer le temps d'exécution entre la recherche linéaire et la recherche binaire en utilisant la bibliothèque Python <code>time</code>.</p>
        
            <pre><code>
    import time

    # Chronométrer la recherche linéaire
    start_time = time.time()
    recherche_lineaire(sections, 32)
    print("Temps d'exécution de la recherche linéaire :", time.time() - start_time)
    
    # Chronométrer la recherche binaire
    start_time = time.time()
    recherche_binaire(sections, 0, len(sections) - 1, 32)
    print("Temps d'exécution de la recherche binaire :", time.time() - start_time)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif de la Séance :</h3>
            <p>À la fin de cette séance, les élèves auront appris à :</p>
            <ul>
                <li>Analyser la complexité d’un algorithme.</li>
                <li>Comprendre pourquoi certains algorithmes (comme la recherche binaire) sont beaucoup plus rapides que d'autres (recherche linéaire).</li>
                <li>Appliquer ces notions de complexité à des cas concrets, comme la recherche d’objets dans un jeu vidéo.</li>
            </ul>
        </section>

        <section id="session7" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 7 : Introduction au Backtracking (Concepts de Base)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre les concepts de base du backtracking et les implémenter dans un contexte pratique en lien avec un jeu vidéo. Le backtracking est un algorithme qui permet de résoudre des problèmes en explorant toutes les solutions possibles et en revenant en arrière si une solution ne fonctionne pas.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte du Jeu Vidéo :</h3>
            <p>Dans un jeu d'exploration, le joueur est perdu dans un labyrinthe complexe. Il doit trouver le chemin vers la sortie. Cependant, certains chemins sont bloqués ou mènent à des culs-de-sac. L’objectif est d’utiliser un algorithme de backtracking pour trouver la sortie en explorant le labyrinthe, tout en revenant en arrière lorsqu’un chemin ne fonctionne pas.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Introduction au Problème</h3>
            <p>Le joueur doit naviguer dans un labyrinthe (représenté par une grille 2D) et trouver la sortie. À chaque case, il peut se déplacer vers le haut, bas, gauche, ou droite, mais certains chemins sont bloqués (murs), et certains conduisent à des impasses.</p>
            <p><strong>Problème initial :</strong> Comment trouver le chemin optimal pour sortir du labyrinthe sans devoir essayer toutes les combinaisons possibles manuellement ?</p>
            <p><strong>Solution optimisée :</strong> Utiliser un algorithme de backtracking pour explorer tous les chemins possibles, tout en revenant en arrière (backtrack) lorsqu'on atteint un cul-de-sac ou un chemin bloqué.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Explication Théorique du Backtracking</h3>
            <p>Le backtracking est un algorithme récursif qui explore toutes les solutions possibles à un problème en essayant différentes options. Lorsqu’une option échoue, l'algorithme revient en arrière (backtrack) et essaie une autre option.</p>
            <p><strong>Étapes générales de l'algorithme de backtracking :</strong></p>
            <ul>
                <li>Commencer à partir d’un point de départ (ici, l’entrée du labyrinthe).</li>
                <li>Essayer une direction (haut, bas, gauche, droite).</li>
                <li>Vérifier si la direction est valide (pas de mur, pas de chemin déjà emprunté).</li>
                <li>Si la direction mène à la sortie, on a trouvé une solution.</li>
                <li>Si la direction ne mène nulle part (cul-de-sac), revenir en arrière et essayer une autre direction.</li>
                <li>Répéter jusqu’à trouver la sortie ou épuiser toutes les options.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple de Pseudo-code :</h4>
            <pre><code>
    trouver_sortie(labyrinthe, position_x, position_y):
    Si la position actuelle est la sortie :
        Afficher "Sortie trouvée"
        Finir l'algorithme
    
    Marquer la position actuelle comme visitée
    
    Pour chaque direction possible (haut, bas, gauche, droite) :
        Si la direction est valide et non visitée :
            Appeler récursivement trouver_sortie avec la nouvelle position
            Si cela conduit à la sortie, Finir
    
    Si aucune direction ne fonctionne, revenir en arrière (backtrack)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Implémentation du Backtracking dans un Labyrinthe</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Modélisation du Labyrinthe</h4>
            <p>Nous allons représenter le labyrinthe comme une grille 2D où chaque case peut être soit un mur (1), soit un chemin libre (0), soit l’entrée (S), soit la sortie (E).</p>
            <p><strong>Voici un exemple de labyrinthe :</strong></p>
            <pre><code>
    labyrinthe = [
        ['S', 1, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0]
    ]
            </code></pre>
            <ul>
                <li><strong>S :</strong> point de départ (entrée).</li>
                <li><strong>E :</strong> point d'arrivée (sortie).</li>
                <li><strong>1 :</strong> mur (chemin bloqué).</li>
                <li><strong>0 :</strong> chemin possible.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Implémenter l'Algorithme de Backtracking</h4>
            <pre><code>
    # Labyrinthe 2D
    labyrinthe = [
        ['S', 1, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0]
    ]
    
    # Fonction de backtracking pour explorer le labyrinthe
    def explorer_labyrinthe(labyrinthe, x, y, visitees):
        # Vérifier si la position est hors du labyrinthe
        if x < 0 or x >= len(labyrinthe) or y < 0 or y >= len(labyrinthe[0]):
            return False
        
        # Si la position est un mur ou déjà visitée
        if labyrinthe[x][y] == 1 or (x, y) in visitees:
            return False
        
        # Si on a trouvé la sortie
        if labyrinthe[x][y] == 'E':
            print(f"Sortie trouvée à la position ({x}, {y})")
            return True
        
        # Marquer la position comme visitée
        visitees.add((x, y))
        
        # Explorer les directions : bas, haut, droite, gauche
        if (explorer_labyrinthe(labyrinthe, x+1, y, visitees) or  # Bas
            explorer_labyrinthe(labyrinthe, x-1, y, visitees) or  # Haut
            explorer_labyrinthe(labyrinthe, x, y+1, visitees) or  # Droite
            explorer_labyrinthe(labyrinthe, x, y-1, visitees)):   # Gauche
            return True
        
        # Si aucune direction ne fonctionne, revenir en arrière
        visitees.remove((x, y))
        return False
    
    # Position de départ
    position_depart = (0, 0)
    
    # Ensemble des cases visitées
    cases_visitees = set()
    
    # Lancer la recherche de la sortie
    explorer_labyrinthe(labyrinthe, position_depart[0], position_depart[1], cases_visitees)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Explication de l'Algorithme</h3>
            <ol>
                <li><strong>Exploration des Chemins :</strong> L’algorithme commence à la position de départ (S). Il essaie de se déplacer dans les quatre directions possibles (bas, haut, gauche, droite) et appelle récursivement la fonction pour chaque nouvelle position.</li>
                <li><strong>Conditions de Validité :</strong> Si la position est en dehors des limites du labyrinthe, ou si la case est un mur (1), ou si elle a déjà été visitée, le programme ne continue pas dans cette direction.</li>
                <li><strong>Si la sortie est atteinte :</strong> Si l’algorithme arrive sur la case de la sortie (E), il arrête l’exploration et affiche un message.</li>
                <li><strong>Backtracking (Retour en arrière) :</strong> Si l’algorithme ne trouve pas de solution dans une direction, il revient en arrière (backtrack), annule son choix (retire la case visitée de la liste des cases visitées), et essaie une autre direction.</li>
            </ol>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Prolongements et Extensions</h3>
            <ul>
                <li><strong>Ajouter des éléments dans le labyrinthe :</strong> Les élèves peuvent ajouter des pièges ou des portes fermées qui nécessitent de trouver une clé pour progresser. Modification du labyrinthe pour le rendre plus grand ou plus complexe.</li>
                <li><strong>Limiter le nombre de déplacements :</strong> Proposer une version du jeu où le joueur a un nombre limité de mouvements pour sortir du labyrinthe, ou il échoue.</li>
                <li><strong>Ajouter un deuxième joueur :</strong> Introduire un mode compétition où deux joueurs doivent trouver la sortie, le premier qui trouve la sortie gagne. On peut utiliser le backtracking pour gérer l'IA du second joueur.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion</h3>
            <p>À la fin de cette séance :</p>
            <ul>
                <li>Les élèves auront appris ce qu’est le backtracking, comment il permet d’explorer toutes les solutions possibles à un problème, et pourquoi il est efficace pour les labyrinthes.</li>
                <li>Ils auront implémenté une solution complète pour trouver la sortie d’un labyrinthe en utilisant ce concept.</li>
            </ul>
            <p><strong>Discussion :</strong> Applications pratiques du backtracking dans d’autres problèmes informatiques (ex. : sudoku, puzzles, algorithmes de parcours de graphes, optimisation combinatoire).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exercices Complémentaires :</h3>
            <ul>
                <li><strong>Explorer un plus grand labyrinthe :</strong> Créer un labyrinthe aléatoire de taille 10x10 ou plus grand, et tester l’efficacité du backtracking.</li>
                <li><strong>Ajouter des contraintes :</strong> Imposer des chemins où certaines cases ne peuvent être empruntées qu'une seule fois.</li>
            </ul>
        </section>

        <section id="session8" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 8 : Pratique - Résolution d'un Labyrinthe avec Backtracking (Jeu Vidéo)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves vont apprendre à utiliser l’algorithme de backtracking pour résoudre un labyrinthe. Cet algorithme permet de trouver une sortie dans un environnement en revenant en arrière lorsque le chemin pris est bloqué.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte du Jeu Vidéo :</h3>
            <p>Dans ce jeu, un personnage est perdu dans un labyrinthe représenté sous la forme d'une grille. Le joueur doit trouver un chemin entre le point de départ S (Start) et le point d’arrivée E (End). Certains chemins sont bloqués par des murs, représentés par des 1, et seuls les chemins libres (0) peuvent être empruntés.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Introduction au Problème</h4>
            <p><strong>Expliquer le problème du labyrinthe :</strong></p>
            <p>Le personnage doit trouver la sortie d’un labyrinthe représenté par une grille où certains chemins sont bloqués par des murs.</p>
        
            <p><strong>Représentation du labyrinthe :</strong></p>
            <ul>
                <li>S représente le point de départ.</li>
                <li>E représente le point de sortie.</li>
                <li>1 représente un mur (infranchissable).</li>
                <li>0 représente un chemin libre.</li>
            </ul>
        
            <p><strong>Exemple de labyrinthe simple :</strong></p>
            <pre><code>
    labyrinthe = [    
        ['S', 1, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0]
    ]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">2. Qu'est-ce que le Backtracking ?</h4>
            <p>L’algorithme de backtracking est une méthode récursive qui essaie de trouver une solution à un problème en avançant étape par étape. Si un chemin s’avère incorrect, l’algorithme revient en arrière (backtrack) et essaie un autre chemin.</p>
        
            <p><strong>Explication du principe :</strong></p>
            <ul>
                <li>Le personnage commence au point de départ.</li>
                <li>Il explore les chemins dans toutes les directions (haut, bas, gauche, droite).</li>
                <li>Si le chemin mène à un mur ou à une impasse, il revient à la position précédente et essaie une autre direction.</li>
                <li>Ce processus continue jusqu’à ce qu’il trouve la sortie ou qu’il n’y ait plus de chemin possible.</li>
            </ul>
        
            <p><strong>Application au labyrinthe :</strong></p>
            <p>L'algorithme va explorer tous les chemins possibles et revenir en arrière si un chemin ne mène pas à la sortie. Cela permet de tester toutes les solutions possibles pour trouver celle qui fonctionne.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">3. Algorithme de Backtracking pour Résoudre le Labyrinthe</h4>
            <p>L'algorithme de backtracking est généralement implémenté de manière récursive. Voici un exemple d'algorithme en pseudo-code :</p>
        
            <pre><code>
    explorer_labyrinthe(labyrinthe, x, y, visitees):
    Si (x, y) est hors du labyrinthe ou un mur ou déjà visité :
        Retourner False
                
    Si (x, y) est la sortie :
        Retourner True (la sortie est trouvée)
    
    Marquer (x, y) comme visité
                
    Explorer les 4 directions (haut, bas, gauche, droite) :
        Si l’une des directions mène à la sortie :
            Retourner True
    
    Si aucune direction ne fonctionne :
        Retourner False (chemin bloqué)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">4. Implémentation en Python</h4>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Représenter le Labyrinthe</h5>
            <p>Le labyrinthe sera représenté par une matrice (liste de listes en Python). 0 représente un chemin ouvert, 1 représente un mur, S représente la position de départ, et E la sortie.</p>
        
            <pre><code>
    labyrinthe = [
        ['S', 1, 0, 0, 1],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0]
    ]
            </code></pre>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Fonction de Backtracking</h5>
            <pre><code>
    def explorer_labyrinthe(labyrinthe, x, y, visitees):
        # Vérifier les limites du labyrinthe
        if x < 0 or x >= len(labyrinthe) or y < 0 or y >= len(labyrinthe[0]):
            return False
    
        # Vérifier si la case est un mur ou déjà visitée
        if labyrinthe[x][y] == 1 or (x, y) in visitees:
            return False
    
        # Si on a trouvé la sortie
        if labyrinthe[x][y] == 'E':
            print(f"Sortie trouvée à la position ({x}, {y})")
            return True
    
        # Marquer la case comme visitée
        visitees.add((x, y))
    
        # Appeler la fonction récursive dans les 4 directions
        if (explorer_labyrinthe(labyrinthe, x + 1, y, visitees) or  # Bas
            explorer_labyrinthe(labyrinthe, x - 1, y, visitees) or  # Haut
            explorer_labyrinthe(labyrinthe, x, y + 1, visitees) or  # Droite
            explorer_labyrinthe(labyrinthe, x, y - 1, visitees)):   # Gauche
            return True
    
        # Si aucune direction ne fonctionne, on retourne False (backtrack)
        return False
            </code></pre>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Tester l'Algorithme avec un Labyrinthe</h5>
            <pre><code>
    # Position de départ
    position_depart = (0, 0)
    
    # Ensemble des cases visitées
    cases_visitees = set()
    
    # Lancer la recherche de la sortie
    if not explorer_labyrinthe(labyrinthe, position_depart[0], position_depart[1], cases_visitees):
        print("Aucun chemin trouvé pour sortir du labyrinthe.")
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">5. Ajout d'une Interface Graphique Simple</h4>
            <p>Pour rendre l'algorithme plus interactif, nous allons ajouter une interface graphique simple avec Pygame pour visualiser le personnage se déplaçant dans le labyrinthe.</p>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Installer Pygame</h5>
            <p>Installer Pygame avec la commande :</p>
            <pre><code>
    pip install pygame
            </code></pre>
        
            <h5 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Visualisation du Labyrinthe</h5>
            <pre><code>
    import pygame

    # Dimensions de la fenêtre
    TAILLE_BLOC = 40
    LARGEUR = len(labyrinthe[0]) * TAILLE_BLOC
    HAUTEUR = len(labyrinthe) * TAILLE_BLOC
    
    # Couleurs
    COULEUR_MUR = (0, 0, 0)
    COULEUR_CHEMIN = (255, 255, 255)
    COULEUR_JOUEUR = (0, 255, 0)
    COULEUR_SORTIE = (255, 0, 0)
    
    # Initialiser Pygame
    pygame.init()
    fenetre = pygame.display.set_mode((LARGEUR, HAUTEUR))
    pygame.display.set_caption("Labyrinthe")
    
    def dessiner_labyrinthe(labyrinthe, position_joueur):
        fenetre.fill(COULEUR_CHEMIN)
        for i in range(len(labyrinthe)):
            for j in range(len(labyrinthe[0])):
                x = j * TAILLE_BLOC
                y = i * TAILLE_BLOC
                if labyrinthe[i][j] == 1:
                    pygame.draw.rect(fenetre, COULEUR_MUR, (x, y, TAILLE_BLOC, TAILLE_BLOC))
                elif labyrinthe[i][j] == 'E':
                    pygame.draw.rect(fenetre, COULEUR_SORTIE, (x, y, TAILLE_BLOC, TAILLE_BLOC))
        # Dessiner le joueur
        joueur_x, joueur_y = position_joueur
        pygame.draw.rect(fenetre, COULEUR_JOUEUR, (joueur_y * TAILLE_BLOC, joueur_x * TAILLE_BLOC, TAILLE_BLOC, TAILLE_BLOC))
    
    # Position initiale du joueur
    position_joueur = (0, 0)
    
    # Boucle du jeu
    continuer = True
    while continuer:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                continuer = False
    
        dessiner_labyrinthe(labyrinthe, position_joueur)
        pygame.display.flip()
    
    pygame.quit()
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">6. Challenge et Extension</h4>
            <ul>
                <li><strong>Challenge 1 :</strong> Limiter le nombre de déplacements - Limiter le nombre de mouvements que le joueur peut faire avant de trouver la sortie.</li>
                <li><strong>Challenge 2 :</strong> Génération aléatoire de labyrinthes - Modifier l’algorithme pour générer des labyrinthes aléatoires et les résoudre en utilisant le backtracking.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Réflexion</h3>
            <ul>
                <li>Les élèves auront appris à implémenter un algorithme de backtracking pour résoudre un labyrinthe de manière efficace.</li>
                <li>Ils auront vu comment appliquer cet algorithme à un jeu vidéo pour rendre la solution plus interactive.</li>
                <li>Discussion sur la récursivité et le backtracking : revenir en arrière dans l'exploration d'un problème permet de résoudre des situations complexes où plusieurs chemins sont possibles.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice Complémentaire :</h4>
            <p>Créer une intelligence artificielle pour explorer le labyrinthe automatiquement, ou modifier l’algorithme pour trouver tous les chemins possibles vers la sortie.</p>
        </section>

        <section id="session9" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 9 : Étude des Cas Où le Backtracking Est Utile et de Ses Limitations</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre le fonctionnement de l'algorithme de backtracking (retour en arrière), les cas où il est utile et ses limites en termes de complexité. Ils l'implémenteront dans le cadre d’un jeu vidéo où le joueur doit trouver un chemin dans un labyrinthe.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte :</h3>
            <p>Dans un jeu de labyrinthe, le joueur doit trouver une sortie à travers un labyrinthe complexe. L’algorithme de backtracking est utilisé pour explorer tous les chemins possibles jusqu’à ce que la sortie soit trouvée. Si un chemin mène à une impasse, l’algorithme revient en arrière (backtrack) et essaie un autre chemin.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Introduction au Problème du Labyrinthe</h4>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Scénario du Jeu Vidéo :</h4>
            <p>Le joueur se trouve à l'entrée d'un labyrinthe et doit trouver la sortie. Le labyrinthe est représenté sous forme de grille, où certaines cases sont des chemins possibles (0), et d'autres sont des murs (1). Le joueur peut se déplacer vers le haut, le bas, la gauche, ou la droite. Le but est de trouver un chemin de l'entrée à la sortie.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Structure du Labyrinthe :</h4>
            <pre><code>
    labyrinthe = [
        ['S', 0, 0, 1, 0],
        [1, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 1, 1, 1],
        [0, 0, 0, 0, 0]
    ]
            </code></pre>
            <ul>
                <li><strong>S</strong> représente le point de départ (Start).</li>
                <li><strong>E</strong> représente la sortie (End).</li>
                <li><strong>1</strong> représente un mur (impossible à traverser).</li>
                <li><strong>0</strong> représente un chemin possible.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Explication Théorique du Backtracking</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Concept du Backtracking :</h4>
            <p>Le backtracking est une technique algorithmique qui consiste à essayer toutes les solutions possibles jusqu’à ce que la bonne solution soit trouvée. Le principe est le suivant :</p>
            <ul>
                <li><strong>1. Choisir une option :</strong> On avance dans une direction (ou on prend une décision).</li>
                <li><strong>2. Tester la solution :</strong> Si cette direction (ou décision) mène à une impasse, on "revient en arrière" et on essaie une autre option.</li>
                <li><strong>3. Répéter :</strong> On continue ainsi jusqu’à ce que la solution soit trouvée ou qu'il n'y ait plus de possibilités à explorer.</li>
            </ul>
        
            <p>Dans le cas du labyrinthe :</p>
            <ul>
                <li>On commence à l’entrée du labyrinthe (<strong>S</strong>) et on essaie de se déplacer dans une direction (haut, bas, gauche, droite).</li>
                <li>Si le joueur rencontre un mur ou un chemin déjà exploré, il revient en arrière et essaie une autre direction.</li>
                <li>Le processus se répète jusqu'à ce que le joueur trouve la sortie (<strong>E</strong>).</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Pseudo-code du Backtracking :</h4>
            <pre><code>
    fonction résoudre_labyrinthe(labyrinthe, x, y):
    Si (x, y) est la sortie :
        Retourner vrai (le chemin est trouvé)
            
    Si (x, y) est un mur ou déjà visité :
        Retourner faux (impasse)
            
    Marquer (x, y) comme visité
            
    Tenter de se déplacer dans les 4 directions :
        Si résoudre_labyrinthe(labyrinthe, x + 1, y) retourne vrai :
            Retourner vrai (la direction est correcte)
        Si résoudre_labyrinthe(labyrinthe, x - 1, y) retourne vrai :
            Retourner vrai
        Si résoudre_labyrinthe(labyrinthe, x, y + 1) retourne vrai :
            Retourner vrai
        Si résoudre_labyrinthe(labyrinthe, x, y - 1) retourne vrai :
            Retourner vrai
            
    Si aucune direction ne mène à la sortie :
        Retourner en arrière (backtrack) et Retourner faux
            </code></pre>
        
            <p><strong>Idée Clé :</strong> Le backtracking consiste à tester chaque chemin possible et à revenir en arrière lorsqu'on atteint une impasse. Cela permet d'explorer tous les chemins possibles.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Mise en Pratique du Backtracking pour Résoudre un Labyrinthe</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Représenter le Labyrinthe en Python</h4>
            <p>Nous allons d’abord représenter notre labyrinthe sous forme de liste de listes (2D array), comme précédemment décrit. Chaque case contient soit un chemin possible (0), soit un mur (1), soit l’entrée (S) et la sortie (E).</p>
        
            <pre><code>
    labyrinthe = [
        ['S', 0, 0, 1, 0],
        [1, 1, 0, 1, 0],
        [0, 0, 0, 1, 'E'],
        [1, 1, 1, 1, 1],
        [0, 0, 0, 0, 0]
    ]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Implémenter l'Algorithme de Backtracking</h4>
            <p>L'algorithme va chercher le chemin à partir du point de départ (x, y) et essayer toutes les directions possibles (haut, bas, gauche, droite) jusqu’à ce qu’il atteigne la sortie (E).</p>
        
            <pre><code>
    # Fonction pour résoudre le labyrinthe
    def résoudre_labyrinthe(labyrinthe, x, y, visitees):
        # Vérifier si on est à la sortie
        if labyrinthe[x][y] == 'E':
            print(f"Sortie trouvée à la position ({x}, {y})")
            return True
                    
        # Vérifier les limites du labyrinthe
        if x < 0 or x >= len(labyrinthe) or y < 0 or y >= len(labyrinthe[0]):
            return False
                
        # Vérifier si la case est un mur ou déjà visitée
        if labyrinthe[x][y] == 1 or (x, y) in visitees:
            return False
                    
        # Marquer la case comme visitée
        visitees.add((x, y))
                
        # Appeler récursivement la fonction dans les 4 directions
        if (résoudre_labyrinthe(labyrinthe, x + 1, y, visitees) or  # Bas
            résoudre_labyrinthe(labyrinthe, x - 1, y, visitees) or  # Haut
            résoudre_labyrinthe(labyrinthe, x, y + 1, visitees) or  # Droite
            résoudre_labyrinthe(labyrinthe, x, y - 1, visitees)):   # Gauche
            return True
                    
        # Si aucune direction ne fonctionne, revenir en arrière
        return False
                
    # Initialisation
    visitees = set()  # Ensemble des cases déjà visitées
    résoudre_labyrinthe(labyrinthe, 0, 0, visitees)  # Commence à (0, 0)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Cas d'Utilisation du Backtracking</h3>
        
            <p><strong>Quand le Backtracking est-il utile ?</strong></p>
            <ul>
                <li><strong>1. Résolution de labyrinthes :</strong> comme dans notre exemple de jeu vidéo, où il y a plusieurs chemins possibles à explorer.</li>
                <li><strong>2. Jeux de puzzle :</strong> comme le Sudoku, où chaque choix possible doit être exploré avant de revenir en arrière si nécessaire.</li>
                <li><strong>3. Problèmes de recherche de combinaisons :</strong> trouver toutes les combinaisons possibles d’un ensemble (par exemple, dans un problème de sac à dos où plusieurs combinaisons doivent être explorées).</li>
                <li><strong>4. Coloration de graphes :</strong> assigner des couleurs à des nœuds d’un graphe tout en respectant certaines contraintes.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Limites du Backtracking :</h4>
            <ul>
                <li><strong>1. Complexité exponentielle :</strong> Le backtracking est souvent inefficace pour de très grands problèmes, car il peut nécessiter d'explorer un nombre exponentiel de solutions.</li>
                <li><strong>2. Exploration complète :</strong> Il n'y a pas de raccourci pour éviter d'explorer tous les chemins possibles, sauf si l’on combine le backtracking avec d'autres techniques comme la programmation dynamique ou l’élagage (pruning).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">5. Limites du Backtracking</h3>
        
            <p>Le backtracking peut devenir inefficace dans certaines situations, en particulier lorsque :</p>
            <ul>
                <li><strong>Trop de solutions possibles :</strong> Par exemple, dans un labyrinthe trop complexe avec de nombreuses impasses, le backtracking explorera chaque chemin, même s’il est inutile.</li>
                <li><strong>Complexité exponentielle :</strong> La recherche d'une solution peut prendre un temps très long lorsque le problème devient très grand, car le nombre de combinaisons possibles à tester augmente de façon exponentielle.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion</h3>
            <p>Les élèves auront appris :</p>
            <ul>
                <li>Comment utiliser le backtracking pour résoudre des problèmes tels que des labyrinthes dans des jeux vidéo.</li>
                <li>Pourquoi le backtracking est une méthode efficace pour explorer plusieurs solutions mais pourquoi il peut être limité pour les problèmes de grande envergure.</li>
                <li>Comprendre l'idée de retour en arrière : explorer, tester, revenir en arrière en cas d'impasse, et continuer à chercher jusqu’à la solution.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercices Complémentaires :</h4>
            <ul>
                <li><strong>Amélioration du labyrinthe :</strong> Ajouter plus d’éléments au labyrinthe (ennemis, objets à collecter, etc.).</li>
                <li><strong>Élagage (pruning) :</strong> Modifier l'algorithme pour éviter certains chemins déjà identifiés comme inutiles.</li>
            </ul>
        </section>

        <section id="session10" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 10 : Introduction à la Complexité Algorithmique – Notation Big-O</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <ul>
                <li>Comprendre le concept de complexité algorithmique.</li>
                <li>Apprendre à utiliser la notation Big-O.</li>
                <li>Appliquer la notation Big-O dans des situations concrètes à travers des exemples de jeux vidéo.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Contexte et Introduction</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Le Problème :</h4>
            <p>Dans le contexte d'un jeu vidéo, imaginons que le joueur doit interagir avec un certain nombre d’éléments à l’écran (monstres, objets, personnages). Ces éléments sont stockés dans une liste ou un tableau, et le joueur doit effectuer des actions comme :</p>
            <ul>
                <li>Trouver un monstre spécifique pour l’attaquer.</li>
                <li>Ramasser un objet spécifique.</li>
                <li>Parcourir tous les éléments pour effectuer une action (comme infliger des dégâts à tous les monstres).</li>
            </ul>
            <p>Pour rendre ces actions efficaces, il est crucial de comprendre combien de temps ou combien d'opérations l'algorithme prend pour effectuer la tâche, en fonction du nombre d’éléments. C'est là que la complexité algorithmique intervient.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Qu’est-ce que la Complexité Algorithmique ?</h4>
            <p>La complexité algorithmique mesure l'efficacité d'un algorithme en fonction de la taille de l'entrée (nombre d'éléments à traiter).</p>
            <p>Plutôt que de mesurer le temps en secondes, on mesure le nombre d’opérations que l’algorithme doit effectuer pour résoudre le problème.</p>
            <p><strong>Exemple simple :</strong> Si vous devez chercher un objet spécifique dans une liste, combien de comparaisons l'algorithme devra-t-il faire en fonction de la longueur de la liste ?</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Notation Big-O : Mesurer l’Efficacité des Algorithmes</h3>
            <p>La notation Big-O permet de classer les algorithmes selon le nombre d’opérations qu’ils effectuent en fonction de la taille de l’entrée (souvent notée n).</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Définitions des Complexités :</h4>
            <ul>
                <li><strong>O(1) : Complexité constante</strong> - L’algorithme prend le même temps, quel que soit le nombre d’éléments.
                    <br>Exemple : Accéder directement à un élément dans un tableau (par index), comme dans une liste de potions dans un inventaire.
                </li>
                <li><strong>O(n) : Complexité linéaire</strong> - Le nombre d’opérations augmente proportionnellement au nombre d’éléments.
                    <br>Exemple : Parcourir une liste d'objets pour trouver un objet spécifique dans un inventaire (recherche linéaire).
                </li>
                <li><strong>O(log n) : Complexité logarithmique</strong> - Le nombre d’opérations croît logarithmiquement avec le nombre d'éléments.
                    <br>Exemple : Recherche binaire dans une liste triée d’objets.
                </li>
                <li><strong>O(n²) : Complexité quadratique</strong> - Le nombre d'opérations est proportionnel au carré du nombre d'éléments.
                    <br>Exemple : Comparer chaque monstre à chaque autre monstre dans un jeu de combat (algorithme de tri par sélection).
                </li>
                <li><strong>O(n log n) : Complexité linéaro-logarithmique</strong> - Utilisée pour des algorithmes de tri efficaces comme le tri rapide (Quicksort).
                </li>
                <li><strong>O(2ⁿ) : Complexité exponentielle</strong> - Le nombre d'opérations double à chaque ajout d'élément. Très inefficace.
                    <br>Exemple : Problèmes avec des combinaisons ou la génération d'arbres de décisions très profonds.
                </li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Exemples Concrets avec des Jeux Vidéo</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple 1 : Recherche dans un Inventaire de Jeu Vidéo</h4>
            <p>Imaginons que le joueur possède un inventaire avec n objets (potions, épées, boucliers). Il doit trouver une potion spécifique.</p>
            <ul>
                <li><strong>O(n)</strong> (recherche linéaire) : Le joueur doit parcourir tous les objets de l’inventaire un par un, en comparant chaque objet avec la potion recherchée.</li>
                <li>Si l’inventaire contient 100 objets, il faudra au pire 100 opérations pour trouver la potion (ou ne pas la trouver).</li>
            </ul>
            <p><strong>Exercice pratique :</strong> Implémenter une recherche linéaire sur une liste d’objets de jeu.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple 2 : Attaque de Tous les Monstres</h4>
            <p>Dans un jeu de type RPG, le joueur a la capacité d'attaquer tous les monstres présents sur le terrain en une seule action. Si chaque attaque prend une unité de temps, le nombre d'opérations sera proportionnel au nombre de monstres.</p>
            <ul>
                <li><strong>O(n)</strong> : S’il y a 50 monstres sur le terrain, il faudra 50 attaques, soit 50 opérations.</li>
            </ul>
            <p><strong>Exercice pratique :</strong> Implémenter une boucle qui applique une attaque à chaque monstre dans une liste de 50 monstres.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple 3 : Recherche Binaire pour Trouver un Objet dans un Inventaire Trié</h4>
            <p>Dans un inventaire trié d’un jeu, le joueur peut utiliser la recherche binaire pour trouver un objet plus rapidement.</p>
            <ul>
                <li><strong>O(log n)</strong> : Si l’inventaire contient 100 objets, la recherche binaire permet de trouver un objet en 7 étapes au lieu de 100.</li>
                <li>Chaque étape divise la liste en deux, ce qui fait que l’algorithme est logarithmique.</li>
            </ul>
            <p><strong>Exercice pratique :</strong> Implémenter une recherche binaire dans une liste triée d'objets (similaire à la recherche du trésor vue en séance précédente).</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple 4 : Comparer Chaque Monstre avec Chaque Autre Monstre (Algorithme Quadratique)</h4>
            <p>Dans certains jeux, vous pourriez avoir un système où chaque monstre doit interagir avec tous les autres (par exemple, vérifier les collisions entre eux).</p>
            <ul>
                <li><strong>O(n²)</strong> : Si vous avez 10 monstres, vous devez comparer chaque monstre avec les 9 autres, soit 100 comparaisons.</li>
                <li>Si vous avez 100 monstres, cela fera 10 000 comparaisons (un algorithme quadratique).</li>
            </ul>
            <p><strong>Exercice pratique :</strong> Implémenter un algorithme de comparaison entre chaque paire de monstres dans un jeu.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Expérimentation et Simulation avec des Listes de Données</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Implémenter des Algorithmes Différents</h4>
            <p>Les élèves vont créer une liste d'objets de jeu (par exemple, 100 objets avec des noms aléatoires).</p>
            <ul>
                <li><strong>Exercice 1 :</strong> Recherche linéaire : Implémenter une recherche d’un objet spécifique dans cette liste.</li>
                <li><strong>Exercice 2 :</strong> Recherche binaire : Si la liste est triée, utiliser la recherche binaire pour trouver l’objet plus rapidement.</li>
                <li><strong>Exercice 3 :</strong> Comparaison de tous les éléments : Simuler un combat où chaque monstre est comparé avec tous les autres.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Mesurer et Comparer la Performance</h4>
            <p>Pour chaque exercice, les élèves devront :</p>
            <ul>
                <li>Mesurer le nombre d’opérations nécessaires.</li>
                <li>Comparer la performance des algorithmes en fonction de la taille de la liste (par exemple, en augmentant la taille de la liste de 100 à 1000).</li>
            </ul>
            <p><strong>Exercice pratique :</strong> Afficher le temps pris par chaque algorithme pour trouver un objet dans une liste d’objets. Demander aux élèves d’expliquer pourquoi certains algorithmes sont plus rapides que d'autres pour de grandes listes.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">5. Discussion sur la Notion de Limite et d’Optimisation</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">La Limite des Algorithmes Inefficaces :</h4>
            <p>Discuter avec les élèves sur le fait qu’un algorithme linéaire (<strong>O(n)</strong>) peut être acceptable pour un petit nombre d’éléments, mais qu'il devient trop lent pour un grand nombre.</p>
            <p>Par exemple, rechercher un objet dans une liste de 100 éléments avec <strong>O(n)</strong> peut être acceptable, mais dans une liste de 1 000 000 d’éléments, il faut optimiser avec un algorithme plus rapide (comme <strong>O(log n)</strong> ou <strong>O(1)</strong>).</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Optimiser dans les Jeux Vidéo :</h4>
            <p>Dans les jeux vidéo, optimiser les algorithmes est crucial pour maintenir la performance, surtout si le jeu implique des centaines d'ennemis, des interactions complexes, et des actions en temps réel.</p>
            <p>Par exemple, pour un jeu où des dizaines de monstres doivent être gérés, il est important d’utiliser des algorithmes efficaces pour éviter les ralentissements.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">6. Conclusion et Résumé</h3>
            <p><strong>Ce que les élèves ont appris :</strong></p>
            <ul>
                <li><strong>Complexité algorithmique :</strong> Comprendre comment mesurer l’efficacité d’un algorithme en fonction du nombre d’opérations qu’il effectue.</li>
                <li><strong>Notation Big-O :</strong> Apprendre à classer les algorithmes en fonction de leur performance.</li>
                <li><strong>Exemples concrets :</strong> Les élèves ont appliqué la notion de complexité algorithmique à des cas pratiques dans des jeux vidéo.</li>
                <li><strong>Comparaison des algorithmes :</strong> Voir comment différents algorithmes (<strong>O(n)</strong>, <strong>O(log n)</strong>, <strong>O(n²)</strong>) fonctionnent dans des situations réelles et pourquoi certains sont plus efficaces.</li>
            </ul>
        
            <p><strong>Exercices Complémentaires :</strong></p>
            <ul>
                <li>Étendre l’exercice sur <strong>O(n log n)</strong> : Implémenter un algorithme de tri rapide (Quicksort) et comparer ses performances avec un tri basique (tri par sélection <strong>O(n²)</strong>).</li>
                <li>Tester des algorithmes sur de très grandes listes : Demander aux élèves de simuler des listes contenant des millions d’éléments et de comparer la rapidité des algorithmes.</li>
            </ul>
        </section>

        <section id="session11" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 11 : Pratique - Comparaison des Algorithmes de Tri Simples (Insertion, Sélection)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront à implémenter et comparer les algorithmes de tri par insertion et par sélection, en utilisant une approche pratique. Ces concepts seront appliqués dans le contexte d'un jeu vidéo où il faut organiser les objets de l'inventaire d'un personnage pour optimiser le gameplay.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte du Jeu Vidéo :</h3>
            <p>Dans un jeu d’aventure, le joueur collecte de nombreux objets (armes, potions, armures) pendant son exploration. Ces objets sont initialement mélangés dans son inventaire. Le joueur doit organiser son inventaire, par exemple en triant les objets selon leur valeur ou leur poids.</p>
            <p>Problème initial : Le joueur a besoin d’un inventaire trié pour accéder rapidement à ses objets les plus précieux ou les plus utiles. Si l’inventaire est désorganisé, cela peut nuire à l’efficacité du jeu.</p>
            <p>Solution : Utiliser des algorithmes de tri pour organiser l'inventaire.</p>
            <p>Les élèves vont comparer deux algorithmes de tri simples :</p>
            <ol>
                <li>Tri par insertion (Insertion Sort).</li>
                <li>Tri par sélection (Selection Sort).</li>
            </ol>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Introduction aux Algorithmes de Tri</h3>
            <p>Avant de plonger dans la pratique, il est important de comprendre les deux algorithmes de tri et leurs mécanismes.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Tri par Insertion :</h4>
            <p>Le tri par insertion fonctionne comme si vous triiez une main de cartes :</p>
            <ul>
                <li>Vous prenez les cartes (ici des objets de l’inventaire) une par une et les insérez au bon endroit dans une liste déjà triée.</li>
                <li>À chaque itération, la portion triée de la liste s’agrandit.</li>
            </ul>
            <p><strong>Principe :</strong> On compare l’élément actuel avec les éléments précédents et on l’insère à la bonne position pour que la partie gauche de la liste soit triée.</p>
        
            <pre><code>
    def tri_insertion(liste):
        for i in range(1, len(liste)):
            element = liste[i]
            j = i - 1
            while j >= 0 and liste[j] > element:
                liste[j + 1] = liste[j]
                j -= 1
            liste[j + 1] = element
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Tri par Sélection :</h4>
            <p>Le tri par sélection fonctionne en trouvant l'élément le plus petit et en le plaçant au début de la liste. Ensuite, on cherche le deuxième plus petit, et ainsi de suite.</p>
            <p><strong>Principe :</strong> On sélectionne l'élément le plus petit dans la partie non triée de la liste, puis on le place au début. On répète le processus jusqu'à ce que la liste soit entièrement triée.</p>
        
            <pre><code>
    def tri_selection(liste):
        for i in range(len(liste)):
            min_index = i
            for j in range(i + 1, len(liste)):
                if liste[j] < liste[min_index]:
                    min_index = j
            liste[i], liste[min_index] = liste[min_index], liste[i]
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Application dans le Contexte du Jeu Vidéo</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Préparation de l’Inventaire</h4>
            <p>L’inventaire du personnage est représenté par une liste d’objets, chaque objet ayant une valeur et un poids. Pour simplifier, les élèves peuvent utiliser une liste de nombres représentant les valeurs des objets.</p>
            <pre><code>
    inventaire = [50, 10, 40, 30, 20, 60]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Implémentation du Tri par Insertion</h4>
            <p>Les élèves commenceront par implémenter le tri par insertion pour organiser les objets de l’inventaire en fonction de leur valeur.</p>
            <ul>
                <li>Rappeler le principe : Le joueur veut trier ses objets du moins précieux au plus précieux pour les retrouver facilement.</li>
                <li>Exercice pratique : Écrire la fonction <code>tri_insertion</code> pour trier l’inventaire.</li>
            </ul>
        
            <pre><code>
    def tri_insertion(liste):
        for i in range(1, len(liste)):
            element = liste[i]
            j = i - 1
            while j >= 0 and liste[j] > element:
                liste[j + 1] = liste[j]
                j -= 1
            liste[j + 1] = element
                
    # Exemple d'utilisation
    inventaire = [50, 10, 40, 30, 20, 60]
    print("Inventaire avant tri :", inventaire)
    tri_insertion(inventaire)
    print("Inventaire après tri par insertion :", inventaire)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Implémentation du Tri par Sélection</h4>
            <p>Les élèves passent ensuite à l'implémentation du tri par sélection pour organiser l’inventaire de manière alternative.</p>
            <ul>
                <li>Rappeler le principe : On cherche l'objet le moins précieux et on le place au début de l’inventaire, puis on répète le processus.</li>
                <li>Exercice pratique : Écrire la fonction <code>tri_selection</code>.</li>
            </ul>
        
            <pre><code>
    def tri_selection(liste):
        for i in range(len(liste)):
            min_index = i
            for j in range(i + 1, len(liste)):
                if liste[j] < liste[min_index]:
                    min_index = j
            liste[i], liste[min_index] = liste[min_index], liste[i]
                
    # Exemple d'utilisation
    inventaire = [50, 10, 40, 30, 20, 60]
    print("Inventaire avant tri :", inventaire)
    tri_selection(inventaire)
    print("Inventaire après tri par sélection :", inventaire)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Comparaison des Algorithmes</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 4 : Comparaison sur la Base des Performances</h4>
            <p>Demander aux élèves de comparer les deux algorithmes de tri en termes de :</p>
            <ul>
                <li>Vitesse (nombre de comparaisons) : Combien de comparaisons sont faites dans chaque algorithme ?</li>
                <li>Tri par insertion : Bon pour des listes presque triées.</li>
                <li>Tri par sélection : Meilleur pour des listes complètement désordonnées.</li>
                <li>Simplicité d’implémentation : Lequel est plus simple à comprendre et à écrire ?</li>
                <li>Complexité temporelle :
                    <ul>
                        <li><strong>Insertion sort :</strong> O(n^2) dans le pire des cas.</li>
                        <li><strong>Selection sort :</strong> O(n^2) dans tous les cas.</li>
                    </ul>
                </li>
            </ul>
            <p>Demander aux élèves d’essayer ces algorithmes sur différentes tailles de listes (par exemple, 10, 100, 1000 éléments) et de mesurer le temps que chaque algorithme prend pour terminer le tri. Voici un code simple pour chronométrer :</p>
        
            <pre><code>
    import time
        
    # Exemple pour le tri par insertion
    start_time = time.time()
    tri_insertion(inventaire)
    end_time = time.time()
    print("Temps pris par le tri par insertion :", end_time - start_time)
                
    # Faire de même pour le tri par sélection
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Extension et Discussion</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 5 : Extension - Trier par Poids</h4>
            <p>Ajouter une nouvelle caractéristique aux objets de l’inventaire : le poids. Demander aux élèves de modifier leur code pour trier les objets non plus par valeur, mais par poids.</p>
        
            <pre><code>
    inventaire_avec_poids = [
        {"nom": "épée", "valeur": 50, "poids": 5},
        {"nom": "potion", "valeur": 10, "poids": 1},
        {"nom": "armure", "valeur": 40, "poids": 15},
        {"nom": "bouclier", "valeur": 30, "poids": 8},
        {"nom": "arc", "valeur": 20, "poids": 3},
        {"nom": "flèches", "valeur": 60, "poids": 0.5}
    ]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 6 : Discussion Finale</h4>
            <ul>
                <li><strong>Avantages et inconvénients de chaque algorithme :</strong></li>
                <li>Le tri par insertion est plus rapide pour les petites listes ou les listes presque triées.</li>
                <li>Le tri par sélection est simple à comprendre, mais peu efficace pour les grandes listes.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Objectif Atteint</h3>
            <ul>
                <li>Implémenter les algorithmes de tri par insertion et tri par sélection.</li>
                <li>Comparer leurs performances sur des listes de différentes tailles.</li>
                <li>Appliquer ces concepts à un contexte ludique avec l’organisation d’un inventaire dans un jeu vidéo.</li>
                <li>Comprendre les forces et faiblesses de chaque méthode de tri.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice Complémentaire :</h4>
            <p>Tri d'une liste de dictionnaires : Demander aux élèves de trier une liste de dictionnaires (objets du jeu) non seulement par valeur ou poids, mais aussi par d’autres critères comme la rareté.</p>
        </section>

        <section id="session12" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 12 : Exercices d’Analyse de la Complexité des Algorithmes dans des Jeux Vidéo et la Vie Réelle</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre et analyser la complexité temporelle des algorithmes à travers des exemples concrets tirés de jeux vidéo et de la vie réelle. Ils apprendront à évaluer l’efficacité d’un algorithme en fonction de la taille des données sur lesquelles il opère et à utiliser la notation Big-O.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction à la Complexité Algorithmique</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Qu’est-ce que la Complexité Algorithmique ?</h4>
            <p>Lorsqu’on écrit un programme ou un algorithme, il est important de se demander "combien de temps prend l’algorithme pour s'exécuter" en fonction de la taille des données à traiter.</p>
            <p>La complexité algorithmique est une manière de mesurer et comparer l’efficacité de différents algorithmes en fonction du nombre d’opérations qu’ils effectuent.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">2. La Notation Big-O</h4>
            <p>La notation Big-O est une manière de représenter la croissance du temps d’exécution d’un algorithme en fonction de la taille des données (n).</p>
            <p><strong>Quelques exemples courants :</strong></p>
            <ul>
                <li><strong>O(1)</strong> : Temps constant. L'algorithme prend toujours le même temps, quelle que soit la taille des données.</li>
                <li><strong>O(n)</strong> : Temps linéaire. Le temps de l'algorithme augmente proportionnellement à la taille des données.</li>
                <li><strong>O(log n)</strong> : Temps logarithmique. Le temps de l'algorithme augmente lentement à mesure que les données augmentent.</li>
                <li><strong>O(n²)</strong> : Temps quadratique. Le temps augmente rapidement à mesure que la taille des données augmente (ex. : tri par sélection).</li>
                <li><strong>O(2ⁿ)</strong> : Temps exponentiel. Très inefficace pour de grandes quantités de données.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">3. Exemple de la Recherche dans un Jeu Vidéo</h4>
            <p>Dans un jeu vidéo de type open-world (monde ouvert), imaginons que le joueur cherche un objet caché. L’algorithme peut utiliser différents types de recherche pour aider le joueur à trouver cet objet.</p>
            <ul>
                <li><strong>Recherche linéaire (O(n)) :</strong> Si le joueur explore toutes les sections de la carte une par une, cela prendra du temps proportionnel à la taille de la carte. Si la carte contient 100 sections, il devra en moyenne en parcourir 50 avant de trouver l'objet.</li>
                <li><strong>Recherche binaire (O(log n)) :</strong> Si l'algorithme divise la carte en deux parties à chaque étape (comme vu lors de la recherche binaire), la recherche sera bien plus rapide. Pour 100 sections, il suffit de 7 étapes pour trouver l’objet.</li>
                <li><strong>Recherche dans un graphe (DFS/BFS) (O(n)) :</strong> Si le jeu est un labyrinthe ou un réseau complexe de chemins, les algorithmes de parcours de graphes peuvent être utilisés pour trouver l'objet.</li>
            </ul>
        
            <pre><code>
    # Pseudo-code pour la recherche linéaire :
    def recherche_lineaire(liste, cible):
        for i in range(len(liste)):
            if liste[i] == cible:
                return i
        return -1
                
    # Recherche binaire (comme vu dans une séance précédente) :
    def recherche_binaire(liste, debut, fin, cible):
        if debut > fin:
            return -1
        milieu = (debut + fin) // 2
        if liste[milieu] == cible:
            return milieu
        elif liste[milieu] < cible:
            return recherche_binaire(liste, milieu + 1, fin, cible)
        else:
            return recherche_binaire(liste, debut, milieu - 1, cible)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exercice Pratique 1 : Comparaison des Algorithmes de Recherche</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Scénario dans le Jeu Vidéo :</h4>
            <p>Dans un monde ouvert, un monstre doit suivre le joueur. Le monstre doit déterminer où se trouve le joueur sur une carte divisée en sections numérotées de 1 à 1000.</p>
            <ul>
                <li>Recherche linéaire : Le monstre vérifie chaque section une par une.</li>
                <li>Recherche binaire : Le monstre divise la carte en deux à chaque étape.</li>
            </ul>
            <p><strong>Objectif :</strong> Implémenter les deux algorithmes et comparer le nombre d’étapes nécessaires pour que le monstre trouve le joueur.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étapes :</h4>
            <ol>
                <li>Implémenter la recherche linéaire et la recherche binaire.</li>
                <li>Effectuer des tests avec différentes tailles de carte (ex. : 100, 500, 1000 sections).</li>
                <li>Comparer le nombre d'étapes nécessaires pour trouver le joueur à chaque fois.</li>
            </ol>
        
            <pre><code>
    # Code pour la Recherche Linéaire et Binaire :
    import random
                
    # Simulation d'une carte avec 1000 sections
    sections = list(range(1, 1001))
    # Le joueur se trouve dans une section aléatoire
    joueur = random.choice(sections)
                
    # Recherche linéaire
    def recherche_lineaire(liste, cible):
        etapes = 0
        for i in range(len(liste)):
            etapes += 1
            if liste[i] == cible:
                return i, etapes
        return -1, etapes
                
    # Recherche binaire
    def recherche_binaire(liste, debut, fin, cible, etapes=0):
        if debut > fin:
            return -1, etapes
        milieu = (debut + fin) // 2
        etapes += 1
        if liste[milieu] == cible:
            return milieu, etapes
        elif liste[milieu] < cible:
            return recherche_binaire(liste, milieu + 1, fin, cible, etapes)
        else:
            return recherche_binaire(liste, debut, milieu - 1, cible, etapes)
                
    # Comparaison des algorithmes
    lin_result, lin_etapes = recherche_lineaire(sections, joueur)
    bin_result, bin_etapes = recherche_binaire(sections, 0, len(sections) - 1, joueur)
                
    print(f"Recherche linéaire : trouvé en {lin_etapes} étapes")
    print(f"Recherche binaire : trouvé en {bin_etapes} étapes")
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Analyse des Résultats :</h3>
            <ul>
                <li><strong>Recherche linéaire :</strong> Plus la carte est grande, plus le monstre doit effectuer d'étapes pour trouver le joueur. La recherche linéaire est donc proportionnelle à la taille de la carte.</li>
                <li><strong>Recherche binaire :</strong> Le nombre d'étapes est beaucoup plus faible, car l'algorithme divise la carte en deux à chaque étape.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exercice Pratique 2 : Algorithmes de Tri dans les Jeux Vidéo</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Scénario dans le Jeu Vidéo :</h4>
            <p>Dans un inventaire de jeu vidéo, les objets doivent être triés par valeur ou par poids. L'algorithme de tri utilisé impacte la vitesse avec laquelle le joueur peut afficher son inventaire trié.</p>
            <ul>
                <li><strong>Tri par sélection (O(n²)) :</strong> Un tri basique mais lent.</li>
                <li><strong>Tri rapide (Quicksort, O(n log n)) :</strong> Un tri plus rapide utilisé dans les systèmes de gestion d'inventaire modernes.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Implémenter le Tri par Sélection</h4>
            <pre><code>
    def tri_selection(liste):
        n = len(liste)
        for i in range(n):
            min_idx = i
            for j in range(i+1, n):
                if liste[j] < liste[min_idx]:
                    min_idx = j
            liste[i], liste[min_idx] = liste[min_idx], liste[i]
        return liste
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Implémenter le Tri Rapide (Quicksort)</h4>
            <pre><code>
    def tri_rapide(liste):
        if len(liste) <= 1:
            return liste
        pivot = liste[0]
        inferieur = [x for x in liste[1:] if x <= pivot]
        superieur = [x for x in liste[1:] if x > pivot]
        return tri_rapide(inferieur) + [pivot] + tri_rapide(superieur)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Comparer les Deux Algorithmes de Tri</h4>
            <p>Les élèves doivent comparer les performances des deux algorithmes sur des listes d’inventaires de tailles différentes (10, 100, 1000 objets). Ils analyseront combien de temps chaque tri prend pour s'exécuter.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Discussion et Conclusion</h3>
            <p><strong>Complexité des Algorithmes :</strong> Pourquoi certains algorithmes sont-ils plus lents que d'autres ?</p>
            <p><strong>Big-O et l’importance de la taille des données :</strong> Discuter de la manière dont la taille des données influe sur les performances d'un algorithme.</p>
            <p><strong>Jeux Vidéo et Algorithmes :</strong> Comment des concepts théoriques comme la complexité algorithmique impactent directement des expériences de jeu.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Extensions possibles :</h4>
            <ul>
                <li>Analyser la complexité spatiale (mémoire utilisée) en plus de la complexité temporelle.</li>
                <li>Étudier d'autres algorithmes utilisés dans les jeux vidéo, comme les algorithmes d'IA pour le comportement des ennemis ou la génération procédurale de niveaux.</li>
            </ul>
        </section>

        <section id="session13" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 13 : Introduction aux Graphes et à leurs Applications</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre la notion de graphe en informatique, comment il est représenté et ses différentes applications pratiques, y compris dans le domaine des jeux vidéo. Ils apprendront les concepts de sommets, arêtes, parcours, et utiliseront des graphes pour résoudre des problèmes concrets, comme la navigation dans un jeu vidéo.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Graphes</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Qu’est-ce qu’un graphe ?</h4>
            <p>Un graphe est une structure de données composée :</p>
            <ul>
                <li><strong>De sommets (ou nœuds) :</strong> ce sont les points d’un graphe, souvent utilisés pour représenter des objets, des lieux, ou des états.</li>
                <li><strong>D’arêtes (ou arcs) :</strong> ce sont les lignes qui relient les sommets entre eux, représentant des relations ou des chemins entre ces objets.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Applications des graphes :</h4>
            <ul>
                <li><strong>Jeux vidéo :</strong> Représentation de mondes ou cartes de jeu (les sommets représentent les lieux, les arêtes représentent les chemins entre eux).</li>
                <li><strong>Réseaux sociaux :</strong> Chaque utilisateur est un sommet, et les relations entre eux (amis) sont des arêtes.</li>
                <li><strong>Navigation GPS :</strong> Les intersections (sommets) sont reliées par des routes (arêtes) pour trouver le chemin optimal.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Représentation d’un Graphe :</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Représentation par une matrice d’adjacence :</h4>
            <p>Une matrice carrée où les lignes et colonnes représentent les sommets. Si deux sommets sont connectés, la case correspondante contient une valeur (1 pour les non pondérés, un poids pour les pondérés).</p>
        
            <pre><code>
      |  A  |  B  |  C  |
       ------------------
    A |  0  |  1  |  0  |
    B |  1  |  0  |  1  |
    C |  0  |  1  |  0  |
            </code></pre>
            <p>Ici, A et B sont connectés, et B et C sont connectés.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">2. Représentation par liste d’adjacence :</h4>
            <p>Chaque sommet a une liste de sommets voisins. Cette représentation est plus économe en mémoire pour les graphes peu denses.</p>
        
            <pre><code>
    graphe = {
        'A': ['B'],
        'B': ['A', 'C'],
        'C': ['B']
    }
            </code></pre>
            <p>A est connecté à B, et B est connecté à C.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exemple Ludique : Utilisation des Graphes dans un Jeu Vidéo</h3>
            <p>Dans un jeu vidéo, vous êtes un personnage qui doit se déplacer d'un point A à un point B à travers un réseau de chemins connectant différents lieux. Le monde du jeu peut être représenté sous forme de graphe où :</p>
            <ul>
                <li><strong>Les sommets</strong> représentent des lieux (villes, salles dans un donjon, etc.).</li>
                <li><strong>Les arêtes</strong> représentent des chemins (routes, portes entre les salles, etc.).</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple de Graphe dans le Jeu :</h4>
            <pre><code>
    A ----- B ----- C
    |       |       |
    D ----- E ----- F
            </code></pre>
            <p>Chaque lettre représente une pièce (un sommet). Chaque trait représente un chemin entre deux pièces (une arête).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Types de Graphes</h3>
            <ul>
                <li><strong>Graphe non orienté :</strong> Les arêtes n'ont pas de direction. On peut aller dans les deux sens entre deux sommets.</li>
                <li><strong>Graphe orienté :</strong> Les arêtes ont une direction. On ne peut aller que dans un sens d’un sommet à un autre.</li>
                <li><strong>Graphe pondéré :</strong> Chaque arête a un poids (un coût), qui peut représenter la distance, le temps ou le coût énergétique pour se déplacer d’un sommet à un autre.</li>
                <li><strong>Graphe connexe :</strong> Il est possible d’atteindre n’importe quel sommet à partir de n’importe quel autre sommet.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique : Représentation d'un Monde de Jeu Vidéo avec un Graphe</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Créer un Graphe Représentant un Monde de Jeu</h4>
            <pre><code>
    graphe_donjon = {
        'A': ['B', 'D'],
        'B': ['A', 'C', 'E'],
        'C': ['B', 'F'],
        'D': ['A', 'E'],
        'E': ['B', 'D', 'F'],
        'F': ['C', 'E']
    }
            </code></pre>
            <p>Ici, chaque clé représente une pièce, et les valeurs sont les pièces connectées par une porte.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Représenter le Monde et les Connexions</h4>
            <p>Visualisez ce graphe dans le contexte d’un jeu :</p>
            <ul>
                <li><strong>Les sommets :</strong> Chaque lettre (A, B, C, etc.) représente une salle du donjon.</li>
                <li><strong>Les arêtes :</strong> Les portes qui relient les salles entre elles.</li>
            </ul>
            <p>Demandez aux élèves de dessiner ce graphe sur papier ou sur un tableau pour mieux le visualiser.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Définir des Chemins dans le Graphe</h4>
            <p>Le joueur commence dans la salle A et veut se rendre dans la salle F. L’objectif est de parcourir le graphe et de trouver un chemin du point A au point F en suivant les arêtes du graphe.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Parcours de Graphe : Introduction à la Recherche de Chemin</h3>
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Parcours en largeur (BFS - Breadth First Search) :</h4>
            <p>Utilisé pour trouver le plus court chemin dans un graphe non pondéré. Il explore tous les voisins d’un sommet avant de passer à la couche suivante.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">2. Parcours en profondeur (DFS - Depth First Search) :</h4>
            <p>Utile pour explorer toutes les branches d’un graphe. Il explore aussi loin que possible dans une branche avant de revenir en arrière.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique : Parcours en Largeur (BFS)</h3>
            <pre><code>
    from collections import deque
        
    def bfs(graphe, depart, objectif):
        file_attente = deque([depart])
        visites = set()
        
        while file_attente:
            sommet = file_attente.popleft()
            if sommet == objectif:
                print(f"Vous avez trouvé le chemin vers {objectif} depuis {depart} !")
                return
            if sommet not in visites:
                print(f"Vous explorez la pièce {sommet}")
                visites.add(sommet)
                file_attente.extend(graphe[sommet])
        print(f"Pas de chemin trouvé de {depart} à {objectif}.")
    
    # Appel de la fonction
    bfs(graphe_donjon, 'A', 'F')
            </code></pre>
            <p>Ce programme parcourt le donjon en utilisant une approche BFS (parcours en largeur) pour explorer les pièces adjacentes et trouver le chemin de la pièce A à la pièce F.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Application et Conclusion</h3>
            <p>Réflexion sur les Applications des Graphes :</p>
            <ul>
                <li><strong>Jeux vidéo :</strong> Les graphes sont utiles pour gérer les déplacements des personnages, que ce soit pour les joueurs ou pour les ennemis.</li>
                <li><strong>Navigation :</strong> Les GPS utilisent des graphes pondérés pour calculer les meilleurs itinéraires entre deux lieux.</li>
                <li><strong>Réseaux sociaux :</strong> Les graphes sont utilisés pour représenter les connexions entre utilisateurs (sommets) et leurs relations (arêtes).</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Challenge Supplémentaire (pour les élèves avancés) :</h4>
            <p>Ajoutez des poids aux arêtes pour représenter le coût (distance, énergie) du déplacement entre les salles, puis utilisez l’algorithme de Dijkstra pour trouver le chemin le plus court entre deux salles.</p>
            <p>Amélioration du jeu : Implémentez une fonction qui permet au joueur de trouver automatiquement le chemin le plus court pour s’échapper du donjon en évitant certains pièges.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectifs de la Séance :</h3>
            <ul>
                <li>Comprendre les concepts de base des graphes (sommets, arêtes, connexions).</li>
                <li>Savoir représenter un monde de jeu vidéo sous forme de graphe.</li>
                <li>Utiliser un algorithme de parcours de graphe pour résoudre un problème de navigation dans un jeu.</li>
                <li>Bonus : Introduction à l’application des graphes dans des domaines plus vastes (réseaux sociaux, GPS).</li>
            </ul>
        </section>

        <section id="session14" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 14 : Pratique - Représentation d'un Réseau de Routes dans un Jeu Vidéo avec des Graphes</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif de la Séance :</h3>
            <p>Les élèves vont apprendre à modéliser un réseau de routes dans un jeu vidéo en utilisant des graphes. Ils vont comprendre comment utiliser un graphe pour représenter des routes entre différentes villes et comment ces structures peuvent être utilisées pour trouver les chemins les plus courts dans un jeu vidéo de type simulation de transport.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte du Jeu Vidéo</h3>
            <p>Imaginez un jeu de simulation où le joueur doit gérer le réseau de transport d’un royaume. Le royaume est constitué de plusieurs villes reliées entre elles par des routes. Chaque ville est un nœud (ou sommet) du réseau, et chaque route entre deux villes est une arête (ou arc) dans le graphe.</p>
            <p><strong>Objectif du joueur :</strong> Le joueur doit transporter des marchandises d'une ville à l'autre en optimisant le trajet pour gagner du temps et des ressources. Il devra donc utiliser un algorithme de parcours de graphe pour trouver le chemin le plus court entre deux villes.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Graphes</h3>
            <p><strong>Qu’est-ce qu’un Graphe ?</strong></p>
            <p>Un graphe est une structure mathématique utilisée pour modéliser des relations entre des objets. Il est composé de :</p>
            <ul>
                <li><strong>Nœuds (ou sommets)</strong> : Ici, chaque nœud représente une ville.</li>
                <li><strong>Arêtes (ou arcs)</strong> : Ce sont les routes qui relient les villes entre elles.</li>
            </ul>
            <p><strong>Types de graphes :</strong></p>
            <ul>
                <li><strong>Graphes non orientés :</strong> Les arêtes n'ont pas de direction, comme une route bidirectionnelle entre deux villes.</li>
                <li><strong>Graphes orientés :</strong> Les arêtes ont une direction, comme une autoroute à sens unique entre deux villes.</li>
            </ul>
            <p>Dans notre exemple de jeu vidéo, nous utiliserons un graphe non orienté pour modéliser les routes, où chaque route est bidirectionnelle.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Représentation d’un Graphe en Python</h3>
            <p>Il existe plusieurs manières de représenter un graphe dans un programme :</p>
            <ul>
                <li><strong>Matrice d’adjacence :</strong> Une matrice où chaque élément (i, j) est 1 si une route existe entre les villes i et j, sinon 0.</li>
                <li><strong>Liste d’adjacence :</strong> Un dictionnaire où chaque ville est associée à une liste de villes adjacentes reliées par une route.</li>
            </ul>
            <p>Pour cette séance, nous allons utiliser une liste d’adjacence car elle est plus intuitive et plus efficace pour représenter des graphes avec peu de connexions.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 1 : Créer le Réseau de Routes avec une Liste d’Adjacence</h3>
            <p><strong>Exemple :</strong></p>
            <p>Supposons que nous avons cinq villes dans le royaume : A, B, C, D, et E. Les routes sont les suivantes :</p>
            <ul>
                <li>Route entre A et B.</li>
                <li>Route entre A et C.</li>
                <li>Route entre B et D.</li>
                <li>Route entre C et D.</li>
                <li>Route entre D et E.</li>
            </ul>
            <pre><code>
    # Représentation du réseau de routes avec une liste d'adjacence
    routes = {
        'A': ['B', 'C'],
        'B': ['A', 'D'],
        'C': ['A', 'D'],
        'D': ['B', 'C', 'E'],
        'E': ['D']
    }
            </code></pre>
            <p><strong>Explication :</strong></p>
            <ul>
                <li>La ville A est reliée aux villes B et C.</li>
                <li>La ville B est reliée aux villes A et D, etc.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 2 : Parcourir le Graphe – Algorithme DFS et BFS</h3>
            <p><strong>Pourquoi parcourir un graphe ?</strong></p>
            <p>Dans un jeu vidéo, le joueur peut vouloir savoir le chemin le plus court entre deux villes ou simplement vérifier si une ville est atteignable depuis une autre. Pour cela, on utilise des algorithmes de parcours de graphe, comme DFS (Depth First Search) ou BFS (Breadth First Search).</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Implémentation de DFS :</h4>
            <pre><code>
    # Fonction DFS pour parcourir le graphe
    def dfs(graphe, ville, visitees):
        print(f"Visite de {ville}")
        visitees.add(ville)  # Marquer la ville comme visitée
        
        # Explorer les voisins
        for voisin in graphe[ville]:
            if voisin not in visitees:
                dfs(graphe, voisin, visitees)
    
    # Appel de DFS à partir de la ville A
    visitees = set()
    dfs(routes, 'A', visitees)
            </code></pre>
            <p><strong>Explication de DFS :</strong></p>
            <ul>
                <li><strong>Départ :</strong> On commence par la ville A, puis on visite tous les voisins de A qui n’ont pas encore été visités (ici B et C).</li>
                <li><strong>Récursivité :</strong> L’algorithme appelle récursivement DFS sur chaque voisin jusqu’à ce que toutes les villes connectées soient visitées.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Implémentation de BFS :</h4>
            <pre><code>
    from collections import deque

    # Fonction BFS pour parcourir le graphe
    def bfs(graphe, ville_depart):
        file = deque([ville_depart])
        visitees = set([ville_depart])
        
        while file:
            ville = file.popleft()
            print(f"Visite de {ville}")
            
            # Parcourir les voisins
            for voisin in graphe[ville]:
                if voisin not in visitees:
                    file.append(voisin)
                    visitees.add(voisin)
    
    # Appel de BFS à partir de la ville A
    bfs(routes, 'A')
            </code></pre>
            <p><strong>Explication de BFS :</strong></p>
            <ul>
                <li>On commence par visiter la ville A, puis on ajoute ses voisins dans une file (ou file d’attente) pour les visiter à leur tour.</li>
                <li>Le parcours se fait par niveaux : on visite d’abord les voisins immédiats (ici B et C), puis les voisins des voisins.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 3 : Application au Jeu Vidéo – Trouver le Chemin le Plus Court</h3>
            <p><strong>Objectif :</strong></p>
            <p>Dans le jeu, le joueur doit transporter des marchandises entre deux villes et doit trouver le chemin le plus court. Pour cela, nous allons utiliser BFS car il est bien adapté pour trouver les chemins les plus courts dans les graphes non pondérés.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Ajout de la Fonction de Recherche du Chemin le Plus Court :</h4>
            <pre><code>
    def bfs_chemin_court(graphe, ville_depart, ville_arrivee):
        file = deque([[ville_depart]])  # File qui contient les chemins explorés
        visitees = set([ville_depart])
                    
        while file:
            chemin = file.popleft()
            ville = chemin[-1]
            
            # Si on arrive à la ville cible, on renvoie le chemin emprunté
            if ville == ville_arrivee:
                return chemin
            
            # Parcourir les voisins
            for voisin in graphe[ville]:
                if voisin not in visitees:
                    nouveau_chemin = list(chemin)  # Copier le chemin actuel
                    nouveau_chemin.append(voisin)  # Ajouter le voisin au chemin
                    file.append(nouveau_chemin)
                    visitees.add(voisin)
        
        return None  # Retourner None si aucun chemin n'est trouvé
    
    # Trouver le chemin le plus court entre A et E
    chemin = bfs_chemin_court(routes, 'A', 'E')
    print(f"Le chemin le plus court est : {chemin}")
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 4 : Extensions et Améliorations</h3>
            <ul>
                <li><strong>Pondération des routes :</strong> Ajouter des poids aux routes (distance ou temps de trajet) pour utiliser des algorithmes plus avancés comme Dijkstra pour trouver le chemin le plus court dans un graphe pondéré.</li>
                <li><strong>Modéliser plus de villes :</strong> Ajouter davantage de villes et routes dans le réseau de transport.</li>
                <li><strong>Gestion des trajets multiples :</strong> Permettre au joueur de planifier plusieurs trajets entre différentes villes.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion</h3>
            <ul>
                <li>Modéliser un réseau de routes avec un graphe en utilisant une liste d’adjacence.</li>
                <li>Implémenter des algorithmes de parcours (DFS et BFS) pour explorer un réseau de villes.</li>
                <li>Utiliser BFS pour trouver le chemin le plus court dans un graphe non pondéré, et comprendre comment cela s'applique aux jeux vidéo.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice Complémentaire :</h4>
            <p>Si certains élèves avancent plus rapidement, ils peuvent travailler sur un réseau de routes plus complexe et implémenter un algorithme plus avancé comme Dijkstra pour trouver le chemin le plus rapide en fonction du temps de trajet sur chaque route.</p>
        </section>

        <section id="session15" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 15 : Algorithmes de Parcours de Graphes – DFS et BFS</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre et implémenter deux algorithmes fondamentaux de parcours de graphes : DFS (Depth-First Search) et BFS (Breadth-First Search). Ils apprendront à les utiliser dans le cadre d’un jeu vidéo où un personnage doit explorer un réseau de niveaux ou un labyrinthe.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Graphes et Parcours</h3>
            <h4>Le Contexte du Jeu Vidéo :</h4>
            <p>Dans un jeu vidéo d’aventure, un personnage doit naviguer à travers un labyrinthe ou un réseau de niveaux pour atteindre la sortie ou accomplir une mission. Chaque niveau est représenté comme un graphe, où :</p>
            <ul>
                <li>Chaque nœud du graphe représente une salle ou un point d’intérêt dans le labyrinthe.</li>
                <li>Chaque arête entre deux nœuds représente un chemin que le personnage peut emprunter.</li>
            </ul>
            <p>Le joueur doit explorer le labyrinthe pour trouver la sortie ou un trésor. Pour rendre cette exploration efficace, nous allons utiliser deux algorithmes de parcours de graphes : DFS (parcours en profondeur) et BFS (parcours en largeur).</p>
        
            <h4>Définition de Base d’un Graphe :</h4>
            <ul>
                <li><strong>Nœuds (ou sommets) :</strong> chaque nœud représente un point, comme une salle dans un labyrinthe ou un niveau dans un jeu.</li>
                <li><strong>Arêtes :</strong> les connexions entre les nœuds, qui représentent des chemins.</li>
            </ul>
            <p>Dans notre jeu, nous pouvons modéliser un labyrinthe ou un réseau de niveaux sous forme de graphe.</p>
        
            <h4>Exemple Visuel :</h4>
            <pre><code>
    1 --- 2 --- 3
    |     |     |
    4 --- 5 --- 6
            </code></pre>
            <p>Chaque numéro (1, 2, 3, etc.) représente une salle du labyrinthe.</p>
            <p>Chaque trait (--- ou |) représente un chemin que le personnage peut emprunter pour aller d'une salle à l'autre.</p>
            <p>Nous allons voir comment le personnage peut explorer ce labyrinthe en utilisant les algorithmes DFS et BFS pour parcourir le graphe.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Algorithme DFS (Depth-First Search) – Parcours en Profondeur</h3>
            <h4>1. Principe de DFS :</h4>
            <p>Le parcours en profondeur consiste à explorer le plus loin possible dans une direction avant de revenir en arrière. Cela signifie que l’algorithme suit un chemin jusqu’à ce qu’il n’y ait plus d’arêtes à suivre, puis il revient en arrière pour explorer d’autres chemins.</p>
        
            <p>DFS fonctionne de manière récursive, en suivant un chemin jusqu’à atteindre un nœud sans issue (feuille), puis en revenant pour explorer les autres chemins.</p>
        
            <h4>Exemple Visuel avec DFS :</h4>
            <p>Dans notre labyrinthe ci-dessus, un parcours DFS à partir du nœud 1 pourrait suivre cette séquence : 1 → 2 → 3 → 6 → 5 → 4 (exploration la plus profonde possible avant de revenir).</p>
        
            <h4>Pseudo-code de DFS :</h4>
            <pre><code>
    def dfs(graphe, noeud, visites):
        if noeud not in visites:
            print(f"Visite du nœud {noeud}")
            visites.add(noeud)  # Marquer le nœud comme visité
            for voisin dans graphe[noeud]:  # Explorer tous les voisins non visités
                dfs(graphe, voisin, visites)
            </code></pre>
        
            <h4>Explication Étape par Étape :</h4>
            <ul>
                <li><strong>Initialisation :</strong> On commence au premier nœud (par exemple, la salle de départ).</li>
                <li><strong>Exploration :</strong> On explore un des voisins non visités, puis on continue à explorer les voisins des voisins.</li>
                <li><strong>Retour en arrière :</strong> Si un nœud n’a plus de voisins non visités, on revient en arrière pour explorer les autres chemins.</li>
            </ul>
        
            <h4>Implémentation DFS dans le Contexte du Jeu (Exemple en Python) :</h4>
            <pre><code>
    graphe = {
        1: [2, 4],
        2: [1, 3, 5],
        3: [2, 6],
        4: [1, 5],
        5: [2, 4, 6],
        6: [3, 5]
    }
    
    def dfs(graphe, noeud, visites):
        if noeud not in visites:
            print(f"Visite de la salle {noeud}")
            visites.add(noeud)
            for voisin dans graphe[noeud]:
                dfs(graphe, voisin, visites)
    
    # Initialiser un ensemble de nœuds visités
    visites = set()
    
    # Lancer le parcours DFS à partir de la salle 1
    dfs(graphe, 1, visites)
            </code></pre>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez le graphe pour que certaines salles contiennent des trésors.</li>
                <li><strong>Étape 2 :</strong> Implémentez un DFS pour que le joueur explore toutes les salles et affiche si un trésor est trouvé dans une salle.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Algorithme BFS (Breadth-First Search) – Parcours en Largeur</h3>
            <h4>1. Principe de BFS :</h4>
            <p>Le parcours en largeur consiste à explorer tous les voisins d’un nœud avant de passer aux voisins des voisins.</p>
            <p>BFS fonctionne en utilisant une file d’attente (queue) pour gérer les nœuds à explorer. À chaque étape, on explore tous les nœuds voisins du nœud actuel avant de passer aux nœuds de niveau supérieur.</p>
        
            <h4>Exemple Visuel avec BFS :</h4>
            <p>Dans le labyrinthe, un parcours BFS à partir du nœud 1 pourrait suivre cette séquence : 1 → 2 → 4 → 3 → 5 → 6 (exploration niveau par niveau).</p>
        
            <h4>Pseudo-code de BFS :</h4>
            <pre><code>
    from collections import deque

    def bfs(graphe, noeud):
        visites = set()  # Ensemble des nœuds visités
        queue = deque([noeud])  # File d'attente pour gérer les nœuds à explorer
        
        while queue:
            courant = queue.popleft()  # Récupérer le nœud à explorer
            if courant not in visites:
                print(f"Visite du nœud {courant}")
                visites.add(courant)  # Marquer comme visité
                for voisin dans graphe[courant]:
                    if voisin not in visites:
                        queue.append(voisin)  # Ajouter les voisins à la file d'attente
            </code></pre>
        
            <h4>Explication Étape par Étape :</h4>
            <ul>
                <li><strong>Initialisation :</strong> On commence au premier nœud (la salle de départ).</li>
                <li><strong>Exploration des voisins :</strong> On explore tous les voisins directs du nœud actuel.</li>
                <li><strong>Nœuds de niveau supérieur :</strong> Une fois les voisins directs explorés, on passe aux voisins des voisins, et ainsi de suite, jusqu’à ce que tous les nœuds soient visités.</li>
            </ul>
        
            <h4>Implémentation BFS dans le Contexte du Jeu (Exemple en Python) :</h4>
            <pre><code>
    from collections import deque
        
    graphe = {
        1: [2, 4],
        2: [1, 3, 5],
        3: [2, 6],
        4: [1, 5],
        5: [2, 4, 6],
        6: [3, 5]
    }
                
    def bfs(graphe, noeud):
        visites = set()  # Ensemble des nœuds visités
        queue = deque([noeud])  # File d'attente
        
        while queue:
            courant = queue.popleft()
            if courant not in visites:
                print(f"Visite de la salle {courant}")
                visites.add(courant)
                for voisin dans graphe[courant]:
                    if voisin not in visites:
                        queue.append(voisin)
    
    # Lancer le parcours BFS à partir de la salle 1
    bfs(graphe, 1)
            </code></pre>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Implémentez un système où le personnage doit explorer toutes les salles du labyrinthe à l'aide du parcours en largeur.</li>
                <li><strong>Étape 2 :</strong> Ajoutez un obstacle dans certaines salles et modifiez le BFS pour que le personnage ignore les salles avec des obstacles.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Comparaison des Algorithmes</h3>
        
            <h4>Comparaison DFS vs BFS :</h4>
            <ul>
                <li><strong>DFS (Depth-First Search) :</strong> L'algorithme explore profondément dans un chemin avant de revenir en arrière. Il est utile pour explorer des labyrinthes où l’on veut atteindre des chemins très éloignés. DFS utilise souvent la récursivité.</li>
                <li><strong>BFS (Breadth-First Search) :</strong> L'algorithme explore tous les voisins directs avant de passer aux nœuds suivants. Il est très efficace pour trouver le chemin le plus court dans un graphe. BFS utilise une file d’attente.</li>
            </ul>
        
            <h4>Complexité Temporelle :</h4>
            <p>Les deux algorithmes ont une complexité en temps de <code>O(V + E)</code>, où <code>V</code> est le nombre de nœuds (salles) et <code>E</code> est le nombre d’arêtes (chemins).</p>
        
            <h4>Discussion :</h4>
            <ul>
                <li>DFS est particulièrement utile pour les problèmes de parcours de labyrinthe où il est important d’explorer un chemin complet avant de revenir en arrière.</li>
                <li>BFS est idéal pour trouver des chemins plus courts ou explorer des environnements "niveau par niveau", comme dans un jeu où l’on veut explorer toutes les salles d'un étage avant de monter à l'étage supérieur.</li>
            </ul>
        </section>

        <section id="session16" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 16 : Approfondissement sur l’algorithme DFS (Depth-First Search)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves approfondiront leur compréhension de l’algorithme DFS (Depth-First Search) en explorant ses différentes applications, en particulier dans les graphes, dans un contexte de jeu vidéo où le joueur doit explorer un réseau complexe de salles interconnectées. L'objectif est de renforcer leur capacité à appliquer la récursivité dans la recherche en profondeur.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction à DFS dans un Contexte de Jeu Vidéo</h3>
        
            <h4>Contexte du Jeu Vidéo :</h4>
            <p>Imaginons un jeu d’aventure où le joueur incarne un explorateur qui doit naviguer à travers un réseau complexe de grottes interconnectées. Chaque grotte est une salle, et chaque connexion entre deux salles représente un chemin possible. L’objectif est de visiter toutes les grottes pour trouver un artefact caché. L’algorithme DFS est un moyen efficace pour parcourir toutes les salles en suivant un chemin en profondeur avant de revenir en arrière.</p>
        
            <h4>Concept de DFS :</h4>
            <p>DFS (Depth-First Search) est un algorithme qui explore un graphe en allant aussi loin que possible dans une direction avant de revenir en arrière pour explorer les autres chemins. C’est un algorithme récursif qui suit une stratégie de <strong>diviser pour régner</strong>, en explorant un chemin complet jusqu’à ce qu’il ne puisse plus avancer.</p>
        
            <h4>Représentation en Graphe :</h4>
            <p>Dans ce jeu vidéo, chaque salle est un nœud du graphe, et chaque connexion entre deux salles est une arête. Voici un exemple de graphe représentant un réseau de grottes :</p>
        
            <pre><code>
    1 --- 2 --- 3
    |     |     |
    4 --- 5 --- 6
            </code></pre>
        
            <p>Dans cet exemple, le joueur commence à la salle 1 et doit visiter toutes les autres salles en utilisant l’algorithme DFS pour explorer les salles dans un ordre efficace.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Explication de l’Algorithme DFS (30 min)</h3>
            <h4>1. Fonctionnement de DFS :</h4>
            <p>DFS utilise une approche récursive pour explorer les nœuds d’un graphe :</p>
            <ul>
                <li>On commence par un nœud initial (par exemple, la salle de départ).</li>
                <li>On explore un des voisins de ce nœud.</li>
                <li>À chaque fois qu’un nœud est visité, on le marque comme visité pour éviter de le revisiter.</li>
                <li>Si tous les voisins d’un nœud sont visités, l’algorithme revient en arrière et explore les autres chemins restants.</li>
            </ul>
        
            <h4>2. Récursivité dans DFS :</h4>
            <p>DFS est naturellement récursif. Chaque appel de fonction DFS explore un chemin jusqu’à ce qu’il n’y ait plus de voisins à visiter. L'algorithme revient ensuite à la fonction appelante pour explorer d’autres chemins.</p>
        
            <p>Le pseudo-code de DFS est le suivant :</p>
            <pre><code>
    def dfs(graphe, noeud, visites):
        if noeud not in visites:
            print(f"Visite de la salle {noeud}")
            visites.add(noeud)  # Marquer la salle comme visitée
            for voisin dans graphe[noeud]:  # Explorer les voisins non visités
                dfs(graphe, voisin, visites)
            </code></pre>
        
            <h4>3. Exemple Visuel :</h4>
            <p>Partant du nœud 1, DFS visitera les salles dans l’ordre suivant (dans ce cas particulier) :</p>
            <pre><code>
    1 → 2 → 3 → 6 → 5 → 4
            </code></pre>
            <p>DFS explore en profondeur jusqu’à la salle 6 avant de revenir en arrière pour explorer les autres chemins.</p>
        
            <h4>4. Cas d’Utilisation :</h4>
            <p>DFS est particulièrement utile lorsque l’on veut explorer un graphe complet ou lorsqu’on veut trouver un chemin à travers un labyrinthe, où les chemins peuvent être très profonds avant d’atteindre une solution.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation DFS dans un Contexte de Jeu Vidéo (40 min)</h3>
            
            <h4>1. Représentation du Graphe en Python :</h4>
            <p>Le graphe est représenté en Python sous la forme d’un dictionnaire, où chaque clé représente une salle, et la valeur associée est une liste de salles adjacentes (les voisins).</p>
        
            <pre><code>
    graphe = {
        1: [2, 4],
        2: [1, 3, 5],
        3: [2, 6],
        4: [1, 5],
        5: [2, 4, 6],
        6: [3, 5]
    }
            </code></pre>
        
            <h4>2. Implémentation de DFS en Python :</h4>
            <p>Voici une implémentation simple de l'algorithme DFS pour explorer les salles d’un réseau de grottes :</p>
        
            <pre><code>
    def dfs(graphe, noeud, visites):
        if noeud not in visites:
            print(f"Visite de la salle {noeud}")
            visites.add(noeud)  # Marquer la salle comme visitée
            for voisin dans graphe[noeud]:  # Explorer les voisins non visités
                dfs(graphe, voisin, visites)
    
    # Ensemble des nœuds visités
    visites = set()
    
    # Démarrer le parcours DFS à partir de la salle 1
    dfs(graphe, 1, visites)
            </code></pre>
        
            <h4>3. Explication du Code :</h4>
            <ul>
                <li>La fonction <code>dfs()</code> est appelée avec trois arguments : le graphe, le nœud actuel (la salle où le joueur se trouve), et l’ensemble des salles déjà visitées.</li>
                <li>Si la salle n’a pas encore été visitée, elle est marquée comme visitée et l'algorithme explore tous ses voisins de manière récursive.</li>
                <li>Une fois que tous les voisins ont été explorés, l’algorithme revient en arrière et continue avec les autres chemins possibles.</li>
            </ul>
        
            <h4>Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez le graphe pour ajouter des objets ou des trésors dans certaines salles.</li>
                <li><strong>Étape 2 :</strong> Implémentez une version de DFS qui affiche un message lorsque le joueur trouve un trésor dans une salle.</li>
                <li><strong>Étape 3 :</strong> Ajoutez une fonctionnalité qui limite le nombre de visites dans une salle, comme un nombre maximum de tentatives avant que le joueur échoue.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Comparaison (10 min)</h3>
            <p>À la fin de cette séance, les élèves auront approfondi leur compréhension de l’algorithme DFS et auront appris à l’appliquer dans un contexte de jeu vidéo, en modélisant un labyrinthe ou un réseau de salles. Ils auront également renforcé leurs compétences en <strong>récursivité</strong>, en suivant un chemin en profondeur et en revenant en arrière pour explorer d’autres chemins.</p>
        
            <p>Enfin, nous comparerons DFS avec d’autres algorithmes de parcours comme BFS, en soulignant que DFS est particulièrement efficace dans des contextes où les chemins sont profonds, tandis que BFS est souvent préféré pour trouver les chemins les plus courts.</p>
        </section>

        <section id="session17" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 17 : Pratique - Exploration d’un Monde Ouvert (Jeu Vidéo) avec DFS</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Dans cette séance pratique, les élèves appliqueront l’algorithme DFS (Depth-First Search) pour permettre à un personnage d’explorer un monde ouvert dans un jeu vidéo. L’objectif est de simuler une exploration où le personnage doit visiter différents lieux en profondeur, en suivant des chemins prédéfinis avant de revenir en arrière et explorer d’autres zones.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte de l'Exploration d’un Monde Ouvert dans un Jeu Vidéo</h3>
            
            <h4>1. Le Monde Ouvert :</h4>
            <p>Un <strong>monde ouvert</strong> dans un jeu vidéo est un environnement vaste et interconnecté où le joueur peut se déplacer librement entre différentes zones (comme des villes, des forêts, des montagnes, etc.). Chaque zone est modélisée comme un nœud d’un graphe, et les connexions entre ces zones sont représentées par des chemins.</p>
        
            <p>Dans cette simulation, nous allons modéliser le monde ouvert comme un graphe et utiliser DFS pour simuler l’exploration de ce monde.</p>
        
            <h4>2. Objectif de l’Exploration :</h4>
            <p>Le joueur contrôle un personnage qui doit explorer toutes les zones du monde ouvert. L’objectif est de visiter chaque zone au moins une fois, tout en cherchant des trésors cachés ou des objets dans certaines zones.</p>
        
            <p>Par exemple :</p>
            <ul>
                <li>Le joueur peut commencer dans la <strong>ville principale</strong> (nœud 1).</li>
                <li>Le joueur doit explorer des lieux comme des <strong>forêts</strong>, des <strong>cavernes</strong> ou des <strong>montagnes</strong> interconnectées.</li>
            </ul>
        
            <p>DFS est idéal dans ce contexte, car il explore profondément dans une direction avant de revenir pour visiter d’autres zones.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 1 : Représentation du Monde Ouvert avec un Graphe (30 min)</h3>
            
            <h4>1. Définition du Monde Ouvert sous forme de Graphe :</h4>
            <p>Chaque zone du jeu est représentée comme un nœud du graphe, et les chemins entre les zones sont les arêtes du graphe. Voici un exemple de structure de graphe pour un monde ouvert :</p>
        
            <pre><code>
    Ville Principale --- Forêt --- Caverne
    |                    |        |
    Montagne --- Plage    Lac     Temple
            </code></pre>
        
            <p>Dans ce graphe, le joueur peut explorer des lieux différents en passant par des chemins qui relient les zones. L’algorithme DFS permet de déterminer l’ordre dans lequel ces zones seront explorées.</p>
        
            <h4>2. Représentation en Python :</h4>
            <p>Nous pouvons modéliser ce monde ouvert comme un dictionnaire en Python, où chaque zone est un nœud, et la liste de ses voisins contient les zones adjacentes :</p>
        
            <pre><code>
    monde_ouvert = {
        'Ville Principale': ['Forêt', 'Montagne'],
        'Forêt': ['Ville Principale', 'Caverne', 'Lac'],
        'Caverne': ['Forêt', 'Temple'],
        'Montagne': ['Ville Principale', 'Plage'],
        'Plage': ['Montagne'],
        'Lac': ['Forêt'],
        'Temple': ['Caverne']
    }
            </code></pre>
        
            <h4>3. Objectifs du joueur :</h4>
            <ul>
                <li>Explorer toutes les zones du monde ouvert.</li>
                <li>Trouver des objets ou trésors cachés dans certaines zones.</li>
                <li>Explorer le monde de manière exhaustive en suivant un parcours en profondeur (DFS).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 2 : Implémentation de DFS pour l’Exploration (40 min)</h3>
        
            <h4>1. Implémentation de DFS en Python pour Explorer le Monde Ouvert :</h4>
            <p>Nous allons implémenter DFS pour que le personnage explore chaque zone une par une, en suivant un parcours en profondeur. Voici comment cela peut être fait en Python :</p>
        
            <pre><code>
    def explorer_monde(monde, zone, visites):
        if zone not in visites:
            print(f"Vous explorez {zone}")
            visites.add(zone)  # Marquer la zone comme visitée
            for voisin in monde[zone]:  # Explorer les zones voisines non visitées
                explorer_monde(monde, voisin, visites)
        
    # Ensemble des zones visitées
    zones_visitees = set()
    
    # Lancer l'exploration à partir de la Ville Principale
    explorer_monde(monde_ouvert, 'Ville Principale', zones_visitees)
            </code></pre>
        
            <h4>2. Explication du Code :</h4>
            <ul>
                <li>La fonction <code>explorer_monde()</code> est appelée avec trois arguments : le monde ouvert (le graphe), la zone actuelle, et l’ensemble des zones déjà visitées.</li>
                <li>Si la zone n’a pas encore été visitée, elle est marquée comme visitée, et l’algorithme explore récursivement tous ses voisins (autres zones connectées).</li>
                <li>DFS explore d’abord les zones en profondeur avant de revenir en arrière pour explorer d’autres chemins.</li>
            </ul>
        
            <h4>3. Simulation de l’Exploration :</h4>
            <p>Lorsque vous exécutez le code ci-dessus, le personnage explorera toutes les zones du monde ouvert dans un ordre déterminé par DFS. Par exemple :</p>
            <pre><code>
    Vous explorez Ville Principale
    Vous explorez Forêt
    Vous explorez Caverne
    Vous explorez Temple
    Vous explorez Lac
    Vous explorez Montagne
    Vous explorez Plage
            </code></pre>
            <p>DFS commence à la "Ville Principale", puis explore en profondeur la "Forêt", la "Caverne", et le "Temple" avant de revenir pour explorer d’autres zones.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 3 : Défis Pratiques pour les Élèves (30 min)</h3>
            
            <h4>1. Ajout d’Objets Cachés :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez le monde ouvert pour que certaines zones contiennent des objets ou des trésors cachés.</li>
                <li><strong>Étape 2 :</strong> Modifiez le code pour que l'algorithme affiche un message lorsqu'un objet ou trésor est trouvé dans une zone spécifique.</li>
            </ul>
        
            <h4>2. Limitation du Temps d’Exploration :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Ajoutez une contrainte de temps ou un nombre maximum d'explorations que le joueur peut effectuer avant que le temps ne s’écoule.</li>
                <li><strong>Étape 2 :</strong> Implémentez cette limite dans le code. Si le joueur dépasse la limite, un message s’affiche pour indiquer que l’exploration est terminée.</li>
            </ul>
        
            <h4>3. Exploration Sélective :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Créez un système où certaines zones du monde ouvert sont bloquées jusqu'à ce que le joueur trouve une clé ou un objet spécial dans une autre zone.</li>
                <li><strong>Étape 2 :</strong> Modifiez l'algorithme pour permettre au joueur d'explorer uniquement après avoir trouvé cet objet.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Réflexion sur DFS dans les Jeux Vidéo (10 min)</h3>
        
            <h4>Analyse de DFS dans un Monde Ouvert :</h4>
            <p>DFS est une méthode efficace pour explorer des mondes ouverts en profondeur, permettant au joueur de suivre des chemins jusqu’à ce qu’il atteigne une impasse ou un objectif. Une fois qu’un chemin est épuisé, l’algorithme revient en arrière pour explorer d’autres options.</p>
        
            <h4>Avantages et Inconvénients :</h4>
            <ul>
                <li><strong>Avantage :</strong> DFS est excellent pour explorer les mondes où l’objectif est situé à une grande profondeur (par exemple, dans une grotte éloignée ou dans un temple caché).</li>
                <li><strong>Inconvénient :</strong> DFS peut parfois suivre un chemin non optimal avant de revenir en arrière pour explorer d’autres options.</li>
            </ul>
        
            <h4>Discussion :</h4>
            <ul>
                <li>Comparez DFS avec d’autres algorithmes d’exploration, comme BFS (Breadth-First Search), pour discuter des avantages et inconvénients dans des mondes ouverts.</li>
                <li>Comment pourriez-vous modifier cet algorithme pour permettre une exploration plus "intelligente" dans un monde ouvert ? Par exemple, ajouter une stratégie d’évitement des zones dangereuses ou moins intéressantes.</li>
            </ul>
        </section>

        <section id="session18" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 18 : Applications Réelles des Graphes (Réseaux Sociaux, Chemins dans les Transports)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Dans cette séance, les élèves vont découvrir des applications concrètes de l’utilisation des graphes dans des domaines comme les réseaux sociaux et les systèmes de transport. Ils apprendront à modéliser des situations réelles sous forme de graphes, puis à appliquer des algorithmes de parcours pour résoudre des problèmes spécifiques. Le but est de renforcer la compréhension des graphes à travers des cas pratiques.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Graphes dans le Monde Réel</h3>
            <h4>1. Qu’est-ce qu’un Graphe ?</h4>
            <p>Un graphe est une structure composée de :</p>
            <ul>
                <li><strong>Nœuds (ou sommets) :</strong> représentant des entités (personnes, lieux, stations de transport).</li>
                <li><strong>Arêtes :</strong> les connexions entre les nœuds, représentant des relations (amitié dans les réseaux sociaux, lignes de métro dans un réseau de transport).</li>
            </ul>
            <p>Dans les applications réelles, les graphes peuvent modéliser une grande variété de systèmes complexes.</p>
        
            <h4>2. Applications Réelles des Graphes :</h4>
            <ul>
                <li><strong>Réseaux sociaux :</strong> Les utilisateurs sont les nœuds, et les connexions (amitié, abonnements) sont les arêtes. DFS et BFS peuvent être utilisés pour explorer des groupes d’amis ou des recommandations.</li>
                <li><strong>Réseaux de transport :</strong> Les stations ou arrêts sont des nœuds, et les lignes de transport (bus, métro) sont des arêtes. Les algorithmes de recherche permettent de trouver le chemin le plus court entre deux stations.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étude de Cas 1 : Réseaux Sociaux (40 min)</h3>
            
            <h4>1. Modélisation des Réseaux Sociaux :</h4>
            <p>Dans un réseau social, chaque utilisateur est un **nœud** et chaque relation (amitié, abonnement) est une **arête**. Les graphes permettent de modéliser ces connexions pour résoudre des problèmes comme :</p>
            <ul>
                <li><strong>Explorer des groupes d’amis :</strong> Utilisation de DFS ou BFS pour parcourir un réseau d'amis et suggérer de nouvelles connexions.</li>
                <li><strong>Recommandations :</strong> Utilisation d'algorithmes pour trouver les amis d'amis et recommander de nouveaux contacts.</li>
            </ul>
        
            <h4>2. Exemple Visuel d'un Réseau Social :</h4>
            <pre><code>
    Personne 1 --- Personne 2 --- Personne 3
       |               |               |
    Personne 4 --- Personne 5 --- Personne 6
            </code></pre>
            <p>Chaque personne est représentée comme un nœud, et les liens d’amitié comme des arêtes. L’algorithme peut explorer les connexions d’une personne pour proposer des recommandations.</p>
        
            <h4>3. Algorithme DFS pour Explorer les Amis :</h4>
            <p>On peut utiliser l’algorithme DFS pour explorer les groupes d’amis de manière récursive, à partir d’une personne donnée :</p>
        
            <pre><code>
    def explorer_reseau(graphe, personne, visites):
        if personne not in visites:
            print(f"Exploration de l’ami {personne}")
            visites.add(personne)
            for ami dans graphe[personne]:
                explorer_reseau(graphe, ami, visites)
            </code></pre>
        
            <p>Ce code permet d'explorer tous les amis directs et indirects d'une personne dans le réseau social.</p>
        
            <h4>4. Exemple d'Implémentation en Python :</h4>
            <pre><code>
    reseau_social = {
        "Personne 1": ["Personne 2", "Personne 4"],
        "Personne 2": ["Personne 1", "Personne 3", "Personne 5"],
        "Personne 3": ["Personne 2", "Personne 6"],
        "Personne 4": ["Personne 1", "Personne 5"],
        "Personne 5": ["Personne 2", "Personne 4", "Personne 6"],
        "Personne 6": ["Personne 3", "Personne 5"]
    }
    
    # Ensemble des personnes déjà visitées
    visites = set()
    
    # Lancer l'exploration à partir de "Personne 1"
    explorer_reseau(reseau_social, "Personne 1", visites)
            </code></pre>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez le réseau social pour ajouter des liens d’amitié supplémentaires.</li>
                <li><strong>Étape 2 :</strong> Utilisez DFS pour explorer les amis de "Personne 3" et proposer des amis potentiels (amis d’amis).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étude de Cas 2 : Réseau de Transport (40 min)</h3>
        
            <h4>1. Modélisation d’un Réseau de Transport :</h4>
            <p>Un réseau de transport, comme un réseau de métro ou de bus, peut être modélisé sous forme de graphe :</p>
            <ul>
                <li><strong>Nœuds :</strong> Les stations ou arrêts de bus.</li>
                <li><strong>Arêtes :</strong> Les lignes de transport entre les stations.</li>
            </ul>
        
            <h4>2. Rechercher le Chemin le Plus Court :</h4>
            <p>Dans un réseau de transport, un problème fréquent est de trouver le chemin le plus court entre deux stations. Pour cela, nous utilisons l’algorithme **BFS (Breadth-First Search)**, qui explore tous les voisins d'une station avant de passer aux voisins de niveau supérieur.</p>
        
            <h4>3. Exemple Visuel d’un Réseau de Transport :</h4>
            <pre><code>
    Station A --- Station B --- Station C
        |           |               |
    Station D --- Station E --- Station F
            </code></pre>
            <p>Chaque station est représentée par un nœud, et chaque ligne de transport entre deux stations est une arête.</p>
        
            <h4>Algorithme BFS pour Trouver le Chemin le Plus Court :</h4>
            <p>Nous allons utiliser l’algorithme BFS pour trouver le chemin le plus court entre deux stations :</p>
        
            <pre><code>
    from collections import deque
        
    def bfs_chemin_court(graphe, debut, fin):
        visites = set()  # Ensemble des stations visitées
        queue = deque([(debut, [debut])])  # File d'attente avec le chemin actuel
        
        while queue:
            (station, chemin) = queue.popleft()
            if station == fin:
                return chemin  # Retourner le chemin trouvé
            
            for voisin dans graphe[station]:
                if voisin not in visites:
                    visites.add(voisin)
                    queue.append((voisin, chemin + [voisin]))  # Ajouter le voisin et le chemin parcouru
        return None  # Aucun chemin trouvé
            </code></pre>
        
            <h4>4. Implémentation en Python :</h4>
            <pre><code>
    reseau_transport = {
        "Station A": ["Station B", "Station D"],
        "Station B": ["Station A", "Station C", "Station E"],
        "Station C": ["Station B", "Station F"],
        "Station D": ["Station A", "Station E"],
        "Station E": ["Station B", "Station D", "Station F"],
        "Station F": ["Station C", "Station E"]
    }
    
    chemin = bfs_chemin_court(reseau_transport, "Station A", "Station F")
    print(f"Le chemin le plus court est : {chemin}")
            </code></pre>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Ajoutez de nouvelles lignes de transport dans le réseau.</li>
                <li><strong>Étape 2 :</strong> Utilisez BFS pour trouver le chemin le plus court entre deux stations définies par l’utilisateur.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Comparaison des Applications (10 min)</h3>
            
            <h4>Discussion :</h4>
            <ul>
                <li>Les graphes sont une structure extrêmement polyvalente utilisée dans des domaines très variés, des réseaux sociaux aux transports en passant par la biologie.</li>
                <li>Les algorithmes de parcours comme DFS et BFS permettent de résoudre efficacement des problèmes complexes tels que l’exploration de réseaux ou la recherche de chemins.</li>
                <li>Dans les réseaux sociaux, DFS peut être utilisé pour explorer des relations profondes, tandis que BFS est souvent utilisé pour explorer des connexions plus directes, comme dans les réseaux de transport.</li>
            </ul>
        
            <h4>Problèmes Avancés :</h4>
            <ul>
                <li>Comment optimiser le parcours dans un graphe de grande taille, où chaque nœud peut avoir de nombreux voisins ?</li>
                <li>Comment adapter ces algorithmes pour des applications plus spécifiques, comme la recommandation de contenu ou la gestion du trafic dans un réseau urbain ?</li>
            </ul>
        </section>
        
        <section id="session19" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 19 : Introduction aux Arbres Binaires et leurs Applications</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves découvriront les arbres binaires, leurs propriétés, et leurs applications dans un contexte de jeu vidéo. Ils apprendront à modéliser et à manipuler des arbres binaires, en mettant l'accent sur des applications concrètes comme la gestion d'inventaires dans un jeu ou la recherche rapide d'objets.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Arbres Binaires</h3>
        
            <h4>1. Qu’est-ce qu’un Arbre Binaire ?</h4>
            <p>Un arbre binaire est une structure de données hiérarchique dans laquelle chaque nœud a au maximum deux enfants, appelés <strong>enfant gauche</strong> et <strong>enfant droit</strong>.</p>
            
            <h4>Exemple Visuel :</h4>
            <pre><code>
          8
         / \
        3   10
       / \    \
      1   6   14
         / \   /
        4   7 13
            </code></pre>
            <p>Dans cet exemple, chaque nœud contient une valeur, et chaque nœud peut avoir deux enfants. Le nœud racine est 8, les enfants de 8 sont 3 (à gauche) et 10 (à droite).</p>
        
            <h4>Propriétés des Arbres Binaires :</h4>
            <ul>
                <li>Chaque nœud a au plus deux enfants.</li>
                <li>Les sous-arbres peuvent eux-mêmes être des arbres binaires.</li>
                <li>Un arbre binaire peut être utilisé pour stocker des données ordonnées de manière à permettre des recherches, des insertions et des suppressions rapides.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Applications des Arbres Binaires dans un Jeu Vidéo</h3>
        
            <h4>Contexte du Jeu Vidéo :</h4>
            <p>Dans un jeu vidéo de gestion d'inventaire, chaque objet ramassé par le joueur peut être stocké dans un arbre binaire de recherche (binary search tree, ou BST). Cet arbre permet de rechercher un objet spécifique rapidement, ou de trier les objets par ordre de puissance ou de rareté.</p>
        
            <h4>Exemple d'Application : Gestion d'Inventaire</h4>
            <p>Dans un RPG (jeu de rôle), les objets ramassés par le joueur peuvent être organisés dans un arbre binaire selon leur valeur (par exemple, un objet plus puissant sera placé à droite d'un objet moins puissant). Cela permet de rechercher un objet de manière efficace, ou de lister tous les objets dans l'ordre de leur valeur.</p>
        
            <h4>Modélisation d’un Inventaire avec un Arbre Binaire :</h4>
            <p>Chaque objet dans l’inventaire est un nœud de l’arbre, où :</p>
            <ul>
                <li>La racine de l'arbre est le premier objet ramassé.</li>
                <li>Les objets plus puissants sont placés à droite de l’arbre.</li>
                <li>Les objets moins puissants sont placés à gauche.</li>
            </ul>
        
            <h4>Exemple Visuel avec des Objets :</h4>
            <pre><code>
        Épée de fer (puissance 8)
         /         \
    Bouclier (3)  Arc (10)
                \
             Flèche (14)
            </code></pre>
        
            <p>Dans cet exemple, l'épée de fer est la racine, car elle a été ramassée en premier. Le bouclier, moins puissant, est placé à gauche. L’arc, plus puissant, est placé à droite.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation d’un Arbre Binaire en Python (40 min)</h3>
        
            <h4>1. Représentation d’un Nœud d’Arbre Binaire :</h4>
            <p>Nous allons d’abord définir une classe <code>ArbreBinaire</code> pour représenter chaque nœud de l’arbre binaire.</p>
        
            <pre><code>
    class ArbreBinaire:
        def __init__(self, valeur):
            self.valeur = valeur
            self.gauche = None
            self.droite = None
            </code></pre>
        
            <p>Chaque nœud a une <code>valeur</code> et peut avoir deux enfants : <code>gauche</code> et <code>droite</code>.</p>
        
            <h4>2. Insertion dans un Arbre Binaire :</h4>
            <p>Pour insérer un nouvel objet dans l’arbre binaire, nous allons comparer la valeur de l’objet avec la valeur du nœud courant. Si l’objet est moins puissant (ou de valeur inférieure), il sera inséré à gauche. Sinon, il sera inséré à droite.</p>
        
            <pre><code>
    def inserer(noeud, valeur):
        if noeud is None:
            return ArbreBinaire(valeur)
        
        if valeur < noeud.valeur:
            noeud.gauche = inserer(noeud.gauche, valeur)
        else:
            noeud.droite = inserer(noeud.droite, valeur)
        
        return noeud
            </code></pre>
        
            <h4>3. Exemple d’Insertion dans l’Arbre :</h4>
            <p>Supposons que le joueur ramasse un bouclier avec une puissance de 5 et qu’il l’insère dans l’inventaire :</p>
        
            <pre><code>
    # Créer la racine de l'arbre
    racine = ArbreBinaire(8)
    
    # Insérer d'autres objets dans l'inventaire
    inserer(racine, 3)  # Bouclier
    inserer(racine, 10) # Arc
    inserer(racine, 1)  # Casque
            </code></pre>
        
            <h4>4. Parcours Infixe (In-order Traversal) :</h4>
            <p>Pour lister les objets dans l’ordre de leur puissance, nous utilisons un parcours infixe. Ce parcours visite d’abord le sous-arbre gauche, puis le nœud courant, et enfin le sous-arbre droit.</p>
        
            <pre><code>
    def parcours_infixe(noeud):
        if noeud:
            parcours_infixe(noeud.gauche)
            print(noeud.valeur, end=" ")
            parcours_infixe(noeud.droite)
    
    # Lancer le parcours infixe
    parcours_infixe(racine)
            </code></pre>
        
            <h4>Résultat attendu :</h4>
            <p>Si le joueur a ramassé des objets avec des puissances de 1, 3, 8, et 10, le parcours infixe affichera : <code>1 3 8 10</code>.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Défi Pratique pour les Élèves (30 min)</h3>
        
            <h4>Étape 1 :</h4>
            <p>Modifiez le programme pour que chaque objet ait un nom (par exemple, “Épée de fer”) en plus de sa valeur de puissance. Vous pouvez créer une classe <code>Objet</code> pour représenter chaque objet, et la valeur de puissance sera utilisée pour ordonner les objets dans l’arbre binaire.</p>
        
            <h4>Étape 2 :</h4>
            <p>Ajoutez une fonctionnalité permettant de chercher un objet dans l’arbre par son nom ou sa puissance. Si l’objet est trouvé, affichez ses caractéristiques. Si l’objet n’est pas trouvé, affichez un message indiquant qu’il n’est pas dans l’inventaire.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion (10 min)</h3>
            <p>À la fin de cette séance, les élèves auront appris les concepts fondamentaux des arbres binaires et auront appliqué ces connaissances à un exemple concret de gestion d’inventaire dans un jeu vidéo. Ils auront également renforcé leur compréhension des parcours d’arbres (parcours infixe) et de l’insertion dans un arbre binaire.</p>
            <p>Les élèves pourront utiliser cette structure de données pour d’autres applications dans leurs futurs projets, comme la gestion de données hiérarchiques ou la recherche efficace d’informations.</p>
        </section>

        <section id="session20" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 20 : Pratique - Utilisation d’arbres pour organiser une base de données de personnages de manga</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront à utiliser une structure de données en <strong>arbre binaire de recherche (BST)</strong> pour organiser une base de données de personnages de manga. Ils exploreront comment stocker et rechercher efficacement des informations sur les personnages en fonction de caractéristiques spécifiques (nom, puissance, affiliation).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Arbres Binaires et à leur Utilisation (30 min)</h3>
        
            <h4>Contexte de la Séance :</h4>
            <p>Dans l’univers des mangas, chaque personnage a des caractéristiques uniques (nom, puissance, affiliation, etc.). Nous allons organiser une base de données de personnages en utilisant un <strong>arbre binaire de recherche</strong> pour permettre des opérations de recherche rapide, d’ajout et de suppression de personnages.</p>
        
            <h4>Qu'est-ce qu'un Arbre Binaire de Recherche (BST) ?</h4>
            <p>Un <strong>arbre binaire de recherche (BST)</strong> est une structure de données récursive qui permet de stocker des données de manière ordonnée, facilitant ainsi les opérations de recherche, d'insertion et de suppression.</p>
            <ul>
                <li><strong>Nœud :</strong> Chaque nœud de l'arbre contient un élément (par exemple, un personnage de manga).</li>
                <li><strong>Clé :</strong> Chaque nœud a une clé (par exemple, le nom du personnage ou un autre attribut) qui est utilisée pour organiser l’arbre.</li>
                <li><strong>Arbre binaire :</strong> Chaque nœud a au plus deux enfants : un enfant à gauche (plus petit) et un enfant à droite (plus grand).</li>
            </ul>
        
            <h4>Principe du BST :</h4>
            <p>Dans un BST :</p>
            <ul>
                <li>Pour chaque nœud, tous les éléments dans le sous-arbre gauche sont plus petits que l’élément du nœud.</li>
                <li>Tous les éléments dans le sous-arbre droit sont plus grands que l’élément du nœud.</li>
            </ul>
        
            <h4>Exemple Visuel d’un Arbre Binaire de Recherche :</h4>
            <pre><code>
            Luffy
            /    \
         Goku    Naruto
         /  \       /   \
    Zoro Vegeta   Sasuke  Saitama
            </code></pre>
            <p>Dans cet arbre :</p>
            <ul>
                <li>Le personnage Luffy est la racine.</li>
                <li>Les personnages situés à gauche de Luffy (Goku, Zoro) ont des noms plus petits (ordre alphabétique), tandis que ceux situés à droite (Naruto, Saitama) ont des noms plus grands.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation Pratique d’un Arbre Binaire de Recherche (BST) (45 min)</h3>
        
            <h4>1. Créer une Classe pour Représenter un Personnage de Manga :</h4>
            <p>Chaque personnage sera représenté par un objet contenant des informations telles que son nom, sa puissance et son affiliation.</p>
        
            <pre><code>
    class PersonnageManga:
        def __init__(self, nom, puissance, affiliation):
            self.nom = nom
            self.puissance = puissance
            self.affiliation = affiliation
            self.gauche = None  # Sous-arbre gauche
            self.droite = None  # Sous-arbre droit
    
        def __str__(self):
            return f"{self.nom} - Puissance : {self.puissance}, Affiliation : {self.affiliation}"
            </code></pre>
        
            <p>Chaque instance de <code>PersonnageManga</code> représente un personnage avec un nom, une puissance et une affiliation.</p>
        
            <h4>2. Créer un Arbre Binaire de Recherche :</h4>
            <p>L’arbre binaire de recherche sera utilisé pour organiser les personnages en fonction de leur nom. Chaque nœud de l’arbre contiendra un personnage de manga.</p>
        
            <pre><code>
    class ArbreBinaireRecherche:
        def __init__(self):
            self.racine = None  # La racine de l'arbre est initialement vide
    
        # Fonction pour insérer un nouveau personnage dans l'arbre
        def inserer(self, personnage):
            if self.racine is None:
                self.racine = personnage  # Si l'arbre est vide, le personnage devient la racine
            else:
                self._inserer_recur(self.racine, personnage)
    
        # Fonction récursive pour insérer dans le bon sous-arbre
        def _inserer_recur(self, courant, personnage):
            if personnage.nom < courant.nom:
                if courant.gauche is None:
                    courant.gauche = personnage  # Insertion à gauche
                else:
                    self._inserer_recur(courant.gauche, personnage)  # Récursion vers la gauche
            else:
                if courant.droite is None:
                    courant.droite = personnage  # Insertion à droite
                else:
                    self._inserer_recur(courant.droite, personnage)  # Récursion vers la droite
    
        # Fonction pour afficher l'arbre en parcours infixe (ordre alphabétique)
        def afficher_infixe(self):
            self._afficher_infixe_recur(self.racine)
    
        def _afficher_infixe_recur(self, courant):
            if courant is not None:
                self._afficher_infixe_recur(courant.gauche)
                print(courant)
                self._afficher_infixe_recur(courant.droite)
            </code></pre>
        
            <p>Cette classe permet d’ajouter des personnages dans l’arbre et de les afficher dans l’ordre alphabétique grâce à un parcours en infixe.</p>
        
            <h4>3. Insérer des Personnages dans l’Arbre :</h4>
            <p>Ajoutons des personnages célèbres de mangas dans notre arbre :</p>
        
            <pre><code>
    # Création de l'arbre
    arbre = ArbreBinaireRecherche()
    
    # Création des personnages
    luffy = PersonnageManga("Luffy", 9000, "Pirate")
    goku = PersonnageManga("Goku", 9500, "Guerrier Saiyan")
    naruto = PersonnageManga("Naruto", 8800, "Ninja")
    saitama = PersonnageManga("Saitama", 10000, "Héros")
    zoro = PersonnageManga("Zoro", 8500, "Pirate")
    vegeta = PersonnageManga("Vegeta", 9400, "Guerrier Saiyan")
    
    # Insertion dans l'arbre
    arbre.inserer(luffy)
    arbre.inserer(goku)
    arbre.inserer(naruto)
    arbre.inserer(saitama)
    arbre.inserer(zoro)
    arbre.inserer(vegeta)
    
    # Affichage des personnages dans l'ordre alphabétique
    arbre.afficher_infixe()
            </code></pre>
        
            <p>La sortie du programme affichera les personnages par ordre alphabétique de nom :</p>
        
            <pre><code>
    Goku - Puissance : 9500, Affiliation : Guerrier Saiyan
    Luffy - Puissance : 9000, Affiliation : Pirate
    Naruto - Puissance : 8800, Affiliation : Ninja
    Saitama - Puissance : 10000, Affiliation : Héros
    Vegeta - Puissance : 9400, Affiliation : Guerrier Saiyan
    Zoro - Puissance : 8500, Affiliation : Pirate
            </code></pre>
        
            <h4>4. Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez le programme pour que l’arbre soit organisé en fonction de la puissance des personnages au lieu de leur nom.</li>
                <li><strong>Étape 2 :</strong> Ajoutez une fonction pour rechercher un personnage par nom dans l’arbre et renvoyer ses caractéristiques.</li>
                <li><strong>Étape 3 :</strong> Ajoutez une fonctionnalité pour supprimer un personnage de l’arbre (utilisation d’un algorithme de suppression dans un arbre binaire).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Applications (10 min)</h3>
        
            <p>À la fin de cette séance, les élèves auront appris à :</p>
            <ul>
                <li>Utiliser un <strong>arbre binaire de recherche</strong> pour organiser et gérer des données de manière structurée et efficace.</li>
                <li>Implémenter les opérations de base d’un arbre (insertion, parcours, recherche) dans un contexte de gestion de base de données de personnages de manga.</li>
            </ul>
        
            <p>Cette approche leur permettra de comprendre comment les structures de données avancées sont utilisées pour organiser de grandes quantités de données dans des applications réelles, telles que les bases de données et les systèmes de recherche d’information.</p>
        </section>
        
        <section id="session21" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 21 : Algorithmes de Parcours d’Arbres (Pré-ordre, En-ordre, Post-ordre)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront et mettront en pratique les trois principales méthodes de parcours d’arbres binaires : pré-ordre, en-ordre, et post-ordre. Ils exploreront ces algorithmes dans le contexte d'un jeu vidéo où un personnage doit explorer des niveaux structurés sous forme d'arbres (arborescence de décisions, exploration d’environnements hiérarchiques).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Arbres Binaires et Parcours</h3>
            <h4>Le Contexte du Jeu Vidéo :</h4>
            <p>Dans un jeu vidéo d'exploration, un personnage évolue dans une série de niveaux ou d’environnements reliés entre eux de manière hiérarchique. Chaque environnement peut être modélisé sous forme d’arbre binaire :</p>
            <ul>
                <li><strong>Nœuds :</strong> représentent des zones ou des objectifs dans le jeu (par exemple, des salles, des missions, ou des ennemis).</li>
                <li><strong>Branches (arêtes) :</strong> relient deux nœuds et représentent les chemins ou les transitions possibles entre les différentes zones ou objectifs.</li>
            </ul>
            <p>Le joueur doit explorer l’arbre en visitant chaque nœud en suivant un parcours spécifique. Nous allons explorer trois types de parcours : pré-ordre, en-ordre, et post-ordre.</p>
        
            <h4>Définition d’un Arbre Binaire :</h4>
            <ul>
                <li><strong>Nœud Racine :</strong> Le point de départ de l’arbre.</li>
                <li><strong>Nœuds Fils :</strong> Deux sous-arbres, le fils gauche et le fils droit.</li>
                <li><strong>Feuille :</strong> Un nœud sans fils.</li>
            </ul>
        
            <h4>Exemple d’Arbre Binaire :</h4>
            <pre><code>
                A
               / \
              B   C
             / \   \
            D   E   F
            </code></pre>
            <p>Dans cet arbre, A est la racine, B et C sont ses enfants, et D, E, F sont des feuilles.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Algorithmes de Parcours d’Arbres (30 min)</h3>
            
            <h4>1. Parcours en Pré-ordre (Prefix Traversal) :</h4>
            <p>Le parcours en pré-ordre explore un arbre en visitant d’abord le nœud racine, puis le sous-arbre gauche, puis le sous-arbre droit. Il suit l’ordre suivant :</p>
            <ul>
                <li>Visiter la racine</li>
                <li>Explorer le sous-arbre gauche</li>
                <li>Explorer le sous-arbre droit</li>
            </ul>
            
            <h4>Exemple Visuel du Parcours en Pré-ordre :</h4>
            <pre><code>
                A
               / \
              B   C
             / \   \
            D   E   F
            
            Parcours pré-ordre : A → B → D → E → C → F
            </code></pre>
            
            <h4>Pseudo-code du Parcours en Pré-ordre :</h4>
            <pre><code>
        def parcours_preordre(noeud):
            if noeud:
                print(noeud.valeur)  # Visiter la racine
                parcours_preordre(noeud.gauche)  # Explorer le sous-arbre gauche
                parcours_preordre(noeud.droite)  # Explorer le sous-arbre droit
            </code></pre>
        
            <h4>Explication :</h4>
            <ul>
                <li>La racine est visitée en premier.</li>
                <li>Le sous-arbre gauche est entièrement exploré avant de passer au sous-arbre droit.</li>
            </ul>
        
            <h4>2. Parcours en En-ordre (Infix Traversal) :</h4>
            <p>Le parcours en en-ordre explore l’arbre en visitant d’abord le sous-arbre gauche, puis la racine, puis le sous-arbre droit. Il suit l’ordre suivant :</p>
            <ul>
                <li>Explorer le sous-arbre gauche</li>
                <li>Visiter la racine</li>
                <li>Explorer le sous-arbre droit</li>
            </ul>
        
            <h4>Exemple Visuel du Parcours en En-ordre :</h4>
            <pre><code>
                A
               / \
              B   C
             / \   \
            D   E   F
            
            Parcours en-ordre : D → B → E → A → C → F
            </code></pre>
        
            <h4>Pseudo-code du Parcours en En-ordre :</h4>
            <pre><code>
        def parcours_enordre(noeud):
            if noeud:
                parcours_enordre(noeud.gauche)  # Explorer le sous-arbre gauche
                print(noeud.valeur)  # Visiter la racine
                parcours_enordre(noeud.droite)  # Explorer le sous-arbre droit
            </code></pre>
        
            <h4>Explication :</h4>
            <ul>
                <li>Le sous-arbre gauche est entièrement exploré avant de visiter la racine.</li>
                <li>Le sous-arbre droit est visité en dernier.</li>
            </ul>
        
            <h4>3. Parcours en Post-ordre (Postfix Traversal) :</h4>
            <p>Le parcours en post-ordre explore l’arbre en visitant d’abord le sous-arbre gauche, puis le sous-arbre droit, et enfin la racine. Il suit l’ordre suivant :</p>
            <ul>
                <li>Explorer le sous-arbre gauche</li>
                <li>Explorer le sous-arbre droit</li>
                <li>Visiter la racine</li>
            </ul>
        
            <h4>Exemple Visuel du Parcours en Post-ordre :</h4>
            <pre><code>
                A
               / \
              B   C
             / \   \
            D   E   F
            
            Parcours post-ordre : D → E → B → F → C → A
            </code></pre>
        
            <h4>Pseudo-code du Parcours en Post-ordre :</h4>
            <pre><code>
        def parcours_postordre(noeud):
            if noeud:
                parcours_postordre(noeud.gauche)  # Explorer le sous-arbre gauche
                parcours_postordre(noeud.droite)  # Explorer le sous-arbre droit
                print(noeud.valeur)  # Visiter la racine
            </code></pre>
        
            <h4>Explication :</h4>
            <ul>
                <li>Les deux sous-arbres sont explorés avant de visiter la racine.</li>
                <li>Le parcours en post-ordre est souvent utilisé dans les contextes où des sous-arbres doivent être traités avant leur racine.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique dans le Contexte du Jeu Vidéo (40 min)</h3>
        
            <h4>1. Représentation d’un Arbre en Python :</h4>
            <p>Dans ce jeu vidéo, nous allons modéliser une série de niveaux interconnectés sous forme d’arbre binaire. Voici une classe Python pour représenter un nœud dans l’arbre :</p>
        
            <pre><code>
        class Noeud:
            def __init__(self, valeur):
                self.valeur = valeur
                self.gauche = None
                self.droite = None
        
        # Créer un exemple d'arbre
        racine = Noeud('A')
        racine.gauche = Noeud('B')
        racine.droite = Noeud('C')
        racine.gauche.gauche = Noeud('D')
        racine.gauche.droite = Noeud('E')
        racine.droite.droite = Noeud('F')
            </code></pre>
        
            <h4>2. Implémentation des Trois Parcours :</h4>
            <p>Les élèves implémenteront les trois types de parcours (pré-ordre, en-ordre, post-ordre) en Python, à partir de la structure d'arbre ci-dessus.</p>
        
            <pre><code>
        def parcours_preordre(noeud):
            if noeud:
                print(noeud.valeur)
                parcours_preordre(noeud.gauche)
                parcours_preordre(noeud.droite)
        
        def parcours_enordre(noeud):
            if noeud:
                parcours_enordre(noeud.gauche)
                print(noeud.valeur)
                parcours_enordre(noeud.droite)
        
        def parcours_postordre(noeud):
            if noeud:
                parcours_postordre(noeud.gauche)
                parcours_postordre(noeud.droite)
                print(noeud.valeur)
            </code></pre>
        
            <h4>Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Implémentez les trois parcours et testez-les sur l’arbre fourni.</li>
                <li><strong>Étape 2 :</strong> Modifiez l’arbre pour ajouter plus de niveaux et des valeurs différentes.</li>
                <li><strong>Étape 3 :</strong> Modélisez un système de progression dans un jeu vidéo où chaque nœud représente une mission ou un niveau, et le joueur suit un parcours spécifique (par exemple, post-ordre pour accomplir toutes les missions avant de rencontrer le boss final).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Comparaison (10 min)</h3>
            <p>À la fin de cette séance, les élèves auront appris à appliquer les trois parcours d’arbres dans différents contextes, et auront compris comment chaque type de parcours peut être utile selon le problème à résoudre. Ils auront également renforcé leur compréhension de la récursivité et de la structure des arbres binaires.</p>
        </section>

        <section id="session22" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 22 : Approfondissement sur les Algorithmes de Parcours d’Arbres</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront les différentes méthodes de parcours d’arbres, incluant les parcours en profondeur (pré-ordre, en ordre, post-ordre) et en largeur. Ces parcours seront appliqués dans un contexte pratique de jeu vidéo, où les structures d’arbres peuvent représenter des niveaux de jeu, des décisions ou des quêtes à accomplir.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Arbres et Parcours d'Arbres</h3>
            
            <h4>Contexte du Jeu Vidéo :</h4>
            <p>Dans un jeu vidéo, un arbre peut représenter différentes structures de jeu. Par exemple :</p>
            <ul>
                <li>Un arbre de quêtes, où chaque nœud représente une quête que le joueur doit accomplir avant de passer à la suivante.</li>
                <li>Un arbre de niveaux, où chaque nœud est un niveau, et le joueur doit explorer les niveaux dans un ordre spécifique.</li>
                <li>Un arbre de décision, où chaque nœud est une action possible, et chaque branche représente une conséquence ou un choix.</li>
            </ul>
            <p>Nous allons étudier comment parcourir ces arbres de manière systématique en utilisant plusieurs algorithmes de parcours.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Types de Parcours d'Arbres</h3>
            
            <p>Il existe deux grandes catégories de parcours d'arbres :</p>
            <ul>
                <li><strong>Parcours en profondeur</strong> (Depth-First Search) :</li>
                <ul>
                    <li><strong>Pré-ordre (Préfixe)</strong> : Visite du nœud courant, puis des sous-arbres gauche et droit.</li>
                    <li><strong>En ordre (Infixe)</strong> : Visite du sous-arbre gauche, du nœud courant, puis du sous-arbre droit.</li>
                    <li><strong>Post-ordre (Suffixe)</strong> : Visite des sous-arbres gauche et droit, puis du nœud courant.</li>
                </ul>
                <li><strong>Parcours en largeur</strong> (Breadth-First Search) :</li>
                <ul>
                    <li>Parcours de chaque niveau de l’arbre un par un, en commençant par la racine, puis les nœuds enfants de gauche à droite.</li>
                </ul>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Explications et Pseudo-code pour chaque Type de Parcours</h3>
        
            <h4>Parcours en Profondeur – Pré-ordre, En Ordre, Post-ordre</h4>
        
            <h5>Pré-ordre</h5>
            <p>Le parcours pré-ordre commence par le nœud courant, puis explore le sous-arbre gauche et enfin le sous-arbre droit. C'est utile dans des jeux où l’on doit visiter une action ou une quête principale avant de passer aux étapes suivantes.</p>
            <pre><code>def parcours_pre_ordre(noeud):
            if noeud is not None:
                print(noeud.valeur)  # Visiter le nœud courant
                parcours_pre_ordre(noeud.gauche)
                parcours_pre_ordre(noeud.droit)
            </code></pre>
        
            <h5>En Ordre</h5>
            <p>Le parcours en ordre explore d'abord le sous-arbre gauche, puis le nœud courant, et enfin le sous-arbre droit. C'est couramment utilisé pour obtenir les valeurs d’un arbre binaire dans un ordre trié.</p>
            <pre><code>def parcours_en_ordre(noeud):
            if noeud is not None:
                parcours_en_ordre(noeud.gauche)
                print(noeud.valeur)  # Visiter le nœud courant
                parcours_en_ordre(noeud.droit)
            </code></pre>
        
            <h5>Post-ordre</h5>
            <p>Le parcours post-ordre commence par explorer les sous-arbres gauche et droit, puis visite le nœud courant. Cela peut être utile pour des jeux où chaque action nécessite d'accomplir des sous-tâches avant de valider la tâche principale.</p>
            <pre><code>def parcours_post_ordre(noeud):
            if noeud is not None:
                parcours_post_ordre(noeud.gauche)
                parcours_post_ordre(noeud.droit)
                print(noeud.valeur)  # Visiter le nœud courant
            </code></pre>
        
            <h4>Parcours en Largeur (BFS)</h4>
            <p>Dans le parcours en largeur, l’algorithme explore les nœuds niveau par niveau, en commençant par la racine. Cela peut être utile pour explorer chaque niveau de décision ou de quête dans un ordre croissant.</p>
            <pre><code>from collections import deque
        
        def parcours_largeur(noeud):
            queue = deque([noeud])  # Utilisation d'une file d'attente
            while queue:
                courant = queue.popleft()
                print(courant.valeur)  # Visiter le nœud courant
                if courant.gauche:
                    queue.append(courant.gauche)
                if courant.droit:
                    queue.append(courant.droit)
            </code></pre>
        
            <h4>Exemple d’Arbre :</h4>
            <p>Considérons l’arbre suivant pour illustrer chaque type de parcours :</p>
            <pre><code>       A
             /     \
            B       C
           / \     / \
          D   E   F   G
            </code></pre>
            <p>Les résultats des parcours seraient :</p>
            <ul>
                <li><strong>Pré-ordre :</strong> A, B, D, E, C, F, G</li>
                <li><strong>En ordre :</strong> D, B, E, A, F, C, G</li>
                <li><strong>Post-ordre :</strong> D, E, B, F, G, C, A</li>
                <li><strong>Largeur :</strong> A, B, C, D, E, F, G</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Mise en Pratique : Application au Jeu Vidéo</h3>
            
            <h4>Exercice Pratique :</h4>
            <p>Imaginons que chaque nœud de cet arbre représente une <strong>quête</strong> dans un jeu. L’objectif est de parcourir toutes les quêtes dans un ordre spécifique :</p>
            <ul>
                <li><strong>Pré-ordre :</strong> Le joueur doit accomplir les quêtes principales avant d’entrer dans les sous-quêtes.</li>
                <li><strong>En ordre :</strong> Le joueur doit accomplir toutes les quêtes de gauche à droite dans un ordre séquentiel.</li>
                <li><strong>Post-ordre :</strong> Le joueur doit terminer toutes les sous-quêtes avant de terminer la quête principale.</li>
                <li><strong>Largeur :</strong> Le joueur explore chaque niveau de l’arbre (comme explorer tous les niveaux d’une tour étage par étage).</li>
            </ul>
        
            <h4>Implémentation en Python :</h4>
            <p>Pour cet exercice, créez un arbre de quêtes, où chaque nœud contient une quête spécifique. Implémentez chaque type de parcours pour que le joueur puisse explorer les quêtes dans un ordre défini.</p>
            
            <pre><code>class Noeud:
            def __init__(self, valeur):
                self.valeur = valeur
                self.gauche = None
                self.droit = None
        
        # Créer l'arbre de quêtes
        racine = Noeud("A")
        racine.gauche = Noeud("B")
        racine.droit = Noeud("C")
        racine.gauche.gauche = Noeud("D")
        racine.gauche.droit = Noeud("E")
        racine.droit.gauche = Noeud("F")
        racine.droit.droit = Noeud("G")
            </code></pre>
        
            <p>Implémentez ensuite chaque parcours :</p>
        
            <pre><code># Parcours pré-ordre
        parcours_pre_ordre(racine)
        
        # Parcours en ordre
        parcours_en_ordre(racine)
        
        # Parcours post-ordre
        parcours_post_ordre(racine)
        
        # Parcours en largeur
        parcours_largeur(racine)
            </code></pre>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Ajoutez des actions dans chaque quête et modifiez les parcours pour afficher l'action correspondante dans chaque nœud visité.</li>
                <li><strong>Étape 2 :</strong> Modifiez l’arbre pour que certaines quêtes aient plusieurs sous-quêtes, puis testez chaque type de parcours.</li>
                <li><strong>Étape 3 :</strong> Faites en sorte que le parcours en largeur (BFS) limite le joueur à explorer uniquement les quêtes d'un certain niveau avant de passer au niveau suivant.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Comparaison des Parcours d’Arbres</h3>
        
            <p>À la fin de cette séance, les élèves auront exploré plusieurs types de parcours d’arbres, chacun ayant ses propres applications et avantages. Ils comprendront comment appliquer ces parcours dans des contextes variés comme la gestion de quêtes et de niveaux dans les jeux vidéo.</p>
        
            <h4>Comparaison des Parcours :</h4>
            <ul>
                <li><strong>Pré-ordre :</strong> Visite immédiate des actions principales, suivi des sous-quêtes.</li>
                <li><strong>En ordre :</strong> Exploration naturelle pour afficher un arbre binaire dans un ordre trié.</li>
                <li><strong>Post-ordre :</strong> Exécution des sous-tâches avant de valider la tâche principale.</li>
                <li><strong>Largeur :</strong> Parcours niveau par niveau, idéal pour explorer toutes les options accessibles au joueur avant de descendre plus loin.</li>
            </ul>
        
            <h4>Discussion et Applications :</h4>
            <p>Ces algorithmes de parcours sont utilisés non seulement dans les jeux, mais aussi dans d’autres domaines comme les bases de données et l’intelligence artificielle pour l’exploration de structures de décision et la recherche.</p>
        </section>

        <section id="session23" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 23 : Pratique - Création d’un Arbre de Décision pour un Jeu de Rôle (Jeu Vidéo)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront à créer et utiliser un <strong>arbre de décision</strong> pour gérer les décisions d'un personnage non joueur (PNJ) dans un jeu de rôle. Un arbre de décision permet de modéliser les choix que le PNJ peut faire en fonction des actions du joueur et des situations rencontrées dans le jeu.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Arbres de Décision</h3>
        
            <h4>Contexte du Jeu de Rôle :</h4>
            <p>Dans un jeu de rôle, un PNJ peut être programmé pour réagir de différentes manières aux actions du joueur. Par exemple, un PNJ garde pourrait décider de laisser passer le joueur, de le combattre, ou de lui poser une question, en fonction de certains critères (comme le niveau du joueur, son arme, ou son alignement).</p>
            <p>Pour modéliser ces comportements, nous allons utiliser un <strong>arbre de décision</strong> qui permet de structurer les choix possibles et d'orienter les décisions du PNJ en fonction de plusieurs conditions.</p>
        
            <h4>Qu'est-ce qu'un Arbre de Décision ?</h4>
            <p>Un arbre de décision est une structure en forme d’arbre où :</p>
            <ul>
                <li>Chaque <strong>nœud</strong> représente une question ou un test conditionnel.</li>
                <li>Chaque <strong>branche</strong> représente le résultat possible de la question (oui/non, vrai/faux, etc.).</li>
                <li>Chaque <strong>feuille</strong> (nœud terminal) représente une action ou une décision.</li>
            </ul>
            <p>Les arbres de décision permettent de diviser un problème complexe en une série de choix simples.</p>
        
            <h4>Exemple Visuel d'un Arbre de Décision :</h4>
            <pre><code>
                                Est-ce que le joueur est armé ?
                               /                       \
                           Oui                           Non
                          /                                \
            Le joueur a une arme puissante ?           Saluer le joueur
                 /              \
               Oui               Non
         Combattre le joueur   Poser une question
            </code></pre>
            <p>Dans cet exemple, le PNJ prend des décisions en fonction de l'état du joueur (armé ou non) et du type d'arme qu'il possède.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Construction d'un Arbre de Décision en Python (30 min)</h3>
            <h4>1. Modéliser l'Arbre de Décision avec des Classes :</h4>
            <p>Pour construire un arbre de décision, nous allons utiliser des <strong>classes</strong> pour représenter les nœuds de décision et les actions. Chaque nœud posera une question, et en fonction de la réponse, il pointera vers un autre nœud ou une action.</p>
        
            <pre><code>class NoeudDecision:
            def __init__(self, question, oui=None, non=None):
                self.question = question  # Question posée dans ce nœud
                self.oui = oui            # Branche oui
                self.non = non            # Branche non
        
        class Action:
            def __init__(self, description):
                self.description = description  # Description de l'action
        
        def executer_arbre(noeud):
            if isinstance(noeud, Action):
                print(noeud.description)
            else:
                reponse = input(noeud.question + " (oui/non) : ")
                if reponse == "oui":
                    executer_arbre(noeud.oui)
                else:
                    executer_arbre(noeud.non)
            </code></pre>
        
            <h4>2. Création de l'Arbre de Décision :</h4>
            <p>À présent, construisons un arbre de décision simple pour un PNJ gardien dans un jeu. Le gardien décidera d'agir en fonction de plusieurs conditions : si le joueur est armé, et si son arme est puissante ou non.</p>
        
            <pre><code># Feuilles de l'arbre de décision (actions)
        saluer = Action("Le PNJ vous salue.")
        poser_question = Action("Le PNJ vous pose une question.")
        combattre = Action("Le PNJ engage le combat.")
        
        # Nœuds de décision
        arme_puissante = NoeudDecision("Le joueur a-t-il une arme puissante ?", oui=combattre, non=poser_question)
        joueur_arme = NoeudDecision("Le joueur est-il armé ?", oui=arme_puissante, non=saluer)
        
        # Exécution de l'arbre de décision
        print("Interaction avec le PNJ :")
        executer_arbre(joueur_arme)
            </code></pre>
        
            <h4>Explication du Code :</h4>
            <ul>
                <li>Les classes <code>NoeudDecision</code> et <code>Action</code> permettent de construire l'arbre de décision.</li>
                <li>Les feuilles (actions) comme <code>saluer</code>, <code>poser_question</code>, et <code>combattre</code> définissent ce que le PNJ fera en fonction de la situation.</li>
                <li>Les nœuds de décision, comme <code>joueur_arme</code>, posent des questions pour déterminer l'action finale.</li>
            </ul>
        
            <h4>Test de l’Arbre de Décision :</h4>
            <p>Exécutez le code et répondez aux questions pour simuler une interaction avec le PNJ. Selon vos réponses, le PNJ prendra une décision appropriée.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Extension Pratique : Complexifier l'Arbre (20 min)</h3>
            <ul>
                <li><strong>Étape 1 :</strong> Ajoutez d’autres critères, par exemple, si le joueur possède un objet spécial ou s’il a une attitude pacifique.</li>
                <li><strong>Étape 2 :</strong> Complexifiez l'arbre pour introduire plus de décisions, par exemple :
                    <ul>
                        <li>Si le joueur est blessé, le PNJ peut offrir de l’aide.</li>
                        <li>Si le joueur a une réputation élevée, le PNJ le laisse passer sans poser de questions.</li>
                    </ul>
                </li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion (10 min)</h3>
            <p>À la fin de cette séance, les élèves auront appris à créer et à utiliser un arbre de décision pour gérer les comportements d’un PNJ dans un jeu vidéo. Ils comprendront comment utiliser des conditions imbriquées pour modéliser des choix complexes et permettront ainsi aux PNJ d'avoir des réactions variées selon les actions du joueur.</p>
        
            <p>Les arbres de décision sont un outil puissant en intelligence artificielle, notamment dans le développement de jeux vidéo, où les personnages doivent réagir de manière crédible à de nombreux scénarios possibles.</p>
        </section>
        
        <section id="session24" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 24 : Analyse des performances et avantages des arbres dans la recherche et le tri</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves vont explorer les avantages des arbres binaires, en particulier des <strong>arbres binaires de recherche</strong> (BST -> Binary Search Tree) et des <strong>arbres équilibrés</strong>, pour les opérations de recherche et de tri. Ils apprendront pourquoi et comment les arbres optimisent ces opérations en termes de complexité, et compareront les performances de l'arbre binaire avec d’autres structures de données comme les listes.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Arbres Binaires</h3>
        
            <h4>Définition d'un Arbre Binaire :</h4>
            <p>Un arbre binaire est une structure de données hiérarchique composée de <strong>nœuds</strong>. Chaque nœud possède au maximum deux <strong>enfants</strong>, généralement appelés enfant gauche et enfant droit.</p>
            
            <p>Les arbres binaires sont utilisés dans de nombreux algorithmes de recherche et de tri, car ils permettent de stocker les données de manière structurée et de faciliter la recherche.</p>
        
            <h4>Arbre Binaire de Recherche (BST) :</h4>
            <p>Un arbre binaire de recherche (BST) est un type spécifique d’arbre binaire où chaque nœud suit une règle importante :</p>
            <ul>
                <li>Les nœuds de l’arbre à gauche d’un nœud contiennent des valeurs plus petites.</li>
                <li>Les nœuds de l’arbre à droite d’un nœud contiennent des valeurs plus grandes.</li>
            </ul>
        
            <p>Cette structure permet d’accélérer les opérations de recherche en réduisant l’espace de recherche de moitié à chaque étape.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Avantages des Arbres Binaires dans la Recherche et le Tri (20 min)</h3>
            
            <h4>1. Recherche dans un BST :</h4>
            <p>Dans un arbre binaire de recherche, les opérations de recherche sont efficaces grâce à la structure organisée des nœuds. Pour rechercher un élément, on commence à la racine et on compare :</p>
            <ul>
                <li>Si la valeur recherchée est plus petite que le nœud courant, on se dirige vers le sous-arbre gauche.</li>
                <li>Si la valeur recherchée est plus grande, on se dirige vers le sous-arbre droit.</li>
            </ul>
        
            <p>Cette approche permet de réduire le nombre de comparaisons et rend la recherche rapide.</p>
        
            <h4>2. Complexité de la Recherche dans un BST :</h4>
            <p>Pour un arbre équilibré, la recherche dans un BST a une complexité moyenne de <code>O(log n)</code>. Cependant, dans le pire des cas (un arbre non équilibré où tous les nœuds sont dans une seule direction), la complexité peut atteindre <code>O(n)</code>.</p>
        
            <h4>3. Tri à l’aide d’un BST :</h4>
            <p>Les arbres binaires de recherche peuvent également être utilisés pour trier des données :</p>
            <ul>
                <li>On insère chaque élément dans le BST.</li>
                <li>En effectuant un parcours en ordre (in-order traversal), on obtient les éléments triés dans l'ordre croissant.</li>
            </ul>
            
            <p>Ce tri est efficace pour les petites structures ou lorsque les données sont progressivement ajoutées.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation d’un Arbre Binaire de Recherche (30 min)</h3>
        
            <h4>1. Structure de l’Arbre Binaire de Recherche :</h4>
            <p>Voici une représentation simple d'un nœud dans un arbre binaire de recherche :</p>
            
            <pre><code>class Noeud:
            def __init__(self, valeur):
                self.valeur = valeur
                self.gauche = None
                self.droite = None
        </code></pre>
        
            <h4>2. Insertion dans un BST :</h4>
            <p>L'insertion d'une valeur dans un arbre binaire de recherche suit la règle du BST :</p>
            <ul>
                <li>Si la valeur est inférieure au nœud courant, on l'insère dans le sous-arbre gauche.</li>
                <li>Si la valeur est supérieure, on l'insère dans le sous-arbre droit.</li>
            </ul>
            
            <pre><code>def inserer(noeud, valeur):
            if noeud is None:
                return Noeud(valeur)
            if valeur < noeud.valeur:
                noeud.gauche = inserer(noeud.gauche, valeur)
            else:
                noeud.droite = inserer(noeud.droite, valeur)
            return noeud
        </code></pre>
        
            <h4>3. Recherche dans un BST :</h4>
            <p>La fonction de recherche parcourt l’arbre de manière récursive pour trouver la valeur cible :</p>
        
            <pre><code>def rechercher(noeud, valeur):
            if noeud is None or noeud.valeur == valeur:
                return noeud
            if valeur < noeud.valeur:
                return rechercher(noeud.gauche, valeur)
            return rechercher(noeud.droite, valeur)
        </code></pre>
        
            <h4>4. Parcours en Ordre (In-order Traversal) :</h4>
            <p>Un parcours en ordre permet de récupérer les éléments dans l'ordre croissant :</p>
        
            <pre><code>def parcours_en_ordre(noeud):
            if noeud is not None:
                parcours_en_ordre(noeud.gauche)
                print(noeud.valeur, end=" ")
                parcours_en_ordre(noeud.droite)
        </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Applications Pratiques et Comparaisons (30 min)</h3>
        
            <h4>Exercice Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Créer un arbre binaire de recherche en insérant une liste de valeurs.</li>
                <li><strong>Étape 2 :</strong> Effectuer une recherche pour vérifier si des valeurs spécifiques sont présentes.</li>
                <li><strong>Étape 3 :</strong> Effectuer un parcours en ordre pour afficher les valeurs triées.</li>
            </ul>
        
            <h4>Comparaison avec d'autres Structures :</h4>
            <p>Les arbres binaires de recherche (BST) sont souvent plus efficaces que les listes pour les opérations de recherche et de tri, car :</p>
            <ul>
                <li><strong>Recherche :</strong> Une recherche dans une liste non triée a une complexité de <code>O(n)</code>, tandis que la recherche dans un BST équilibré est en <code>O(log n)</code>.</li>
                <li><strong>Tri :</strong> Les BST permettent de trier des données dynamiquement lors de leur insertion, sans avoir besoin d’un tri supplémentaire.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Points Clés</h3>
            <ul>
                <li>Les arbres binaires de recherche sont des structures efficaces pour la recherche et le tri.</li>
                <li>Pour maintenir les performances en <code>O(log n)</code>, un arbre binaire doit rester équilibré. Dans le cas contraire, l’arbre peut se transformer en une liste chaînée et perdre son efficacité.</li>
                <li>Les arbres équilibrés (comme les arbres AVL ou Red-Black) sont souvent utilisés en pratique pour garantir des performances optimales.</li>
            </ul>
        </section>

        <section id="session25" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 25 : Introduction au Tri Rapide (Quicksort)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Dans cette séance, les élèves vont découvrir et implémenter l'algorithme de tri rapide, ou Quicksort, un des algorithmes de tri les plus rapides et efficaces. L’objectif est de comprendre comment Quicksort divise une liste de nombres en sous-parties pour organiser ces éléments de manière ordonnée.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction au Tri Rapide (Quicksort)</h3>
            <h4>Le Contexte du Tri :</h4>
            <p>Imaginez un jeu vidéo dans lequel le joueur doit organiser rapidement un inventaire d’objets selon leur valeur ou leur poids pour accéder plus facilement aux objets les plus précieux. Un algorithme de tri comme Quicksort permet d’organiser cet inventaire de manière très efficace, même si le nombre d’objets est élevé.</p>
        
            <h4>Concept du Tri Rapide :</h4>
            <p>Quicksort est un algorithme de tri basé sur le principe de <strong>diviser pour régner</strong> :</p>
            <ul>
                <li>Il sélectionne un élément de la liste appelé <strong>pivot</strong>.</li>
                <li>Ensuite, il réorganise la liste de manière à ce que tous les éléments plus petits que le pivot se trouvent à gauche et tous les éléments plus grands se trouvent à droite.</li>
                <li>Le processus est ensuite appliqué récursivement aux sous-listes de gauche et de droite.</li>
            </ul>
        
            <p>Ce procédé divise la liste en sous-parties jusqu'à ce que chaque sous-liste contienne un seul élément, moment où tous les éléments sont triés.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étapes de Quicksort (20 min)</h3>
            <h4>1. Choix du Pivot :</h4>
            <p>Un pivot est un élément de la liste choisi pour diviser la liste en deux sous-listes. Le choix du pivot peut être fait de différentes manières :</p>
            <ul>
                <li>Le premier élément.</li>
                <li>Le dernier élément.</li>
                <li>Un élément aléatoire.</li>
                <li>Le milieu de la liste (option courante pour éviter les déséquilibres).</li>
            </ul>
            
            <h4>2. Réarrangement des Éléments autour du Pivot :</h4>
            <p>Après avoir choisi le pivot, Quicksort place tous les éléments inférieurs au pivot à gauche et tous les éléments supérieurs à droite. Cela divise la liste en deux parties indépendantes.</p>
        
            <h4>3. Récursivité dans Quicksort :</h4>
            <p>Le tri rapide utilise la récursivité pour trier les sous-listes de gauche et de droite autour du pivot, jusqu'à ce que toutes les sous-listes soient triées.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Pseudo-code de Quicksort</h3>
            <pre><code>def quicksort(liste):
            if len(liste) <= 1:  # Cas de base : si la liste contient 1 ou 0 élément
                return liste
            pivot = liste[len(liste) // 2]  # Choisir le pivot
            gauche = [x for x in liste if x < pivot]  # Éléments plus petits que le pivot
            milieu = [x for x in liste if x == pivot]  # Éléments égaux au pivot
            droite = [x for x in liste if x > pivot]  # Éléments plus grands que le pivot
            return quicksort(gauche) + milieu + quicksort(droite)  # Appels récursifs
            </code></pre>
        
            <p>Ce pseudo-code utilise la récursivité pour trier les sous-listes gauche et droite jusqu'à ce que toutes les sous-listes soient réduites à un ou zéro élément.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation de Quicksort en Python (30 min)</h3>
            <p>Nous allons maintenant implémenter l’algorithme de tri rapide en Python et l'appliquer à une liste de valeurs pour trier les objets d'un inventaire de jeu en fonction de leur poids.</p>
        
            <pre><code>def quicksort(liste):
            # Cas de base : si la liste est vide ou contient un seul élément, elle est déjà triée
            if len(liste) <= 1:
                return liste
        
            # Choix du pivot (élément central pour éviter le déséquilibre)
            pivot = liste[len(liste) // 2]
        
            # Créer des sous-listes pour les éléments inférieurs, égaux et supérieurs au pivot
            gauche = [x for x in liste if x < pivot]
            milieu = [x for x in liste if x == pivot]
            droite = [x for x in liste if x > pivot]
        
            # Appels récursifs sur les sous-listes
            return quicksort(gauche) + milieu + quicksort(droite)
        
        # Liste d'exemple pour tester le tri rapide
        inventaire = [5, 3, 8, 6, 2, 7, 4, 1]
        print("Inventaire trié :", quicksort(inventaire))
            </code></pre>
        
            <h4>Explication de l’Implémentation :</h4>
            <ul>
                <li><strong>Cas de base :</strong> Si la liste est vide ou contient un seul élément, elle est déjà triée.</li>
                <li><strong>Choix du pivot :</strong> L'élément central de la liste est choisi comme pivot.</li>
                <li><strong>Création de sous-listes :</strong> La liste est divisée en trois parties : éléments plus petits que le pivot, éléments égaux au pivot et éléments plus grands.</li>
                <li><strong>Appels récursifs :</strong> Les sous-listes gauche et droite sont triées de manière récursive, puis combinées pour obtenir la liste triée.</li>
            </ul>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez la liste pour qu'elle représente un inventaire avec des poids de différents objets.</li>
                <li><strong>Étape 2 :</strong> Utilisez Quicksort pour organiser les objets de l'inventaire par ordre de poids croissant.</li>
                <li><strong>Étape 3 :</strong> Ajoutez une fonctionnalité pour trier par ordre décroissant (en inversant la logique de comparaison).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Analyse de la Complexité de Quicksort (10 min)</h3>
            <p>Quicksort est un algorithme très efficace pour trier de grandes listes. Cependant, son efficacité dépend de la manière dont les pivots sont choisis.</p>
        
            <h4>1. Complexité Temporelle :</h4>
            <ul>
                <li><strong>Meilleur et cas moyen :</strong> <code>O(n log n)</code> lorsque les pivots divisent la liste de manière équilibrée.</li>
                <li><strong>Pire cas :</strong> <code>O(n^2)</code> si les pivots choisis divisent la liste de manière très déséquilibrée (par exemple, si le pivot est toujours le plus grand ou le plus petit élément).</li>
            </ul>
        
            <h4>2. Efficacité Pratique :</h4>
            <p>En moyenne, Quicksort est très rapide et est préféré pour de nombreux problèmes de tri, car il utilise peu de mémoire supplémentaire et est souvent plus rapide que d’autres algorithmes de tri comme le tri par fusion dans les applications pratiques.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion</h3>
            <p>À la fin de cette séance, les élèves comprendront comment Quicksort utilise la division pour organiser efficacement une liste d'éléments. Ils auront appris à choisir un pivot, diviser une liste autour de ce pivot, et appliquer la récursivité pour trier les sous-listes. Ce tri est particulièrement utile dans les jeux vidéo pour organiser des inventaires, classer des scores, et bien plus encore.</p>
        </section>

        <section id="session26" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 26 : Pratique - Implémentation du Quicksort pour trier des scores de jeu vidéo</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves vont apprendre à implémenter l’algorithme de tri Quicksort et à l'utiliser dans un contexte de jeu vidéo pour trier les scores des joueurs. Ils découvriront comment cet algorithme de tri rapide fonctionne en divisant et triant des sous-parties de la liste de scores, ce qui en fait une méthode efficace pour organiser des données en temps réel.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte de Jeu Vidéo :</h3>
            <p>Dans un jeu vidéo, les scores des joueurs sont souvent affichés sur un tableau de classement. Ce tableau doit être trié pour montrer les meilleurs scores en haut de la liste. L'algorithme Quicksort est un excellent choix pour organiser efficacement une liste de scores, car il est rapide et divise la liste en parties plus petites pour les trier indépendamment.</p>
        
            <h4>Scénario :</h4>
            <p>Les scores des joueurs dans notre jeu vidéo sont stockés dans une liste. Chaque fois qu'un joueur termine une partie, son score est ajouté à la liste. Pour afficher le classement des meilleurs joueurs, nous devons trier cette liste du score le plus élevé au plus bas.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Principe de Quicksort</h3>
            <p>Quicksort est un algorithme de tri qui utilise la méthode de "diviser pour régner" (divide and conquer) :</p>
            <ul>
                <li>Il sélectionne un élément appelé <strong>pivot</strong> dans la liste.</li>
                <li>Il divise la liste en deux parties : les éléments inférieurs au pivot et ceux supérieurs au pivot.</li>
                <li>Quicksort est ensuite appliqué récursivement aux sous-listes de chaque côté du pivot.</li>
            </ul>
            <p>Grâce à cette méthode, Quicksort peut trier une liste de manière très efficace, même pour de grandes quantités de données.</p>
        
            <h4>Exemple de Tri avec Quicksort :</h4>
            <pre><code>Scores initiaux : [35, 50, 20, 60, 10, 90]
        Pivot choisi : 35
        Scores inférieurs au pivot (35) : [20, 10]
        Scores supérieurs au pivot (35) : [50, 60, 90]
        Liste triée : [10, 20, 35, 50, 60, 90]
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Pseudo-code de Quicksort</h3>
            <p>Voici le pseudo-code pour une implémentation simple de Quicksort :</p>
            <pre><code>def quicksort(liste):
            if len(liste) <= 1:
                return liste  # Liste déjà triée ou vide
        
            pivot = liste[0]  # Choisir le premier élément comme pivot
            inferieurs = [x for x in liste[1:] if x <= pivot]  # Obtenir les éléments inférieurs au pivot
            superieurs = [x for x in liste[1:] if x > pivot]   # Obtenir les éléments supérieurs au pivot
        
            return quicksort(superieurs) + [pivot] + quicksort(inferieurs)  # Tri des parties et recombinaison
            </code></pre>
        
            <p>Dans cet exemple, on choisit le premier élément de la liste comme pivot et on utilise des compréhensions de liste pour diviser les éléments en deux groupes : ceux inférieurs ou égaux au pivot et ceux supérieurs au pivot.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation de Quicksort en Python (45 min)</h3>
        
            <h4>1. Initialisation de la Liste de Scores :</h4>
            <p>Pour notre jeu vidéo, nous initialisons une liste de scores de joueurs :</p>
            <pre><code>scores = [50, 85, 40, 95, 70, 10, 65, 100, 25, 80]
            </code></pre>
        
            <h4>2. Implémentation de Quicksort :</h4>
            <p>Nous allons maintenant implémenter Quicksort en Python pour trier cette liste de scores :</p>
            <pre><code>def quicksort(liste):
            # Condition d'arrêt : si la liste a un seul élément ou est vide, elle est déjà triée
            if len(liste) <= 1:
                return liste
        
            # Choix du pivot (le premier élément)
            pivot = liste[0]
        
            # Diviser les éléments autour du pivot
            inferieurs = [x for x in liste[1:] if x <= pivot]
            superieurs = [x for x in liste[1:] if x > pivot]
        
            # Récursivité : appliquer Quicksort aux sous-listes
            return quicksort(superieurs) + [pivot] + quicksort(inferieurs)
        
        # Utiliser Quicksort pour trier la liste des scores
        scores_tries = quicksort(scores)
        print("Scores triés du plus grand au plus petit :", scores_tries)
            </code></pre>
        
            <h4>3. Explication de l'implémentation :</h4>
            <ul>
                <li>La fonction <code>quicksort()</code> prend en paramètre une liste de scores.</li>
                <li>Si la liste est vide ou comporte un seul élément, elle est déjà triée et la fonction la retourne telle quelle.</li>
                <li>On choisit un pivot (ici, le premier élément de la liste) pour diviser la liste en deux groupes : <strong>inférieurs</strong> et <strong>supérieurs</strong>.</li>
                <li>La fonction appelle ensuite <code>quicksort()</code> récursivement sur les sous-listes, puis combine les résultats pour obtenir la liste triée.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exercice Pratique (30 min)</h3>
            <h4>Objectif :</h4>
            <p>Dans cet exercice pratique, les élèves devront modifier le code pour trier les scores du plus bas au plus haut, ou pour ajouter de nouveaux scores à la liste, simuler l'ajout de nouveaux joueurs et afficher un classement mis à jour.</p>
        
            <h4>Étapes :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Implémenter la fonction de tri Quicksort de manière à afficher les scores du plus bas au plus haut.</li>
                <li><strong>Étape 2 :</strong> Simuler l’ajout d’un score aléatoire à la liste des scores et afficher le classement mis à jour.</li>
                <li><strong>Étape 3 :</strong> Modifier l’algorithme pour trier en ordre croissant ou décroissant en fonction d’un paramètre.</li>
            </ul>
        
            <h4>Exemple d'ajout de score et affichage de classement :</h4>
            <pre><code>import random
        
        # Ajouter un nouveau score et trier la liste
        nouveau_score = random.randint(0, 100)
        scores.append(nouveau_score)
        print(f"Nouveau score ajouté : {nouveau_score}")
        scores_tries = quicksort(scores)
        print("Classement mis à jour :", scores_tries)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion (15 min)</h3>
            <p>À la fin de cette séance, les élèves auront appris comment implémenter et utiliser l’algorithme Quicksort pour organiser une liste de scores de jeu vidéo. Ils auront vu comment cet algorithme, en divisant la liste en parties plus petites, permet d'obtenir une solution très efficace pour trier des données dans un contexte interactif.</p>
        
            <p><strong>Points clés :</strong></p>
            <ul>
                <li><strong>Récursivité :</strong> Quicksort utilise la récursivité pour traiter chaque sous-liste individuellement.</li>
                <li><strong>Pivot :</strong> Le choix du pivot est crucial pour diviser la liste efficacement.</li>
                <li><strong>Applications pratiques :</strong> Utiliser Quicksort dans un contexte de jeu vidéo pour organiser un classement de scores.</li>
            </ul>
        
            <p>Pour la prochaine séance, les élèves appliqueront Quicksort dans un contexte de tri dynamique, où de nouveaux scores s’ajoutent régulièrement.</p>
        </section>

        <section id="session27" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 27 : Comparaison de la complexité des différents algorithmes de tri</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves vont étudier et comparer différents algorithmes de tri en Python en analysant leurs performances (complexité temporelle) dans des scénarios variés. Ils comprendront comment choisir l'algorithme de tri le plus adapté en fonction du contexte.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Algorithmes de Tri</h3>
            <p>Les algorithmes de tri permettent d’organiser les données dans un certain ordre (par exemple, croissant ou décroissant). Certains sont efficaces pour des petits ensembles de données, tandis que d'autres sont optimisés pour de grands ensembles. Les trois algorithmes de tri les plus courants que nous allons étudier sont :</p>
        
            <ul>
                <li><strong>Tri par sélection</strong> – Simple, mais peu efficace pour de grands ensembles de données.</li>
                <li><strong>Tri par insertion</strong> – Adapté aux petits ensembles ou aux listes presque triées.</li>
                <li><strong>Tri rapide (QuickSort)</strong> – Très performant pour de grands ensembles, mais peut être inefficace dans certains cas.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étude et Implémentation des Algorithmes de Tri</h3>
        
            <h4>1. Tri par Sélection</h4>
            <p>Le tri par sélection trouve l’élément le plus petit dans la liste et le place au début. Il répète ce processus pour chaque position dans la liste jusqu'à ce que tous les éléments soient triés.</p>
        
            <h4>Pseudo-code du Tri par Sélection :</h4>
            <pre><code>def tri_selection(liste):
            for i in range(len(liste)):
                min_index = i
                for j in range(i + 1, len(liste)):
                    if liste[j] < liste[min_index]:
                        min_index = j
                liste[i], liste[min_index] = liste[min_index], liste[i]
            </code></pre>
        
            <p>**Complexité temporelle** : O(n²) (peu efficace pour les grands ensembles)</p>
        
            <h4>Exercice pratique :</h4>
            <p>Implémentez le tri par sélection et testez-le sur une liste de nombres aléatoires. Notez le temps d’exécution pour des listes de 10, 100 et 1000 éléments.</p>
        
            <h4>2. Tri par Insertion</h4>
            <p>Le tri par insertion fonctionne en prenant chaque élément et en l'insérant à la bonne place dans une sous-liste triée. Ce tri est efficace pour les petites listes ou les listes presque triées.</p>
        
            <h4>Pseudo-code du Tri par Insertion :</h4>
            <pre><code>def tri_insertion(liste):
            for i in range(1, len(liste)):
                current = liste[i]
                j = i - 1
                while j >= 0 and liste[j] > current:
                    liste[j + 1] = liste[j]
                    j -= 1
                liste[j + 1] = current
            </code></pre>
        
            <p>**Complexité temporelle** : O(n²) (efficace pour les petites listes ou les listes presque triées)</p>
        
            <h4>Exercice pratique :</h4>
            <p>Implémentez le tri par insertion et mesurez son temps d’exécution pour des listes de tailles variées.</p>
        
            <h4>3. Tri Rapide (QuickSort)</h4>
            <p>Le tri rapide (QuickSort) est un algorithme de tri très rapide qui utilise le principe de <strong>diviser pour régner</strong>. Il choisit un élément pivot et partitionne la liste autour de ce pivot, de sorte que les éléments plus petits que le pivot se trouvent d'un côté et les éléments plus grands de l'autre. L'algorithme est ensuite appliqué récursivement sur chaque sous-liste.</p>
        
            <h4>Pseudo-code du Tri Rapide :</h4>
            <pre><code>def quicksort(liste):
            if len(liste) <= 1:
                return liste
            pivot = liste[len(liste) // 2]
            gauche = [x for x in liste if x < pivot]
            milieu = [x for x in liste if x == pivot]
            droite = [x for x in liste if x > pivot]
            return quicksort(gauche) + milieu + quicksort(droite)
            </code></pre>
        
            <p>**Complexité temporelle** : O(n log n) en moyenne (très efficace pour les grands ensembles de données)</p>
        
            <h4>Exercice pratique :</h4>
            <p>Implémentez QuickSort et comparez son temps d’exécution avec les autres algorithmes de tri pour des listes de 10, 100 et 1000 éléments.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Comparaison de la Complexité Temporelle des Algorithmes (45 min)</h3>
        
            <h4>1. Explication de la Complexité Temporelle</h4>
            <p>La complexité temporelle mesure le temps d'exécution d'un algorithme en fonction de la taille de la liste :</p>
            <ul>
                <li><strong>O(n²)</strong> : La complexité des algorithmes de tri par sélection et par insertion. Ils ne sont pas performants pour les grandes listes car le temps d'exécution augmente rapidement.</li>
                <li><strong>O(n log n)</strong> : La complexité moyenne du tri rapide. C'est le meilleur choix pour trier de grandes listes.</li>
            </ul>
        
            <h4>2. Comparaison en Situation Réelle</h4>
            <p>Demandez aux élèves d’écrire un programme pour mesurer le temps d'exécution des trois algorithmes sur des listes de différentes tailles (10, 100, 1000, et 10 000 éléments).</p>
        
            <pre><code>import random
        import time
        
        def mesurer_temps(algorithme, liste):
            debut = time.time()
            algorithme(liste)
            fin = time.time()
            return fin - debut
        
        # Créer des listes de différentes tailles
        tailles = [10, 100, 1000, 10000]
        algorithmes = [tri_selection, tri_insertion, quicksort]
        
        # Tester chaque algorithme pour chaque taille
        for taille in tailles:
            print(f"Taille de la liste : {taille}")
            liste = [random.randint(0, 100) for _ in range(taille)]
            for algorithme in algorithmes:
                liste_copie = liste[:]
                temps = mesurer_temps(algorithme, liste_copie)
                print(f"{algorithme.__name__} - Temps d'exécution : {temps:.5f} secondes")
            print("-" * 40)
            </code></pre>
        
            <h4>3. Analyse des Résultats :</h4>
            <p>Les élèves doivent observer et analyser les résultats obtenus. Le tri rapide devrait être le plus performant pour les grandes listes, tandis que les tris par sélection et par insertion deviendront rapidement très lents.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion (15 min)</h3>
        
            <h4>Comparaison des Algorithmes de Tri :</h4>
            <ul>
                <li><strong>Tri par sélection :</strong> Simple mais inefficace pour les grandes listes. Complexité : O(n²).</li>
                <li><strong>Tri par insertion :</strong> Utile pour les petites listes ou les listes presque triées. Complexité : O(n²).</li>
                <li><strong>QuickSort :</strong> Très performant pour les grandes listes grâce à sa complexité moyenne de O(n log n).</li>
            </ul>
        
            <h4>Discussion Finale :</h4>
            <p>En fonction des résultats, discutez avec les élèves de la meilleure approche à adopter pour trier des listes de différentes tailles. Soulignez que certains algorithmes conviennent mieux aux petits ensembles de données, tandis que d'autres sont plus adaptés aux grands ensembles.</p>
        </section>

        <section id="session28" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 28 : Introduction au tri par tas (Heapsort)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves vont découvrir l’algorithme de tri par tas (Heapsort), un algorithme de tri efficace utilisant une structure de données appelée tas (heap). Ils apprendront à construire un tas, à extraire les éléments dans un ordre trié, et à utiliser cette approche pour trier une liste de nombres.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction au Tri par Tas</h3>
            
            <h4>1. Qu'est-ce qu'un Tas (Heap) ?</h4>
            <p>Un <strong>tas</strong> (heap) est une structure de données basée sur un arbre binaire. Dans un tas binaire :</p>
            <ul>
                <li>Chaque nœud parent a une valeur supérieure ou égale à celle de ses enfants dans un <strong>max-heap</strong>.</li>
                <li>Chaque nœud parent a une valeur inférieure ou égale à celle de ses enfants dans un <strong>min-heap</strong>.</li>
            </ul>
            <p>Le tri par tas utilise un max-heap (ou min-heap) pour organiser les éléments de manière à pouvoir les extraire dans un ordre trié.</p>
        
            <h4>2. Principe de Fonctionnement du Heapsort</h4>
            <p>L’algorithme Heapsort fonctionne en deux étapes principales :</p>
            <ul>
                <li><strong>Étape 1 :</strong> Construire un tas (max-heap) à partir de la liste de nombres.</li>
                <li><strong>Étape 2 :</strong> Extraire le maximum du tas et le placer à la fin de la liste, puis ajuster le tas pour maintenir sa structure. Cette opération est répétée jusqu’à ce que tous les éléments soient extraits.</li>
            </ul>
        
            <p>En fin de compte, la liste est triée en ordre croissant (ou décroissant) en fonction de la structure de tas utilisée.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étapes de Construction du Tas (30 min)</h3>
        
            <h4>1. Transformation d'une Liste en Max-Heap</h4>
            <p>Pour convertir une liste de nombres en max-heap, on applique une opération appelée <strong>heapification</strong> :</p>
            <ul>
                <li>On commence par le dernier nœud non-feuille de l'arbre et on vérifie si sa valeur est supérieure à celle de ses enfants.</li>
                <li>Si ce nœud est plus petit que l'un de ses enfants, on échange leurs valeurs et on continue l'opération de heapification sur le sous-arbre affecté.</li>
            </ul>
        
            <p>Voici un exemple de liste que nous allons transformer en max-heap : [4, 10, 3, 5, 1]</p>
        
            <pre><code>Avant heapification :  4, 10, 3, 5, 1
        Après heapification : 10, 5, 3, 4, 1
            </code></pre>
        
            <h4>2. Implémentation de la Fonction de Heapification en Python</h4>
            <p>Voici un exemple de code Python pour appliquer la fonction de heapification sur un tableau :</p>
        
            <pre><code>def heapify(liste, n, i):
            plus_grand = i  # initialiser le plus grand élément comme racine
            gauche = 2 * i + 1  # fils gauche
            droite = 2 * i + 2  # fils droit
        
            # Vérifier si le fils gauche est plus grand que la racine
            if gauche < n and liste[gauche] > liste[plus_grand]:
                plus_grand = gauche
        
            # Vérifier si le fils droit est plus grand que le plus grand actuel
            if droite < n and liste[droite] > liste[plus_grand]:
                plus_grand = droite
        
            # Si le plus grand n'est pas la racine
            if plus_grand != i:
                liste[i], liste[plus_grand] = liste[plus_grand], liste[i]  # échanger
                heapify(liste, n, plus_grand)  # continuer la heapification
            </code></pre>
        
            <p>La fonction <code>heapify</code> prend en paramètres la liste, sa taille <code>n</code>, et l’indice <code>i</code> du nœud à heapifier. Elle vérifie si le nœud actuel est le plus grand, et si ce n’est pas le cas, elle échange les valeurs et appelle récursivement la fonction.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Algorithme Complet du Heapsort (45 min)</h3>
        
            <h4>1. Étape 1 : Construire le Max-Heap</h4>
            <p>Nous allons construire un max-heap à partir de la liste en appliquant la fonction <code>heapify</code> sur chaque nœud, en commençant par le dernier nœud non-feuille jusqu'à la racine.</p>
        
            <pre><code>def construire_tas(liste):
            n = len(liste)
            for i in range(n // 2 - 1, -1, -1):
                heapify(liste, n, i)
            </code></pre>
        
            <h4>2. Étape 2 : Tri par Extraction</h4>
            <p>Une fois le tas construit, nous procédons au tri. Nous échangeons la racine (plus grand élément) avec le dernier élément de la liste, puis réduisons la taille du tas et réappliquons <code>heapify</code> pour maintenir la structure du tas.</p>
        
            <pre><code>def heapsort(liste):
            n = len(liste)
            construire_tas(liste)
            
            # Extraire un à un les éléments du tas
            for i in range(n - 1, 0, -1):
                liste[i], liste[0] = liste[0], liste[i]  # échanger
                heapify(liste, i, 0)  # réappliquer heapify pour maintenir le tas
            </code></pre>
        
            <h4>3. Code Complet de l’Algorithme Heapsort</h4>
            <p>Voici le code complet pour trier une liste de nombres en utilisant Heapsort :</p>
        
            <pre><code>def heapify(liste, n, i):
            plus_grand = i
            gauche = 2 * i + 1
            droite = 2 * i + 2
        
            if gauche < n and liste[gauche] > liste[plus_grand]:
                plus_grand = gauche
            if droite < n and liste[droite] > liste[plus_grand]:
                plus_grand = droite
        
            if plus_grand != i:
                liste[i], liste[plus_grand] = liste[plus_grand], liste[i]
                heapify(liste, n, plus_grand)
        
        def construire_tas(liste):
            n = len(liste)
            for i in range(n // 2 - 1, -1, -1):
                heapify(liste, n, i)
        
        def heapsort(liste):
            n = len(liste)
            construire_tas(liste)
            for i in range(n - 1, 0, -1):
                liste[i], liste[0] = liste[0], liste[i]
                heapify(liste, i, 0)
        
        # Exemple d'utilisation
        liste = [4, 10, 3, 5, 1]
        heapsort(liste)
        print("Liste triée :", liste)
            </code></pre>
        
            <h4>Explication Étape par Étape du Code :</h4>
            <ul>
                <li><code>heapify</code> organise une partie du tableau pour en faire un tas valide.</li>
                <li><code>construire_tas</code> crée un max-heap sur l’ensemble de la liste.</li>
                <li><code>heapsort</code> utilise le max-heap pour extraire les éléments dans un ordre décroissant et les organiser de manière triée.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Défi Pratique pour les Élèves (20 min)</h3>
            <ul>
                <li><strong>Étape 1 :</strong> Utiliser Heapsort pour trier une liste de scores de joueurs dans un jeu, du plus haut au plus bas.</li>
                <li><strong>Étape 2 :</strong> Modifier l'algorithme pour qu'il trie les scores du plus bas au plus haut (utiliser un min-heap).</li>
                <li><strong>Étape 3 :</strong> Mesurer le temps d'exécution de Heapsort par rapport à d'autres algorithmes de tri comme le tri par sélection ou le tri par insertion.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Analyse de la Complexité (10 min)</h3>
        
            <h4>Complexité de Heapsort :</h4>
            <ul>
                <li><strong>Complexité en temps :</strong> Heapsort a une complexité temporelle de <code>O(n log n)</code> dans tous les cas, car la construction du tas prend <code>O(n)</code> et chaque extraction prend <code>O(log n)</code>.</li>
                <li><strong>Complexité en espace :</strong> Heapsort est un tri <strong>en place</strong>, ce qui signifie qu’il ne nécessite pas de mémoire supplémentaire.</li>
            </ul>
        
            <h4>Discussion Finale :</h4>
            <p>Heapsort est un algorithme de tri efficace et stable qui utilise un tas pour organiser les éléments de manière ordonnée. Contrairement au tri rapide (Quicksort), Heapsort a une complexité temporelle garantie de <code>O(n log n)</code> dans le pire des cas, ce qui le rend particulièrement adapté pour des jeux ou des applications où le tri des scores ou des objets est requis de manière fiable.</p>
        </section>

        <section id="session29" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 29 : Pratique - Utilisation du Heapsort pour organiser un inventaire dans un jeu vidéo</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront à utiliser l'algorithme de tri Heapsort pour organiser un inventaire dans un jeu vidéo. L'objectif est de comprendre l'algorithme Heapsort et de l'appliquer à un cas pratique en classant les objets d'inventaire par ordre de priorité, comme le poids ou la valeur.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction au Contexte du Jeu Vidéo</h3>
        
            <h4>Contexte de l'Inventaire dans un Jeu Vidéo :</h4>
            <p>Dans de nombreux jeux vidéo, les joueurs possèdent un inventaire contenant divers objets (armes, potions, ressources) qu’ils peuvent trier par ordre de priorité pour faciliter la gestion. Par exemple :</p>
            <ul>
                <li>Les objets peuvent être triés par <strong>poids</strong> (les objets les plus lourds en premier) pour gérer l'espace d'inventaire.</li>
                <li>Les objets peuvent être triés par <strong>valeur</strong> (les objets les plus précieux en premier) pour optimiser les gains lorsqu'on vend des objets.</li>
            </ul>
            <p>Pour effectuer ce tri efficacement, nous utiliserons l'algorithme de tri Heapsort.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Explication de Heapsort (20 min)</h3>
        
            <h4>1. Principe de Heapsort :</h4>
            <p>Heapsort est un algorithme de tri basé sur la structure de données appelée <strong>tas (heap)</strong>, qui est un type de <em>file de priorité</em>. L’algorithme Heapsort suit ces étapes :</p>
            <ul>
                <li>Créer un tas à partir de la liste d'éléments (objets d'inventaire).</li>
                <li>Extraire les éléments du tas un par un pour obtenir une liste triée.</li>
            </ul>
        
            <h4>2. Types de Tas :</h4>
            <ul>
                <li><strong>Max-Heap :</strong> Le plus grand élément est toujours en haut. Utilisé pour trier par ordre décroissant.</li>
                <li><strong>Min-Heap :</strong> Le plus petit élément est toujours en haut. Utilisé pour trier par ordre croissant.</li>
            </ul>
        
            <h4>3. Utilisation de Heapsort :</h4>
            <p>En utilisant Heapsort, nous pouvons trier les objets d'inventaire dans l'ordre souhaité (par exemple, du plus lourd au plus léger ou du plus précieux au moins précieux).</p>
        
            <h4>Pseudo-code de Heapsort :</h4>
            <pre><code>def heapsort(liste):
            # Construire le Max-Heap
            for i in range(len(liste) // 2 - 1, -1, -1):
                entasser(liste, len(liste), i)
            
            # Extraire les éléments un par un
            for i in range(len(liste) - 1, 0, -1):
                liste[i], liste[0] = liste[0], liste[i]  # Échanger
                entasser(liste, i, 0)
            
        def entasser(liste, taille, i):
            plus_grand = i  # Initialiser le plus grand comme racine
            gauche = 2 * i + 1
            droite = 2 * i + 2
            
            # Vérifier si le fils gauche est plus grand que la racine
            if gauche < taille and liste[gauche] > liste[plus_grand]:
                plus_grand = gauche
            
            # Vérifier si le fils droit est plus grand que le plus grand actuel
            if droite < taille and liste[droite] > liste[plus_grand]:
                plus_grand = droite
            
            # Changer la racine si nécessaire
            if plus_grand != i:
                liste[i], liste[plus_grand] = liste[plus_grand], liste[i]
                entasser(liste, taille, plus_grand)
            </code></pre>
        
            <h4>Explication Étape par Étape :</h4>
            <ul>
                <li><strong>Construction du tas :</strong> L'algorithme commence par transformer la liste en un tas maximal (Max-Heap).</li>
                <li><strong>Extraction des éléments :</strong> À chaque étape, l’élément le plus grand est extrait du tas et placé à la fin de la liste.</li>
                <li><strong>Réorganisation :</strong> Le tas est réorganisé après chaque extraction pour maintenir sa structure.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique : Organisation de l'Inventaire d’un Jeu (45 min)</h3>
        
            <h4>1. Initialiser l'Inventaire :</h4>
            <p>Dans cet exemple, nous allons créer un inventaire de jeu contenant plusieurs objets avec des attributs tels que le <strong>nom</strong>, le <strong>poids</strong> et la <strong>valeur</strong>.</p>
            <pre><code>inventaire = [
            {"nom": "épée", "poids": 5, "valeur": 150},
            {"nom": "potion", "poids": 1, "valeur": 50},
            {"nom": "bouclier", "poids": 7, "valeur": 100},
            {"nom": "pierre précieuse", "poids": 2, "valeur": 500},
            {"nom": "herbes", "poids": 1, "valeur": 20}
        ]
            </code></pre>
        
            <h4>2. Fonction Heapsort pour Trier l’Inventaire :</h4>
            <p>Nous allons maintenant adapter l'algorithme Heapsort pour trier l'inventaire en fonction d'un attribut, comme le poids ou la valeur.</p>
        
            <pre><code>def trier_inventaire_par_valeur(inventaire):
            def entasser(liste, taille, i):
                plus_grand = i
                gauche = 2 * i + 1
                droite = 2 * i + 2
                
                if gauche < taille and liste[gauche]["valeur"] > liste[plus_grand]["valeur"]:
                    plus_grand = gauche
                if droite < taille and liste[droite]["valeur"] > liste[plus_grand]["valeur"]:
                    plus_grand = droite
                
                if plus_grand != i:
                    liste[i], liste[plus_grand] = liste[plus_grand], liste[i]
                    entasser(liste, taille, plus_grand)
            
            # Construire le Max-Heap
            for i in range(len(inventaire) // 2 - 1, -1, -1):
                entasser(inventaire, len(inventaire), i)
            
            # Trier
            for i in range(len(inventaire) - 1, 0, -1):
                inventaire[i], inventaire[0] = inventaire[0], inventaire[i]
                entasser(inventaire, i, 0)
        
        # Trier l'inventaire par valeur
        trier_inventaire_par_valeur(inventaire)
        print("Inventaire trié par valeur décroissante :", inventaire)
            </code></pre>
        
            <h4>3. Explication du Code :</h4>
            <ul>
                <li>La fonction <code>trier_inventaire_par_valeur()</code> crée un Max-Heap en fonction de la valeur de chaque objet.</li>
                <li>Chaque objet est extrait et placé en fin de liste, garantissant ainsi un tri par ordre décroissant de valeur.</li>
                <li>On peut facilement adapter le code pour trier l’inventaire en fonction d’autres attributs, comme le poids.</li>
            </ul>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez la fonction pour trier l’inventaire en fonction du <code>poids</code> plutôt que de la <code>valeur</code>.</li>
                <li><strong>Étape 2 :</strong> Ajoutez une option pour trier l’inventaire en ordre croissant ou décroissant, en utilisant un Min-Heap ou un Max-Heap.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion (15 min)</h3>
            <p>À la fin de cette séance, les élèves auront appris à utiliser Heapsort pour organiser un inventaire dans un jeu vidéo. Ils comprendront l'importance d'un tri efficace dans un jeu où l’organisation de l’inventaire joue un rôle clé.</p>
        
            <h4>Comparaison avec d'autres Algorithmes de Tri :</h4>
            <ul>
                <li><strong>Heapsort :</strong> Complexité en temps <code>O(n log n)</code>, utile pour des tri en place et pour gérer les priorités.</li>
                <li><strong>Quicksort :</strong> Bien que performant, il est moins adapté pour des structures de file de priorité comme celles d’un inventaire.</li>
            </ul>
        
            <h4>Applications Pratiques :</h4>
            <ul>
                <li>Organisation de l’inventaire dans les jeux RPG pour prioriser les objets en fonction de leur importance.</li>
                <li>Gestion des ressources dans des jeux de stratégie, en triant les ressources par quantité ou valeur.</li>
            </ul>
        </section>

        <section id="session30" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 30 : Analyse de la Complexité du Heapsort et de ses Applications</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves vont explorer le tri par tas (Heapsort) en analysant sa complexité et en comprenant son fonctionnement en pratique. Ils découvriront comment cet algorithme s’applique efficacement dans différents contextes, en particulier dans la gestion de files prioritaires et la sélection des éléments de plus grande valeur.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction au Heapsort (20 min)</h3>
            <p>Heapsort est un algorithme de tri qui utilise une structure de données appelée <strong>tas binaire</strong> (ou heap). Il fonctionne en construisant un tas, puis en retirant l’élément de plus grande (ou de plus petite) valeur de ce tas pour le placer en fin de liste.</p>
        
            <h4>1. Notions de Base sur le Tas Binaire :</h4>
            <ul>
                <li><strong>Tas binaire (Heap) :</strong> Une structure d'arbre binaire où chaque nœud est supérieur (max-heap) ou inférieur (min-heap) à ses enfants.</li>
                <li><strong>Max-heap :</strong> Le plus grand élément est situé à la racine de l’arbre.</li>
                <li><strong>Min-heap :</strong> Le plus petit élément est situé à la racine de l’arbre.</li>
            </ul>
            <p>Pour implémenter Heapsort, nous allons utiliser un max-heap, ce qui signifie que l'élément de plus grande valeur est toujours à la racine.</p>
        
            <h4>2. Principe de Fonctionnement du Heapsort :</h4>
            <p>Heapsort fonctionne en deux étapes :</p>
            <ul>
                <li><strong>Étape 1 :</strong> Construire un max-heap à partir des éléments de la liste.</li>
                <li><strong>Étape 2 :</strong> Extraire successivement le maximum du tas, puis replacer le dernier élément à la racine et ajuster la structure pour maintenir la propriété de tas.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Analyse de la Complexité de Heapsort (30 min)</h3>
        
            <h4>1. Complexité de la Construction du Tas :</h4>
            <p>Pour construire un max-heap, on utilise un processus d’<strong>ajustement</strong> (appelé "heapify") qui assure que chaque sous-arbre respecte la propriété de tas. Construire un tas à partir d'une liste de <em>n</em> éléments a une complexité en <strong>O(n)</strong>.</p>
        
            <h4>2. Complexité de l'Extraction et du Tri :</h4>
            <p>Après la construction du tas, chaque extraction de l’élément maximal a une complexité de <strong>O(log n)</strong>, car elle nécessite de réajuster le tas. Pour trier <em>n</em> éléments, on effectue <em>n</em> extractions, chacune prenant <em>O(log n)</em> temps.</p>
            <p><strong>Complexité totale du tri Heapsort :</strong> <code>O(n log n)</code>.</p>
        
            <h4>3. Comparaison avec d’autres Algorithmes de Tri :</h4>
            <p>Heapsort est souvent comparé avec d'autres algorithmes de tri :</p>
            <ul>
                <li><strong>Quicksort :</strong> Généralement plus rapide en pratique avec une complexité moyenne de <code>O(n log n)</code>, mais sa complexité dans le pire des cas est <code>O(n²)</code>.</li>
                <li><strong>Mergesort :</strong> Stable et de complexité <code>O(n log n)</code>, mais nécessite de l'espace supplémentaire, contrairement à Heapsort.</li>
            </ul>
        
            <h4>Applications Pratiques de Heapsort :</h4>
            <ul>
                <li><strong>Files prioritaires :</strong> Heapsort est utilisé pour organiser des files où les éléments les plus prioritaires doivent être traités en premier.</li>
                <li><strong>Tri de grands ensembles de données :</strong> Heapsort est utile dans les systèmes embarqués, car il ne nécessite pas d’espace supplémentaire pour le tri.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation de Heapsort (30 min)</h3>
        
            <h4>1. Fonction de Réajustement (Heapify) :</h4>
            <p>La fonction <code>heapify</code> assure que chaque nœud d’un sous-arbre est supérieur à ses enfants. Cette fonction est essentielle pour maintenir la propriété de tas après chaque extraction.</p>
            <pre><code>def heapify(arr, n, i):
            largest = i  # Initialise le plus grand comme racine
            left = 2 * i + 1  # Enfant gauche
            right = 2 * i + 2  # Enfant droit
        
            # Si l'enfant gauche est plus grand que la racine
            if left < n and arr[left] > arr[largest]:
                largest = left
        
            # Si l'enfant droit est plus grand que le plus grand actuel
            if right < n and arr[right] > arr[largest]:
                largest = right
        
            # Si le plus grand n'est pas la racine
            if largest != i:
                arr[i], arr[largest] = arr[largest], arr[i]  # Échange
                heapify(arr, n, largest)  # Réajuster récursivement
            </code></pre>
        
            <h4>2. Fonction de Tri (Heapsort) :</h4>
            <p>La fonction <code>heapsort</code> construit d'abord un max-heap, puis extrait successivement le plus grand élément en l’ajoutant à la fin de la liste triée.</p>
            <pre><code>def heapsort(arr):
            n = len(arr)
        
            # Construire un max-heap
            for i in range(n // 2 - 1, -1, -1):
                heapify(arr, n, i)
        
            # Extraire les éléments du tas
            for i in range(n - 1, 0, -1):
                arr[i], arr[0] = arr[0], arr[i]  # Déplacer la racine à la fin
                heapify(arr, i, 0)  # Réajuster le tas
            </code></pre>
        
            <h4>3. Exemple d’Utilisation :</h4>
            <p>Testons Heapsort avec une liste d’entiers :</p>
            <pre><code># Liste à trier
        arr = [12, 11, 13, 5, 6, 7]
        print("Liste initiale :", arr)
        
        # Tri avec Heapsort
        heapsort(arr)
        print("Liste triée :", arr)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Défis Pratiques pour les Élèves (30 min)</h3>
            <ul>
                <li><strong>Défi 1 :</strong> Modifiez la fonction <code>heapify</code> pour que le tas devienne un <strong>min-heap</strong>, où le plus petit élément est toujours à la racine.</li>
                <li><strong>Défi 2 :</strong> Utilisez Heapsort pour trier une liste de tuples, où chaque tuple représente un joueur avec son score. L'objectif est de trier les joueurs par ordre décroissant de score.</li>
                <li><strong>Défi 3 :</strong> Dans une file de priorité, certains éléments doivent être traités avant d’autres. Utilisez Heapsort pour implémenter une file de priorité simple et trier les éléments en fonction de leur importance.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Réflexion (10 min)</h3>
            <p>En conclusion, Heapsort est un algorithme de tri efficace avec une complexité de <code>O(n log n)</code>, similaire à d'autres algorithmes de tri comme Quicksort et Mergesort, mais avec ses propres avantages. Sa structure en tas le rend particulièrement adapté pour des applications comme les files prioritaires, où les éléments doivent être traités par priorité.</p>
            
            <p>Les élèves auront appris à construire et manipuler un tas, à utiliser Heapsort pour trier des listes, et à comprendre son efficacité dans divers contextes.</p>
        </section>

        <section id="session31" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 31 : Introduction au Tri Fusion (Merge Sort)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves découvriront le fonctionnement de l'algorithme de tri fusion, un algorithme de tri efficace basé sur le principe de "diviser pour régner". Cette séance leur permettra d'implémenter l'algorithme en utilisant la récursivité et de comprendre pourquoi il est plus performant que des méthodes de tri plus simples, comme le tri par sélection ou par insertion.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction au Tri Fusion (20 min)</h3>
        
            <h4>Principe du Tri Fusion :</h4>
            <p>Le tri fusion (ou Merge Sort) est un algorithme de tri basé sur une stratégie de <strong>diviser pour régner</strong>. L'idée est de diviser le tableau en deux sous-tableaux, de trier chaque sous-tableau de manière récursive, puis de fusionner les deux sous-tableaux triés pour obtenir un tableau final trié.</p>
        
            <h4>Étapes de l'algorithme :</h4>
            <ol>
                <li><strong>Diviser :</strong> Si le tableau a plus d'un élément, le diviser en deux sous-tableaux de tailles à peu près égales.</li>
                <li><strong>Trier :</strong> Appliquer récursivement le tri fusion sur chaque sous-tableau.</li>
                <li><strong>Fusionner :</strong> Fusionner les deux sous-tableaux triés pour obtenir un tableau trié.</li>
            </ol>
        
            <h4>Illustration Visuelle :</h4>
            <p>Pour illustrer, imaginons un tableau initial : <code>[38, 27, 43, 3, 9, 82, 10]</code>. Le tri fusion fonctionnerait de la manière suivante :</p>
            <pre><code>
        [38, 27, 43, 3, 9, 82, 10]
                  |
            -----------------
            |               |
        [38, 27, 43]     [3, 9, 82, 10]
               |              |
            ------         ------
            |    |         |    |
        [38] [27, 43] [3, 9] [82, 10]
        ...
            </code></pre>
        
            <p>Chaque sous-tableau est divisé jusqu’à obtenir des éléments individuels, puis ils sont fusionnés pour reconstituer le tableau trié.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Décomposition de l'Algorithme (30 min)</h3>
        
            <h4>1. Cas de Base et Cas Récursif :</h4>
            <p>L'algorithme utilise la récursivité pour diviser le tableau :</p>
            <ul>
                <li><strong>Cas de base :</strong> Si le tableau contient 1 ou 0 élément, il est déjà trié.</li>
                <li><strong>Cas récursif :</strong> Diviser le tableau en deux, appliquer le tri fusion sur chaque sous-tableau, puis fusionner.</li>
            </ul>
        
            <h4>Fonction de Fusion :</h4>
            <p>La fonction de fusion combine deux sous-tableaux triés en un seul tableau trié :</p>
            <ul>
                <li>On compare les premiers éléments des deux sous-tableaux.</li>
                <li>L'élément le plus petit est ajouté au tableau de fusion.</li>
                <li>On répète jusqu'à ce que tous les éléments soient fusionnés.</li>
            </ul>
        
            <h4>Pseudo-code du Tri Fusion :</h4>
            <pre><code>def tri_fusion(tableau):
            if len(tableau) <= 1:  # Cas de base
                return tableau
            
            milieu = len(tableau) // 2  # Trouver le milieu
            gauche = tri_fusion(tableau[:milieu])  # Trier le sous-tableau gauche
            droite = tri_fusion(tableau[milieu:])  # Trier le sous-tableau droit
            
            return fusion(gauche, droite)
        
        def fusion(gauche, droite):
            resultat = []
            while gauche and droite:
                if gauche[0] < droite[0]:
                    resultat.append(gauche.pop(0))
                else:
                    resultat.append(droite.pop(0))
            resultat.extend(gauche or droite)  # Ajouter les éléments restants
            return resultat
            </code></pre>
        
            <h4>Explication du Pseudo-code :</h4>
            <ul>
                <li><code>tri_fusion</code> est une fonction récursive qui divise le tableau en deux parties égales.</li>
                <li>La fonction <code>fusion</code> fusionne les deux sous-tableaux triés en comparant les éléments un par un.</li>
                <li>Si le tableau ne contient qu'un seul élément ou est vide, il est retourné tel quel (cas de base).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation du Tri Fusion (40 min)</h3>
        
            <h4>Étape 1 : Diviser et Fusionner le Tableau</h4>
            <p>Voici une implémentation complète de l'algorithme de tri fusion en Python :</p>
            <pre><code>def tri_fusion(tableau):
            if len(tableau) <= 1:
                return tableau
            
            milieu = len(tableau) // 2
            gauche = tri_fusion(tableau[:milieu])
            droite = tri_fusion(tableau[milieu:])
            
            return fusion(gauche, droite)
        
        def fusion(gauche, droite):
            resultat = []
            while gauche and droite:
                if gauche[0] < droite[0]:
                    resultat.append(gauche.pop(0))
                else:
                    resultat.append(droite.pop(0))
            resultat.extend(gauche or droite)
            return resultat
        
        # Exemple d'utilisation
        tableau = [38, 27, 43, 3, 9, 82, 10]
        print("Tableau trié :", tri_fusion(tableau))
            </code></pre>
        
            <h4>Étape 2 : Tester le Tri Fusion avec des Exemples</h4>
            <p>Encouragez les élèves à tester la fonction <code>tri_fusion</code> avec plusieurs exemples pour vérifier qu'elle fonctionne correctement et comprendre le processus de fusion en pratique.</p>
        
            <h4>Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Modifiez la fonction <code>fusion</code> pour afficher chaque étape de fusion.</li>
                <li><strong>Étape 2 :</strong> Testez l'algorithme avec des tableaux plus grands et analysez le temps de traitement.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Complexité et Avantages du Tri Fusion (20 min)</h3>
        
            <h4>Complexité Temporelle :</h4>
            <p>Le tri fusion a une complexité en temps de <code>O(n log n)</code>, ce qui en fait un algorithme de tri plus efficace que les méthodes de tri simples (comme le tri par sélection) dans la plupart des cas.</p>
        
            <h4>Avantages du Tri Fusion :</h4>
            <ul>
                <li><strong>Efficace :</strong> La complexité de <code>O(n log n)</code> rend le tri fusion rapide même pour des tableaux relativement grands.</li>
                <li><strong>Stable :</strong> Il conserve l’ordre relatif des éléments égaux, ce qui est important dans certaines applications.</li>
            </ul>
        
            <h4>Inconvénients du Tri Fusion :</h4>
            <ul>
                <li><strong>Utilisation de mémoire :</strong> Le tri fusion nécessite de la mémoire supplémentaire pour stocker les sous-tableaux temporaires, ce qui peut être un inconvénient dans des environnements à mémoire limitée.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Réflexion</h3>
            <p>À la fin de cette séance, les élèves devraient comprendre le fonctionnement de l’algorithme de tri fusion, ses avantages en termes d’efficacité et sa complexité temporelle. Ils auront appris à utiliser la récursivité pour diviser un problème en sous-problèmes et à les fusionner pour obtenir une solution complète.</p>
            <p>Le tri fusion est un exemple parfait d’algorithme diviseur qui montre comment la récursivité peut simplifier la résolution de problèmes complexes.</p>
        </section>

        <section id="session32" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 32 : Pratique - Implémentation du Tri Fusion pour Classer des Mangas par Popularité</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront et implémenteront l’algorithme de tri fusion (Merge Sort) pour organiser une liste de mangas selon leur popularité. Ce tri permettra de comprendre la récursivité dans les algorithmes de tri et d'explorer une méthode de tri efficace pour de grandes quantités de données.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte du Projet : Classement des Mangas par Popularité</h3>
        
            <h4>Contexte :</h4>
            <p>Imaginez que vous êtes responsable d'un site de mangas et que vous devez classer ces mangas en fonction de leur popularité (nombre de lecteurs ou notes moyennes). Pour cette tâche, nous allons implémenter un tri fusion qui organisera les mangas du plus populaire au moins populaire.</p>
        
            <h4>Définition de l’Algorithme de Tri Fusion :</h4>
            <p>Le tri fusion est un algorithme de tri basé sur le principe de "diviser pour régner". Cet algorithme est efficace pour trier de grandes listes car il divise la liste en sous-listes, trie chaque sous-liste, puis fusionne les sous-listes triées.</p>
        
            <h4>Concepts Clés :</h4>
            <ul>
                <li><strong>Diviser :</strong> Diviser la liste de mangas en deux moitiés jusqu’à obtenir des sous-listes d'un seul élément.</li>
                <li><strong>Fusionner :</strong> Fusionner les sous-listes en une seule liste triée en comparant les éléments.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Explication de l'Algorithme de Tri Fusion (20 min)</h3>
        
            <h4>Étapes du Tri Fusion :</h4>
            <p>L'algorithme de tri fusion suit trois étapes principales :</p>
            <ol>
                <li><strong>Diviser :</strong> La liste est divisée en deux sous-listes égales (ou presque égales) jusqu’à ce qu’il ne reste plus qu’un seul élément par sous-liste.</li>
                <li><strong>Trier :</strong> Les sous-listes sont considérées comme triées si elles contiennent un seul élément.</li>
                <li><strong>Fusionner :</strong> Fusionner les sous-listes triées pour obtenir une seule liste triée.</li>
            </ol>
        
            <h4>Exemple Visuel :</h4>
            <p>Imaginons une liste de popularité de mangas, où chaque nombre représente le nombre de lecteurs :</p>
            <pre><code>[1200, 4500, 3000, 2500, 3900]</code></pre>
            <p>L'algorithme divise cette liste en sous-listes, trie chaque sous-liste, puis les fusionne de manière triée :</p>
            <pre><code>[1200, 4500, 3000, 2500, 3900]
        => [1200, 4500, 3000]  et  [2500, 3900]
        => [1200, 4500] et [3000] et [2500, 3900]
        => [1200] et [4500] et [3000] et [2500] et [3900]
        => [1200, 4500] et [3000] et [2500, 3900]
        => [1200, 3000, 4500] et [2500, 3900]
        => [1200, 2500, 3000, 3900, 4500]
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation de l'Algorithme de Tri Fusion (30 min)</h3>
        
            <h4>Code de l'Algorithme de Tri Fusion en Python :</h4>
            <p>Nous allons maintenant implémenter le tri fusion en Python pour trier une liste de mangas en fonction de leur popularité.</p>
        
            <pre><code>def tri_fusion(liste):
            # Cas de base : si la liste est vide ou ne contient qu'un seul élément
            if len(liste) &lt;= 1:
                return liste
            
            # Diviser la liste en deux moitiés
            milieu = len(liste) // 2
            gauche = liste[:milieu]
            droite = liste[milieu:]
            
            # Appliquer le tri fusion récursivement sur chaque moitié
            gauche = tri_fusion(gauche)
            droite = tri_fusion(droite)
            
            # Fusionner les deux moitiés triées
            return fusion(gauche, droite)
        
        def fusion(gauche, droite):
            resultat = []
            i = j = 0
            
            # Comparer les éléments des deux sous-listes et les fusionner dans la liste résultat
            while i &lt; len(gauche) and j &lt; len(droite):
                if gauche[i] &lt;= droite[j]:
                    resultat.append(gauche[i])
                    i += 1
                else:
                    resultat.append(droite[j])
                    j += 1
            
            # Ajouter les éléments restants
            resultat.extend(gauche[i:])
            resultat.extend(droite[j:])
            
            return resultat
            </code></pre>
        
            <h4>Étape par Étape :</h4>
            <ul>
                <li>La fonction <code>tri_fusion()</code> divise la liste en deux parties et appelle récursivement le tri fusion sur chacune d’elles.</li>
                <li>La fonction <code>fusion()</code> prend deux sous-listes triées et les fusionne en une seule liste triée.</li>
                <li>Lorsque toutes les sous-listes sont fusionnées, la liste complète est triée.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique : Classement des Mangas par Popularité (30 min)</h3>
        
            <h4>1. Préparer la Liste des Mangas :</h4>
            <p>Créez une liste de mangas, chacun ayant une popularité exprimée par un nombre. Voici un exemple :</p>
            <pre><code>mangas = [
            {"titre": "One Piece", "popularite": 4500},
            {"titre": "Naruto", "popularite": 3900},
            {"titre": "Bleach", "popularite": 2500},
            {"titre": "Dragon Ball", "popularite": 3000},
            {"titre": "Attack on Titan", "popularite": 1200}
        ]
            </code></pre>
        
            <h4>2. Adapter le Tri Fusion pour Trier les Mangas :</h4>
            <p>Modifiez l’algorithme pour trier les mangas en fonction de la clé <code>popularite</code>.</p>
        
            <pre><code>def tri_fusion_mangas(liste):
            if len(liste) &lt;= 1:
                return liste
            
            milieu = len(liste) // 2
            gauche = liste[:milieu]
            droite = liste[milieu:]
            
            gauche = tri_fusion_mangas(gauche)
            droite = tri_fusion_mangas(droite)
            
            return fusion_mangas(gauche, droite)
        
        def fusion_mangas(gauche, droite):
            resultat = []
            i = j = 0
            
            while i &lt; len(gauche) and j &lt; len(droite):
                if gauche[i]["popularite"] &gt;= droite[j]["popularite"]:
                    resultat.append(gauche[i])
                    i += 1
                else:
                    resultat.append(droite[j])
                    j += 1
            
            resultat.extend(gauche[i:])
            resultat.extend(droite[j:])
            
            return resultat
        
        # Trier les mangas par popularité
        mangas_tries = tri_fusion_mangas(mangas)
        for manga in mangas_tries:
            print(f"{manga['titre']} - Popularité : {manga['popularite']}")
            </code></pre>
        
            <h4>Explication :</h4>
            <ul>
                <li>La fonction <code>tri_fusion_mangas()</code> applique le tri fusion sur une liste de mangas.</li>
                <li>La fonction <code>fusion_mangas()</code> fusionne deux sous-listes de mangas en fonction de leur popularité.</li>
            </ul>
        
            <h4>Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Ajoutez des mangas supplémentaires avec des valeurs de popularité aléatoires.</li>
                <li><strong>Étape 2 :</strong> Modifiez l’algorithme pour trier les mangas en ordre croissant de popularité.</li>
                <li><strong>Étape 3 :</strong> Testez l’efficacité du tri fusion pour des listes de 1000 mangas ou plus (générées aléatoirement).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion (10 min)</h3>
            <p>À la fin de cette séance, les élèves comprendront comment utiliser le tri fusion pour trier une liste complexe. Ils auront également appris à adapter l’algorithme pour trier selon une clé spécifique, ici la popularité des mangas. Nous terminerons par une discussion sur l’efficacité du tri fusion, particulièrement utile pour des listes de grandes tailles en raison de sa complexité en temps <code>O(n log n)</code>.</p>
        </section>

        <section id="session33" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 33 : Étude comparative des algorithmes de tri avancés (Quicksort, Heapsort, Merge Sort)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves vont explorer et comparer trois algorithmes de tri avancés : Quicksort, Heapsort et Merge Sort. L'objectif est de comprendre leurs différences en termes de performances, d'implémentation et de cas d'utilisation. Les élèves vont également mettre en pratique ces algorithmes et observer leurs comportements sur différents jeux de données.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Algorithmes de Tri Avancés</h3>
        
            <p>Dans cette séance, nous allons comparer trois algorithmes de tri populaires et efficaces pour trier de grandes quantités de données. Ces algorithmes sont souvent utilisés en programmation en raison de leur efficacité et de leurs caractéristiques différentes :</p>
            <ul>
                <li><strong>Quicksort :</strong> algorithme de tri rapide basé sur un pivot et une partition des données.</li>
                <li><strong>Heapsort :</strong> utilise une structure de tas (heap) pour organiser les éléments et trier le tableau.</li>
                <li><strong>Merge Sort :</strong> utilise une approche de division et fusion (merge) pour trier les données.</li>
            </ul>
        
            <h4>Cas d'utilisation :</h4>
            <p>Ces algorithmes sont utilisés dans différents contextes en fonction des données et des contraintes de performance :</p>
            <ul>
                <li>Quicksort est souvent choisi pour sa rapidité en moyenne, mais il peut être moins performant dans le pire des cas.</li>
                <li>Heapsort offre des performances garanties grâce à sa complexité stable.</li>
                <li>Merge Sort est particulièrement adapté aux grandes listes et est stable dans sa performance.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étude et Implémentation des Algorithmes (1 heure)</h3>
        
            <h4>1. Quicksort</h4>
            <p>Quicksort est un algorithme de tri en place (ne nécessitant pas d'espace supplémentaire) basé sur le choix d'un pivot. Il partitionne les données en deux parties autour du pivot :</p>
        
            <p><strong>Pseudo-code de Quicksort :</strong></p>
            <pre><code>def quicksort(tableau, debut, fin):
            if debut < fin:
                pivot = partition(tableau, debut, fin)
                quicksort(tableau, debut, pivot - 1)
                quicksort(tableau, pivot + 1, fin)
                
        def partition(tableau, debut, fin):
            pivot = tableau[fin]
            i = debut - 1
            for j in range(debut, fin):
                if tableau[j] <= pivot:
                    i += 1
                    tableau[i], tableau[j] = tableau[j], tableau[i]
            tableau[i + 1], tableau[fin] = tableau[fin], tableau[i + 1]
            return i + 1
            </code></pre>
        
            <p>Quicksort fonctionne bien en moyenne, mais il peut être moins efficace si le pivot est mal choisi. Sa complexité est en moyenne <code>O(n log n)</code>, mais dans le pire des cas, elle peut atteindre <code>O(n²)</code>.</p>
        
            <h4>Exercice Pratique avec Quicksort :</h4>
            <ul>
                <li>Implémentez l’algorithme Quicksort sur une liste de nombres aléatoires.</li>
                <li>Mesurez le temps de tri en utilisant différents choix de pivots pour observer les variations de performance.</li>
            </ul>
        
            <h4>2. Heapsort</h4>
            <p>Heapsort utilise une structure de tas binaire (heap) pour trier les éléments. Le tas est une structure en forme d’arbre où chaque nœud est plus grand ou plus petit que ses enfants, ce qui permet de construire un tableau trié :</p>
        
            <p><strong>Pseudo-code de Heapsort :</strong></p>
            <pre><code>def heapsort(tableau):
            n = len(tableau)
            for i in range(n // 2 - 1, -1, -1):
                entasser(tableau, n, i)
            
            for i in range(n - 1, 0, -1):
                tableau[i], tableau[0] = tableau[0], tableau[i]
                entasser(tableau, i, 0)
                
        def entasser(tableau, n, i):
            plus_grand = i
            gauche = 2 * i + 1
            droite = 2 * i + 2
        
            if gauche < n and tableau[gauche] > tableau[plus_grand]:
                plus_grand = gauche
        
            if droite < n and tableau[droite] > tableau[plus_grand]:
                plus_grand = droite
        
            if plus_grand != i:
                tableau[i], tableau[plus_grand] = tableau[plus_grand], tableau[i]
                entasser(tableau, n, plus_grand)
            </code></pre>
        
            <p>Heapsort a une complexité stable de <code>O(n log n)</code>, ce qui en fait un choix sûr pour des tri nécessitant une garantie de performance, indépendamment de l'ordre initial des éléments.</p>
        
            <h4>Exercice Pratique avec Heapsort :</h4>
            <ul>
                <li>Implémentez Heapsort sur une liste de nombres aléatoires et mesurez le temps d'exécution.</li>
                <li>Comparez les résultats avec ceux de Quicksort sur les mêmes données.</li>
            </ul>
        
            <h4>3. Merge Sort</h4>
            <p>Merge Sort suit une approche de division-fusion. Il divise récursivement le tableau en deux moitiés, trie chaque moitié, puis fusionne les moitiés triées :</p>
        
            <p><strong>Pseudo-code de Merge Sort :</strong></p>
            <pre><code>def merge_sort(tableau):
            if len(tableau) > 1:
                milieu = len(tableau) // 2
                gauche = tableau[:milieu]
                droite = tableau[milieu:]
        
                merge_sort(gauche)
                merge_sort(droite)
        
                i = j = k = 0
        
                while i < len(gauche) and j < len(droite):
                    if gauche[i] < droite[j]:
                        tableau[k] = gauche[i]
                        i += 1
                    else:
                        tableau[k] = droite[j]
                        j += 1
                    k += 1
        
                while i < len(gauche):
                    tableau[k] = gauche[i]
                    i += 1
                    k += 1
        
                while j < len(droite):
                    tableau[k] = droite[j]
                    j += 1
                    k += 1
            </code></pre>
        
            <p>Merge Sort est stable et a une complexité garantie de <code>O(n log n)</code>, ce qui le rend particulièrement adapté pour trier de grands ensembles de données, même si cela peut nécessiter plus de mémoire.</p>
        
            <h4>Exercice Pratique avec Merge Sort :</h4>
            <ul>
                <li>Implémentez Merge Sort sur une liste de nombres et observez les temps d'exécution pour de grandes listes.</li>
                <li>Comparez les résultats de Merge Sort avec ceux de Quicksort et Heapsort.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Comparaison des Algorithmes (45 min)</h3>
        
            <h4>1. Complexité Temporelle et Efficacité</h4>
            <p>Voici un récapitulatif des complexités des trois algorithmes étudiés :</p>
            <ul>
                <li><strong>Quicksort :</strong> <code>O(n log n)</code> en moyenne, mais <code>O(n²)</code> dans le pire des cas.</li>
                <li><strong>Heapsort :</strong> <code>O(n log n)</code> dans tous les cas.</li>
                <li><strong>Merge Sort :</strong> <code>O(n log n)</code> dans tous les cas, mais nécessite plus de mémoire.</li>
            </ul>
        
            <h4>2. Observation des Performances en Pratique</h4>
            <ul>
                <li>Utilisez de grands ensembles de données pour observer les temps d'exécution et la consommation mémoire de chaque algorithme.</li>
                <li>Documentez les résultats dans un tableau pour comparer l’efficacité de chaque algorithme sur différentes tailles de listes.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion (15 min)</h3>
            <p>À la fin de cette séance, les élèves doivent être capables de :</p>
            <ul>
                <li>Expliquer les principes et les différences entre Quicksort, Heapsort et Merge Sort.</li>
                <li>Comparer ces algorithmes en fonction de leur complexité et de leurs performances en pratique.</li>
                <li>Choisir l’algorithme le plus adapté selon les caractéristiques de l’ensemble de données et les contraintes de mémoire ou de temps.</li>
            </ul>
        
            <h4>Discussion :</h4>
            <ul>
                <li>Dans quels cas choisir chaque algorithme de tri ?</li>
                <li>Comment les optimisations de mémoire influencent-elles le choix de l'algorithme ?</li>
            </ul>
        </section>

        <section id="session34" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 34 : Optimisation des Algorithmes de Tri dans des Contextes Réels</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves vont explorer et optimiser différents algorithmes de tri (tri à bulles, tri par sélection, tri rapide) dans des contextes réels. L'objectif est de comprendre les limites et les avantages de chaque algorithme selon les données à trier. Les élèves apprendront à choisir le tri le plus efficace en fonction des situations et à comparer les performances de chaque algorithme.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Algorithmes de Tri</h3>
            <p>Les algorithmes de tri sont essentiels en informatique, car ils permettent d’organiser les données pour rendre leur traitement plus efficace. Voici quelques exemples d’utilisation des algorithmes de tri dans des contextes réels :</p>
            <ul>
                <li><strong>Jeux vidéo :</strong> tri des scores des joueurs pour afficher le classement.</li>
                <li><strong>Sites de commerce électronique :</strong> tri des produits par prix, note ou popularité.</li>
                <li><strong>Banques de données :</strong> tri des transactions financières par date pour faciliter la recherche.</li>
            </ul>
            <p>Dans cette séance, nous allons explorer différents algorithmes de tri et apprendre à choisir celui qui convient le mieux selon la taille et la nature des données.</p>
        
            <h4>Les Algorithmes de Tri Principaux :</h4>
            <ul>
                <li><strong>Tri à bulles (Bubble Sort) :</strong> un algorithme simple mais peu efficace sur de grands ensembles de données.</li>
                <li><strong>Tri par sélection (Selection Sort) :</strong> un algorithme efficace sur de petits ensembles, mais moins performant sur de grands ensembles.</li>
                <li><strong>Tri rapide (Quick Sort) :</strong> un algorithme très performant pour la plupart des tailles de données.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étude et Implémentation des Algorithmes de Tri (40 min)</h3>
            <h4>1. Tri à Bulles (Bubble Sort)</h4>
            <p>Le tri à bulles consiste à comparer chaque paire d’éléments adjacents dans une liste et à échanger leur position si l'ordre est incorrect. Ce processus est répété jusqu'à ce que la liste soit triée.</p>
            
            <pre><code>def tri_a_bulles(liste):
            n = len(liste)
            for i in range(n):
                for j in range(0, n-i-1):
                    if liste[j] > liste[j+1]:
                        liste[j], liste[j+1] = liste[j+1], liste[j]
            </code></pre>
        
            <h4>2. Tri par Sélection (Selection Sort)</h4>
            <p>Le tri par sélection trouve le plus petit élément de la liste et l’échange avec le premier élément non trié. Ce processus est répété en ignorant la partie déjà triée de la liste.</p>
        
            <pre><code>def tri_par_selection(liste):
            n = len(liste)
            for i in range(n):
                min_index = i
                for j in range(i+1, n):
                    if liste[j] < liste[min_index]:
                        min_index = j
                liste[i], liste[min_index] = liste[min_index], liste[i]
            </code></pre>
        
            <h4>3. Tri Rapide (Quick Sort)</h4>
            <p>Le tri rapide est un algorithme efficace qui utilise la récursivité. Il choisit un élément "pivot" et réorganise la liste de sorte que tous les éléments inférieurs au pivot soient à gauche et tous les éléments supérieurs soient à droite. Ensuite, il trie récursivement les sous-listes de chaque côté du pivot.</p>
        
            <pre><code>def tri_rapide(liste):
            if len(liste) <= 1:
                return liste
            pivot = liste[len(liste) // 2]
            gauche = [x for x in liste if x < pivot]
            milieu = [x for x in liste if x == pivot]
            droite = [x for x in liste if x > pivot]
            return tri_rapide(gauche) + milieu + tri_rapide(droite)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Comparaison des Algorithmes dans un Contexte Réel (45 min)</h3>
            
            <h4>1. Contexte : Tri des Scores dans un Jeu Vidéo</h4>
            <p>Imaginez que nous avons une liste de scores de joueurs dans un jeu vidéo, et que nous devons afficher un classement du meilleur au moins bon. Nous allons comparer l'efficacité des trois algorithmes de tri pour ordonner cette liste.</p>
        
            <p>Liste des scores aléatoires :</p>
            <pre><code>scores = [42, 17, 88, 61, 53, 92, 74, 38, 20, 5]
            </code></pre>
        
            <h4>2. Expérience Pratique : Mesurer les Temps de Calcul</h4>
            <p>Pour chaque algorithme, les élèves doivent mesurer le temps de calcul nécessaire pour trier la liste de scores. Cela permettra de voir l'efficacité de chaque méthode sur une liste de taille moyenne.</p>
        
            <pre><code>import time
        
        # Tri à bulles
        debut = time.time()
        tri_a_bulles(scores)
        print("Temps pour le tri à bulles :", time.time() - debut)
        
        # Tri par sélection
        debut = time.time()
        tri_par_selection(scores)
        print("Temps pour le tri par sélection :", time.time() - debut)
        
        # Tri rapide
        debut = time.time()
        tri_rapide(scores)
        print("Temps pour le tri rapide :", time.time() - debut)
            </code></pre>
        
            <p>Les élèves pourront noter les temps d'exécution et constater que le tri rapide est généralement le plus performant.</p>
        
            <h4>3. Choix de l’Algorithme en Fonction du Contexte</h4>
            <p>En fonction de la taille et de la nature des données, chaque algorithme a ses avantages et inconvénients :</p>
            <ul>
                <li><strong>Tri à Bulles :</strong> adapté aux listes de petite taille ou partiellement triées, mais inefficace pour de grandes listes.</li>
                <li><strong>Tri par Sélection :</strong> fonctionne bien sur des listes de petite taille, mais est lent pour les grandes listes.</li>
                <li><strong>Tri Rapide :</strong> très efficace pour les grandes listes de données, mais peut être moins performant si les données sont déjà presque triées.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Défi Pratique (20 min)</h3>
            <ul>
                <li><strong>Étape 1 :</strong> Créez une liste de 1 000 scores aléatoires et mesurez le temps de calcul pour chaque algorithme. Quelle est la méthode la plus rapide ?</li>
                <li><strong>Étape 2 :</strong> Modifiez la liste pour qu’elle soit presque triée et comparez à nouveau les temps de calcul. Qu’observez-vous ?</li>
                <li><strong>Étape 3 :</strong> Écrivez un programme qui choisit automatiquement l’algorithme de tri optimal en fonction de la taille et de l’ordre initial de la liste.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Réflexion (15 min)</h3>
            <p>À la fin de cette séance, les élèves comprendront que le choix de l'algorithme de tri dépend du contexte : taille de la liste, ordre initial des éléments, et besoin en performance. En analysant les avantages et limitations de chaque algorithme, ils sauront comment adapter leur choix aux exigences réelles d'un programme.</p>
        
            <h4>Points de Réflexion :</h4>
            <ul>
                <li>Pourquoi certains algorithmes sont-ils plus efficaces sur des listes déjà triées ou presque triées ?</li>
                <li>Quel serait le meilleur choix d'algorithme si les données sont triées dans l'ordre inverse ?</li>
                <li>Comment pourriez-vous appliquer ces connaissances dans d'autres contextes de tri, comme la gestion de grandes bases de données ?</li>
            </ul>
        </section>

        <section id="session35" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 35 : Pratique - Choisir et implémenter l’algorithme de tri le plus efficace pour différentes situations</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves doivent comprendre comment sélectionner et implémenter l’algorithme de tri le plus adapté en fonction de différents contextes, en utilisant des exemples pratiques issus des jeux vidéo et de l’actualité. Ils analyseront la complexité de différents algorithmes de tri (comme le tri rapide, le tri par insertion et le tri fusion) et choisiront celui qui convient le mieux selon la taille et les spécificités des données à trier.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Algorithmes de Tri (15 min)</h3>
            
            <h4>Pourquoi Utiliser des Algorithmes de Tri dans des Contextes Concrets ?</h4>
            <p>Le tri est une opération fondamentale dans de nombreuses applications. Dans un jeu vidéo, par exemple, il est souvent nécessaire de trier les scores des joueurs pour afficher un classement, ou de trier les objets dans l’inventaire d’un personnage. Dans le contexte de l’actualité, il peut être important de trier les nouvelles en fonction de leur popularité ou de leur date de publication.</p>
            
            <h4>Présentation des Algorithmes de Tri à Connaître :</h4>
            <ul>
                <li><strong>Tri par Insertion</strong> : efficace pour les petites listes ou les listes presque triées.</li>
                <li><strong>Tri Fusion</strong> : performant pour de grands ensembles de données grâce à sa complexité en <code>O(n log n)</code>.</li>
                <li><strong>Tri Rapide (Quicksort)</strong> : souvent rapide dans la pratique, mais peut être inefficace dans certains cas particuliers.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Études de Cas - Choix des Algorithmes de Tri (25 min)</h3>
            
            <h4>1. Exemple de Jeu Vidéo - Classement des Joueurs</h4>
            <p>Dans un jeu vidéo de course, chaque joueur obtient un score. Pour afficher le classement des joueurs à la fin de chaque partie, il est nécessaire de trier les scores du plus élevé au plus bas.</p>
            
            <h5>Choix de l’algorithme :</h5>
            <ul>
                <li>Le nombre de scores à trier est souvent limité, car il n’y a généralement pas des milliers de joueurs par partie.</li>
                <li>Un <strong>tri rapide</strong> ou un <strong>tri par insertion</strong> pourrait être un bon choix pour une liste de scores limitée.</li>
            </ul>
        
            <h4>2. Exemple d’Actualité - Trier les Articles par Popularité</h4>
            <p>Dans une application de nouvelles, les articles doivent être affichés par ordre de popularité (nombre de vues). Cette liste est mise à jour en temps réel.</p>
            
            <h5>Choix de l’algorithme :</h5>
            <ul>
                <li>Le nombre d’articles peut être important, mais comme les nouvelles populaires sont mises en avant, la liste pourrait être partiellement triée.</li>
                <li>Le <strong>tri fusion</strong> est souvent préféré pour sa stabilité et son efficacité sur de grands ensembles de données.</li>
            </ul>
        
            <h4>3. Autres Situations - Tri de l'Inventaire dans un Jeu Vidéo</h4>
            <p>Un personnage de jeu peut avoir de nombreux objets dans son inventaire. Ces objets peuvent être triés par type (armes, potions) ou par valeur.</p>
            
            <h5>Choix de l’algorithme :</h5>
            <ul>
                <li>Pour un inventaire de taille moyenne, le <strong>tri par insertion</strong> est efficace, car il est simple et rapide pour des listes petites à moyennes.</li>
                <li>Si l’inventaire est volumineux, un <strong>tri rapide</strong> pourrait être plus adapté.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Implémentation des Algorithmes de Tri (50 min)</h3>
        
            <h4>1. Implémentation du Tri par Insertion :</h4>
            <pre><code>def tri_insertion(liste):
            for i in range(1, len(liste)):
                cle = liste[i]
                j = i - 1
                while j >= 0 and liste[j] > cle:
                    liste[j + 1] = liste[j]
                    j -= 1
                liste[j + 1] = cle
            return liste
            </code></pre>
            <p><strong>Exercice :</strong> Utilisez cet algorithme pour trier une liste de scores de joueurs dans un jeu vidéo.</p>
        
            <h4>2. Implémentation du Tri Fusion :</h4>
            <pre><code>def tri_fusion(liste):
            if len(liste) <= 1:
                return liste
            milieu = len(liste) // 2
            gauche = tri_fusion(liste[:milieu])
            droite = tri_fusion(liste[milieu:])
            return fusion(gauche, droite)
        
        def fusion(gauche, droite):
            resultat = []
            i = j = 0
            while i < len(gauche) and j < len(droite):
                if gauche[i] < droite[j]:
                    resultat.append(gauche[i])
                    i += 1
                else:
                    resultat.append(droite[j])
                    j += 1
            resultat.extend(gauche[i:])
            resultat.extend(droite[j:])
            return resultat
            </code></pre>
            <p><strong>Exercice :</strong> Utilisez cet algorithme pour trier une liste d'articles de presse en fonction de leur popularité.</p>
        
            <h4>3. Implémentation du Tri Rapide (Quicksort) :</h4>
            <pre><code>def tri_rapide(liste):
            if len(liste) <= 1:
                return liste
            pivot = liste[len(liste) // 2]
            gauche = [x for x in liste if x < pivot]
            milieu = [x for x in liste if x == pivot]
            droite = [x for x in liste if x > pivot]
            return tri_rapide(gauche) + milieu + tri_rapide(droite)
            </code></pre>
            <p><strong>Exercice :</strong> Utilisez cet algorithme pour trier une liste de noms d’objets dans un inventaire de jeu vidéo.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Comparaison des Algorithmes (10 min)</h3>
            
            <h4>Comparaison des Algorithmes de Tri :</h4>
            <ul>
                <li><strong>Tri par Insertion :</strong> efficace pour des petites listes ou des listes presque triées. Complexité moyenne : <code>O(n^2)</code>.</li>
                <li><strong>Tri Fusion :</strong> stable et performant pour des grandes listes, mais utilise de la mémoire supplémentaire. Complexité : <code>O(n log n)</code>.</li>
                <li><strong>Tri Rapide :</strong> très rapide dans la pratique, mais instable dans le pire des cas. Complexité moyenne : <code>O(n log n)</code>, pire des cas : <code>O(n^2)</code>.</li>
            </ul>
        
            <h4>Résumé :</h4>
            <p>Les élèves ont appris à identifier l’algorithme de tri le plus adapté selon la taille et l’état initial des données. En choisissant un algorithme en fonction du contexte (comme un jeu vidéo ou une application d'actualités), ils comprennent mieux l'importance de l’efficacité dans le développement d'applications.</p>
        </section>

        <section id="session36" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 36 : Révision et consolidation des concepts d'algorithmes de tri</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves réviseront les principaux algorithmes de tri, comprendront leur fonctionnement, et analyseront leurs différences en termes de complexité. L’objectif est de renforcer leur maîtrise des algorithmes de tri et de les rendre capables de choisir l'algorithme le plus adapté selon le contexte.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Algorithmes de Tri (15 min)</h3>
            <p>Les algorithmes de tri sont des méthodes pour organiser les données dans un ordre particulier, comme l’ordre croissant ou décroissant. Ils sont essentiels en informatique, car de nombreux autres algorithmes s'appuient sur des données triées pour améliorer leurs performances.</p>
        
            <h4>Algorithmes de Tri à Étudier :</h4>
            <ul>
                <li><strong>Tri par Insertion :</strong> méthode simple et intuitive, efficace pour des listes presque triées.</li>
                <li><strong>Tri par Sélection :</strong> recherche de l'élément le plus petit à chaque itération pour le placer dans l'ordre.</li>
                <li><strong>Tri à Bulles (Bubble Sort) :</strong> échange les éléments adjacents pour faire « remonter » les plus grands éléments.</li>
                <li><strong>Tri Rapide (Quick Sort) :</strong> méthode de tri par division et conquête, efficace pour les grandes listes.</li>
                <li><strong>Tri Fusion (Merge Sort) :</strong> méthode basée sur la fusion de listes triées, adaptée aux grandes listes.</li>
            </ul>
        
            <h4>Complexité des Algorithmes :</h4>
            <p>Nous allons examiner la <strong>complexité en temps</strong> de chaque algorithme pour comparer leur efficacité :</p>
            <ul>
                <li>Tri par Insertion, Sélection, et Bulles : <code>O(n²)</code> dans le pire des cas.</li>
                <li>Tri Rapide : <code>O(n log n)</code> en moyenne, mais peut aller jusqu’à <code>O(n²)</code> dans le pire des cas.</li>
                <li>Tri Fusion : <code>O(n log n)</code> dans le pire des cas.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Révision et Implémentation des Algorithmes (50 min)</h3>
            
            <h4>1. Tri par Insertion :</h4>
            <p>Le tri par insertion parcourt la liste et insère chaque élément à sa place dans la partie déjà triée de la liste.</p>
            <pre><code>def tri_insertion(liste):
            for i in range(1, len(liste)):
                valeur = liste[i]
                j = i - 1
                while j >= 0 and liste[j] > valeur:
                    liste[j + 1] = liste[j]
                    j -= 1
                liste[j + 1] = valeur
            </code></pre>
        
            <h4>Exercice pratique :</h4>
            <ul>
                <li>Écrire une liste de nombres aléatoires.</li>
                <li>Utiliser le tri par insertion pour les trier.</li>
                <li>Observer la complexité du tri en comptant les comparaisons.</li>
            </ul>
        
            <h4>2. Tri par Sélection :</h4>
            <p>Le tri par sélection parcourt la liste pour trouver l’élément le plus petit et le place au début.</p>
            <pre><code>def tri_selection(liste):
            for i in range(len(liste)):
                min_index = i
                for j in range(i + 1, len(liste)):
                    if liste[j] < liste[min_index]:
                        min_index = j
                liste[i], liste[min_index] = liste[min_index], liste[i]
            </code></pre>
        
            <h4>Exercice pratique :</h4>
            <ul>
                <li>Utiliser le tri par sélection sur une liste aléatoire et observer la façon dont chaque élément est placé dans l’ordre.</li>
                <li>Noter la complexité pour des listes de différentes tailles.</li>
            </ul>
        
            <h4>3. Tri à Bulles (Bubble Sort) :</h4>
            <p>Le tri à bulles fait passer les éléments les plus grands vers la fin de la liste en effectuant des échanges successifs entre éléments adjacents.</p>
            <pre><code>def tri_bulles(liste):
            n = len(liste)
            for i in range(n):
                for j in range(0, n-i-1):
                    if liste[j] > liste[j+1]:
                        liste[j], liste[j+1] = liste[j+1], liste[j]
            </code></pre>
        
            <h4>Exercice pratique :</h4>
            <ul>
                <li>Utiliser le tri à bulles pour trier une liste et observer les changements à chaque passage.</li>
                <li>Comparer le nombre de comparaisons avec les autres méthodes.</li>
            </ul>
        
            <h4>4. Tri Rapide (Quick Sort) :</h4>
            <p>Le tri rapide choisit un élément pivot et divise la liste en deux parties pour les trier récursivement.</p>
            <pre><code>def tri_rapide(liste):
            if len(liste) <= 1:
                return liste
            else:
                pivot = liste[0]
                gauche = [x for x in liste[1:] if x <= pivot]
                droite = [x for x in liste[1:] if x > pivot]
                return tri_rapide(gauche) + [pivot] + tri_rapide(droite)
            </code></pre>
        
            <h4>Exercice pratique :</h4>
            <ul>
                <li>Choisir une liste d’éléments aléatoires et utiliser le tri rapide pour la trier.</li>
                <li>Observer le nombre de comparaisons et d’échanges, et comparer la vitesse avec les méthodes <code>O(n²)</code>.</li>
            </ul>
        
            <h4>5. Tri Fusion (Merge Sort) :</h4>
            <p>Le tri fusion divise la liste en sous-listes jusqu'à ce qu'elles ne contiennent qu'un élément, puis fusionne les sous-listes en ordre croissant.</p>
            <pre><code>def tri_fusion(liste):
            if len(liste) <= 1:
                return liste
            milieu = len(liste) // 2
            gauche = tri_fusion(liste[:milieu])
            droite = tri_fusion(liste[milieu:])
            return fusion(gauche, droite)
        
        def fusion(gauche, droite):
            resultat = []
            i = j = 0
            while i < len(gauche) and j < len(droite):
                if gauche[i] < droite[j]:
                    resultat.append(gauche[i])
                    i += 1
                else:
                    resultat.append(droite[j])
                    j += 1
            resultat.extend(gauche[i:])
            resultat.extend(droite[j:])
            return resultat
            </code></pre>
        
            <h4>Exercice pratique :</h4>
            <ul>
                <li>Utiliser le tri fusion pour trier une liste et observer les étapes de fusion des sous-listes.</li>
                <li>Comparer la complexité temporelle avec le tri rapide.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Comparaison des Algorithmes (15 min)</h3>
            <h4>Comparaison des Complexités :</h4>
            <p>Les élèves comparent chaque algorithme en termes de complexité, vitesse et nombre d’opérations, en utilisant des listes de différentes tailles.</p>
            <ul>
                <li>Tri Insertion, Sélection, Bulles : <code>O(n²)</code> – moins efficace pour les grandes listes.</li>
                <li>Tri Rapide : <code>O(n log n)</code> en moyenne – efficace pour les grandes listes.</li>
                <li>Tri Fusion : <code>O(n log n)</code> – stable et efficace.</li>
            </ul>
        
            <h4>Analyse Pratique :</h4>
            <ul>
                <li><strong>Stabilité :</strong> les tris fusion et insertion sont stables, ce qui est important dans certains contextes.</li>
                <li><strong>Cas d’utilisation :</strong> le tri rapide est souvent privilégié pour les grandes listes, alors que le tri insertion est adapté pour les petites listes déjà partiellement triées.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion (10 min)</h3>
            <p>À la fin de cette séance, les élèves devraient être capables de choisir le bon algorithme de tri en fonction du contexte et de la taille des données. Ils auront également acquis une bonne compréhension des différences de complexité entre chaque algorithme, ainsi que leurs avantages et inconvénients.</p>
        </section>

        <section id="session37" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 37 : Introduction à la Programmation Orientée Objet (POO) – Classes, Objets, Méthodes</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Dans cette séance, les élèves découvriront les concepts fondamentaux de la programmation orientée objet (POO) en Python. Ils apprendront à définir des classes, à créer des objets et à utiliser des méthodes pour manipuler les attributs des objets. Cette séance comporte des exercices pratiques pour illustrer chaque concept, en utilisant des exemples simples et concrets.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction à la Programmation Orientée Objet (15 min)</h3>
            
            <h4>Contexte :</h4>
            <p>La Programmation Orientée Objet (POO) est un paradigme de programmation qui permet de structurer le code en regroupant des données et des comportements dans des <strong>objets</strong>. Un objet est une instance d'une <strong>classe</strong>, qui est un modèle ou une "usine" pour créer des objets similaires.</p>
        
            <h4>Concepts Clés :</h4>
            <ul>
                <li><strong>Classe :</strong> Une classe est un modèle pour créer des objets. Elle définit les attributs (données) et les méthodes (fonctions) que chaque objet de cette classe possédera.</li>
                <li><strong>Objet :</strong> Un objet est une instance de classe. C’est une entité spécifique créée à partir d’une classe, avec ses propres valeurs d'attributs.</li>
                <li><strong>Méthode :</strong> Une méthode est une fonction définie dans une classe. Elle décrit les actions qu'un objet de cette classe peut effectuer.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Définition d’une Classe en Python (20 min)</h3>
            
            <h4>Exemple : Classe Personnage dans un Jeu Vidéo</h4>
            <p>Imaginons que nous créons un jeu vidéo. Nous avons besoin de définir un modèle pour les personnages du jeu, avec des attributs comme le <strong>nom</strong> du personnage et ses <strong>points de vie</strong>, et des méthodes pour qu'il puisse <strong>se déplacer</strong> ou <strong>attaquer</strong>.</p>
        
            <h4>Code Exemple :</h4>
            <p>Voici comment définir une classe <code>Personnage</code> avec deux attributs et une méthode :</p>
            <pre><code>class Personnage:
            def __init__(self, nom, points_de_vie):
                self.nom = nom                # Attribut 'nom'
                self.points_de_vie = points_de_vie  # Attribut 'points de vie'
            
            def se_presenter(self):
                print(f"Je suis {self.nom} et j'ai {self.points_de_vie} points de vie.")
            </code></pre>
        
            <p><strong>Explication :</strong></p>
            <ul>
                <li><code>__init__</code> : Cette méthode spéciale s’appelle le <strong>constructeur</strong>. Elle est appelée automatiquement quand un nouvel objet est créé. Elle initialise les attributs de l'objet.</li>
                <li><code>self</code> : Représente l'instance de l'objet actuel. Il est utilisé pour accéder aux attributs et méthodes de l'objet dans la classe.</li>
                <li><code>nom</code> et <code>points_de_vie</code> : Attributs de la classe <code>Personnage</code>, qui stockent le nom et les points de vie du personnage.</li>
                <li><code>se_presenter</code> : Méthode qui affiche une présentation du personnage.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Création et Utilisation d’Objets (25 min)</h3>
            
            <h4>1. Créer un Objet</h4>
            <p>Pour créer un objet de la classe <code>Personnage</code>, on utilise la syntaxe suivante :</p>
            <pre><code># Création d'un objet de la classe Personnage
        heros = Personnage("Arthur", 100)
            </code></pre>
        
            <h4>2. Utiliser les Attributs et Méthodes de l'Objet</h4>
            <p>Une fois l'objet <code>heros</code> créé, nous pouvons accéder à ses attributs et méthodes :</p>
            <pre><code># Accéder aux attributs
        print(heros.nom)           # Affiche "Arthur"
        print(heros.points_de_vie) # Affiche 100
        
        # Appeler une méthode
        heros.se_presenter()        # Affiche "Je suis Arthur et j'ai 100 points de vie."
            </code></pre>
        
            <p><strong>Explication :</strong> Ici, nous avons créé un personnage appelé "Arthur" avec 100 points de vie. En appelant <code>heros.se_presenter()</code>, nous demandons à l'objet de se présenter.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Exercice Pratique (40 min)</h3>
            <h4>Contexte du Jeu :</h4>
            <p>Dans un jeu de rôle, chaque personnage peut avoir un nom, des points de vie et une action de présentation. Nous allons étendre cet exemple en ajoutant une méthode pour que le personnage puisse <strong>perdre des points de vie</strong> lorsqu'il prend des dégâts.</p>
        
            <h4>Étapes de l'Exercice :</h4>
            <ol>
                <li><strong>Étape 1 :</strong> Ajoutez une méthode <code>subir_degats</code> dans la classe <code>Personnage</code> qui réduit les points de vie du personnage.</li>
                <li><strong>Étape 2 :</strong> Utilisez cette méthode pour simuler un combat où le personnage prend des dégâts et affiche ses points de vie restants.</li>
            </ol>
        
            <h4>Code de Base :</h4>
            <pre><code>class Personnage:
            def __init__(self, nom, points_de_vie):
                self.nom = nom
                self.points_de_vie = points_de_vie
            
            def se_presenter(self):
                print(f"Je suis {self.nom} et j'ai {self.points_de_vie} points de vie.")
            
            def subir_degats(self, degats):
                self.points_de_vie -= degats
                print(f"{self.nom} subit {degats} points de dégâts. Points de vie restants : {self.points_de_vie}")
            </code></pre>
        
            <h4>Exemple d'Utilisation :</h4>
            <pre><code># Créer un personnage
        heros = Personnage("Arthur", 100)
        
        # Le personnage se présente
        heros.se_presenter()
        
        # Le personnage subit des dégâts
        heros.subir_degats(20)   # Réduit les points de vie de 20
        heros.subir_degats(10)   # Réduit les points de vie de 10
            </code></pre>
        
            <h4>Résultat Attendu :</h4>
            <p>Le programme doit afficher :</p>
            <pre><code>Je suis Arthur et j'ai 100 points de vie.
        Arthur subit 20 points de dégâts. Points de vie restants : 80
        Arthur subit 10 points de dégâts. Points de vie restants : 70
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Questions de Réflexion (20 min)</h3>
        
            <h4>Récapitulatif :</h4>
            <p>Dans cette séance, les élèves ont appris :</p>
            <ul>
                <li>À définir une <strong>classe</strong> avec des attributs et des méthodes.</li>
                <li>À créer des <strong>objets</strong> de cette classe et à manipuler leurs attributs et méthodes.</li>
                <li>À comprendre l'importance de la <strong>POO</strong> pour structurer le code de manière modulaire et réutilisable.</li>
            </ul>
        
            <h4>Questions pour Approfondir :</h4>
            <ul>
                <li>Comment pouvez-vous ajouter des <strong>types de personnages</strong> différents (par exemple, Guerrier, Mage) qui ont chacun des actions spécifiques ?</li>
                <li>Comment pourrait-on améliorer la méthode <code>subir_degats</code> pour éviter que les points de vie ne deviennent négatifs ?</li>
                <li>Que se passe-t-il si on ajoute de nouveaux attributs à la classe ? Comment cela affecte-t-il les objets existants ?</li>
            </ul>
        
            <h4>Défi supplémentaire :</h4>
            <p>Demandez aux élèves de créer une nouvelle méthode appelée <code>soigner</code> qui permet au personnage de regagner des points de vie lorsqu’il reçoit des soins. Cette méthode doit vérifier que les points de vie ne dépassent pas un maximum (par exemple, 100).</p>
        
        </section>

        <section id="session38" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 38 : Pratique - Modélisation d’un personnage de jeu vidéo en POO</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront à utiliser les concepts de Programmation Orientée Objet (POO) pour modéliser un personnage de jeu vidéo. Ils vont créer une classe <code>Personnage</code> avec différents attributs et méthodes pour simuler les actions et l’évolution du personnage dans le jeu.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction à la Modélisation d'un Personnage (15 min)</h3>
        
            <h4>Concept de Modélisation en POO :</h4>
            <p>Dans les jeux vidéo, chaque personnage possède des caractéristiques (comme la santé, la force, la vitesse) et peut accomplir des actions (comme se déplacer, attaquer, utiliser des objets). Nous allons utiliser la POO pour représenter ces caractéristiques et actions sous forme de <strong>classes</strong> et de <strong>méthodes</strong>.</p>
        
            <h4>Définition de la Classe <code>Personnage</code> :</h4>
            <p>La classe <code>Personnage</code> représentera un personnage de jeu vidéo. Cette classe inclura :</p>
            <ul>
                <li>Des <strong>attributs</strong> pour stocker les caractéristiques du personnage, comme son nom, ses points de vie, sa force, et sa position.</li>
                <li>Des <strong>méthodes</strong> pour effectuer des actions, comme se déplacer, attaquer, et récupérer des points de vie.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 1 : Création de la Classe Personnage et des Attributs (30 min)</h3>
        
            <h4>1. Définition des Attributs :</h4>
            <p>Chaque personnage aura les attributs suivants :</p>
            <ul>
                <li><strong>nom</strong> : le nom du personnage.</li>
                <li><strong>points_vie</strong> : le nombre de points de vie restants.</li>
                <li><strong>force</strong> : la force d’attaque du personnage.</li>
                <li><strong>position</strong> : la position du personnage dans le jeu (par exemple, représentée par des coordonnées x et y).</li>
            </ul>
        
            <h4>2. Implémentation de la Classe Personnage :</h4>
            <p>Voici le code de base pour la classe <code>Personnage</code> avec les attributs définis :</p>
        
            <pre><code>class Personnage:
            def __init__(self, nom, points_vie, force, position=(0, 0)):
                self.nom = nom  # Nom du personnage
                self.points_vie = points_vie  # Points de vie
                self.force = force  # Force d'attaque
                self.position = position  # Position (x, y)
        
            def afficher_informations(self):
                print(f"Nom : {self.nom}")
                print(f"Points de vie : {self.points_vie}")
                print(f"Force : {self.force}")
                print(f"Position : {self.position}")
            </code></pre>
        
            <h4>3. Explication du Code :</h4>
            <ul>
                <li>Le constructeur <code>__init__()</code> initialise les attributs du personnage.</li>
                <li>La méthode <code>afficher_informations()</code> permet d’afficher les informations du personnage, ce qui sera utile pour vérifier les attributs de chaque instance.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 2 : Ajouter des Méthodes d'Action (45 min)</h3>
        
            <h4>1. Méthode <code>se_deplacer()</code> :</h4>
            <p>Cette méthode permettra au personnage de se déplacer dans le jeu. Elle acceptera une direction (<code>haut</code>, <code>bas</code>, <code>gauche</code>, <code>droite</code>) et mettra à jour les coordonnées du personnage en conséquence.</p>
        
            <pre><code>def se_deplacer(self, direction):
            x, y = self.position
            if direction == "haut":
                self.position = (x, y + 1)
            elif direction == "bas":
                self.position = (x, y - 1)
            elif direction == "gauche":
                self.position = (x - 1, y)
            elif direction == "droite":
                self.position = (x + 1, y)
            print(f"{self.nom} s'est déplacé vers {direction}. Nouvelle position : {self.position}")
            </code></pre>
        
            <h4>2. Méthode <code>attaquer()</code> :</h4>
            <p>Cette méthode permet au personnage d’attaquer un autre personnage. Elle prend un objet <code>cible</code> comme paramètre et réduit les points de vie de la cible en fonction de la force du personnage attaquant.</p>
        
            <pre><code>def attaquer(self, cible):
            print(f"{self.nom} attaque {cible.nom} avec une force de {self.force}")
            cible.points_vie -= self.force
            print(f"{cible.nom} a maintenant {cible.points_vie} points de vie restants.")
            if cible.points_vie <= 0:
                print(f"{cible.nom} a été vaincu !")
            </code></pre>
        
            <h4>3. Méthode <code>soigner()</code> :</h4>
            <p>La méthode <code>soigner()</code> permet au personnage de regagner des points de vie.</p>
        
            <pre><code>def soigner(self, points):
            self.points_vie += points
            print(f"{self.nom} a récupéré {points} points de vie. Points de vie actuels : {self.points_vie}")
            </code></pre>
        
            <h4>4. Code Complet de la Classe <code>Personnage</code> :</h4>
            <pre><code>class Personnage:
            def __init__(self, nom, points_vie, force, position=(0, 0)):
                self.nom = nom
                self.points_vie = points_vie
                self.force = force
                self.position = position
        
            def afficher_informations(self):
                print(f"Nom : {self.nom}")
                print(f"Points de vie : {self.points_vie}")
                print(f"Force : {self.force}")
                print(f"Position : {self.position}")
        
            def se_deplacer(self, direction):
                x, y = self.position
                if direction == "haut":
                    self.position = (x, y + 1)
                elif direction == "bas":
                    self.position = (x, y - 1)
                elif direction == "gauche":
                    self.position = (x - 1, y)
                elif direction == "droite":
                    self.position = (x + 1, y)
                print(f"{self.nom} s'est déplacé vers {direction}. Nouvelle position : {self.position}")
        
            def attaquer(self, cible):
                print(f"{self.nom} attaque {cible.nom} avec une force de {self.force}")
                cible.points_vie -= self.force
                print(f"{cible.nom} a maintenant {cible.points_vie} points de vie restants.")
                if cible.points_vie <= 0:
                    print(f"{cible.nom} a été vaincu !")
        
            def soigner(self, points):
                self.points_vie += points
                print(f"{self.nom} a récupéré {points} points de vie. Points de vie actuels : {self.points_vie}")
            </code></pre>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Créez deux personnages avec des noms, des points de vie, et des forces différentes.</li>
                <li><strong>Étape 2 :</strong> Faites-les se déplacer sur une grille et simulez un combat où chaque personnage attaque l'autre.</li>
                <li><strong>Étape 3 :</strong> Utilisez la méthode <code>soigner()</code> pour régénérer les points de vie d’un personnage après une attaque.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Analyse (15 min)</h3>
            <p>Les élèves auront appris à modéliser un personnage de jeu vidéo en utilisant la POO. Ils auront mis en pratique les concepts de classe, d'attributs et de méthodes pour créer un modèle de personnage complet capable de se déplacer, d’attaquer et de se soigner. Cette structure de code pourra être réutilisée et étendue dans des projets futurs pour simuler des comportements plus complexes dans un jeu vidéo.</p>
        </section>

        <section id="session39" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 39 : Héritage et Polymorphisme (Théorie)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Cette séance a pour but de permettre aux élèves de comprendre les concepts d'héritage et de polymorphisme en programmation orientée objet (POO). Ils apprendront comment utiliser l'héritage pour structurer le code et comment le polymorphisme permet de gérer différentes méthodes de manière flexible et uniforme.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction à l'Héritage et au Polymorphisme</h3>
            
            <h4>Qu'est-ce que la Programmation Orientée Objet (POO) ?</h4>
            <p>La programmation orientée objet est un paradigme de programmation qui permet de structurer les programmes en utilisant des objets. Chaque objet est une instance d'une <strong>classe</strong>, et les classes permettent de regrouper des <strong>attributs</strong> (données) et des <strong>méthodes</strong> (fonctions) qui définissent le comportement des objets.</p>
            <p>Deux concepts clés en POO sont l'<strong>héritage</strong> et le <strong>polymorphisme</strong>, qui permettent de créer des structures de code réutilisables et flexibles.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Partie 1 : L'Héritage (50 min)</h3>
            
            <h4>1. Définition de l'Héritage</h4>
            <p>L'héritage permet de créer une nouvelle classe qui <strong>hérite</strong> des attributs et méthodes d'une classe existante. La classe existante est appelée <strong>classe parente</strong> (ou super-classe), et la nouvelle classe est appelée <strong>classe enfant</strong> (ou sous-classe).</p>
            <p>En utilisant l'héritage, la classe enfant peut :</p>
            <ul>
                <li>Accéder aux attributs et méthodes de la classe parente.</li>
                <li>Ajouter ses propres attributs et méthodes.</li>
                <li>Redéfinir (ou <em>surcharger</em>) certaines méthodes de la classe parente.</li>
            </ul>
        
            <h4>2. Avantages de l'Héritage</h4>
            <p>L'héritage permet de :</p>
            <ul>
                <li>Réutiliser le code existant, ce qui rend le programme plus efficace et facile à maintenir.</li>
                <li>Organiser les classes en hiérarchies, ce qui facilite la compréhension de la structure du programme.</li>
                <li>Éviter la duplication du code en centralisant les méthodes et attributs communs dans la classe parente.</li>
            </ul>
        
            <h4>3. Exemple d'Héritage dans un Jeu Vidéo</h4>
            <p>Imaginons un jeu où il y a plusieurs types de personnages : des guerriers, des mages et des archers. Tous les personnages partagent des caractéristiques communes, comme un nom et des points de vie, mais chaque type de personnage a des capacités spécifiques.</p>
            <p>Nous pouvons définir une <strong>classe parente</strong> appelée <code>Personnage</code>, et des <strong>classes enfants</strong> pour chaque type de personnage :</p>
            
            <pre><code>class Personnage:
            def __init__(self, nom, points_vie):
                self.nom = nom
                self.points_vie = points_vie
        
            def se_presenter(self):
                print(f"Je suis {self.nom} avec {self.points_vie} points de vie.")
        
        class Guerrier(Personnage):
            def __init__(self, nom, points_vie, force):
                super().__init__(nom, points_vie)  # Appel du constructeur de la classe parente
                self.force = force
        
            def attaquer(self):
                print(f"{self.nom} attaque avec une force de {self.force}!")
        
        class Mage(Personnage):
            def __init__(self, nom, points_vie, mana):
                super().__init__(nom, points_vie)
                self.mana = mana
        
            def lancer_sort(self):
                print(f"{self.nom} lance un sort avec {self.mana} points de mana!")
            </code></pre>
        
            <p>Dans cet exemple :</p>
            <ul>
                <li>La classe <code>Personnage</code> est la <strong>classe parente</strong>, contenant des attributs communs (<code>nom</code> et <code>points_vie</code>).</li>
                <li>Les classes <code>Guerrier</code> et <code>Mage</code> sont des <strong>classes enfants</strong> qui héritent de <code>Personnage</code>.</li>
                <li>Chaque classe enfant ajoute ses propres attributs (<code>force</code> pour <code>Guerrier</code> et <code>mana</code> pour <code>Mage</code>), et peut aussi définir des méthodes spécifiques comme <code>attaquer()</code> et <code>lancer_sort()</code>.</li>
            </ul>
        
            <h4>4. Exercices Pratiques</h4>
            <ul>
                <li>Créer une classe enfant <code>Archer</code> qui hérite de <code>Personnage</code> et ajoute un attribut spécifique comme <code>precison</code>.</li>
                <li>Implémenter une méthode pour chaque classe enfant qui utilise les attributs spécifiques de chaque personnage.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Partie 2 : Le Polymorphisme (50 min)</h3>
        
            <h4>1. Définition du Polymorphisme</h4>
            <p>Le polymorphisme est la capacité d'utiliser une même méthode sur des objets de classes différentes. Avec le polymorphisme, des objets de différentes classes peuvent être manipulés de manière uniforme en utilisant une interface commune.</p>
            <p>Dans l'exemple précédent, tous les personnages peuvent être appelés pour se présenter ou exécuter une action, quelle que soit leur classe. Cela permet de traiter différents objets de manière homogène.</p>
        
            <h4>2. Exemple de Polymorphisme</h4>
            <p>Nous allons utiliser le polymorphisme pour faire en sorte que chaque personnage (qu’il soit guerrier, mage ou archer) puisse exécuter une méthode commune <code>agir()</code> mais avec un comportement propre à chaque type de personnage.</p>
        
            <pre><code>class Personnage:
            def agir(self):
                print("Le personnage effectue une action.")
        
        class Guerrier(Personnage):
            def agir(self):
                print("Le guerrier attaque avec une épée!")
        
        class Mage(Personnage):
            def agir(self):
                print("Le mage lance un sort!")
        
        class Archer(Personnage):
            def agir(self):
                print("L'archer tire une flèche!")
            </code></pre>
        
            <h4>3. Utilisation Pratique du Polymorphisme</h4>
            <p>En utilisant le polymorphisme, nous pouvons créer une liste de personnages et les faire agir de manière uniforme :</p>
            
            <pre><code>personnages = [Guerrier(), Mage(), Archer()]
        
        for personnage in personnages:
            personnage.agir()  # Chaque personnage agit de manière spécifique
            </code></pre>
        
            <p>Dans cet exemple, chaque personnage exécute la méthode <code>agir()</code>, mais le comportement de cette méthode est propre à chaque classe. C’est là que réside la puissance du polymorphisme, car il permet d’utiliser une interface commune pour des comportements différents.</p>
        
            <h4>4. Exercices Pratiques</h4>
            <ul>
                <li>Ajouter d'autres types de personnages avec des comportements spécifiques dans la méthode <code>agir()</code>.</li>
                <li>Créer une fonction qui prend une liste de personnages et fait agir chaque personnage, démontrant ainsi le polymorphisme.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion (20 min)</h3>
            <h4>Résumé des Concepts :</h4>
            <ul>
                <li><strong>Héritage :</strong> Permet à une classe enfant d'hériter des attributs et méthodes d'une classe parente, réduisant la duplication de code.</li>
                <li><strong>Polymorphisme :</strong> Permet à des objets de classes différentes de répondre à une méthode commune de manière spécifique, offrant une grande flexibilité dans le code.</li>
            </ul>
        
            <h4>Discussion :</h4>
            <p>Discutez avec les élèves des avantages de l’héritage et du polymorphisme dans les projets de programmation. En particulier, abordez comment ces concepts permettent de structurer le code de manière claire et réutilisable dans des projets complexes, comme des jeux vidéo ou des applications de gestion.</p>
        </section>

        <section id="session40" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 40 : Pratique - Implémentation d’un Système d’Héritage dans une Application de Gestion de Personnages (Jeu Vidéo)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Les élèves apprendront à implémenter un système d’héritage en programmation orientée objet dans un contexte de jeu vidéo. Ils créeront une hiérarchie de classes pour représenter différents types de personnages dans un jeu (comme des joueurs, des ennemis, et des PNJ) et apprendront à utiliser l'héritage pour partager des caractéristiques et des comportements communs.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction à l’Héritage dans le Contexte du Jeu Vidéo</h3>
            
            <h4>Contexte :</h4>
            <p>Dans de nombreux jeux vidéo, il existe différents types de personnages : le joueur, des ennemis, et des PNJ (personnages non jouables) qui interagissent avec le joueur. Bien que chaque type de personnage ait ses propres caractéristiques, ils partagent également des propriétés communes comme des points de vie, une position, et des méthodes pour se déplacer ou attaquer.</p>
            
            <p>L’héritage permet de créer une structure de classes où les personnages partagent des attributs communs tout en ayant des comportements spécifiques. Par exemple :</p>
            <ul>
                <li>Un <strong>Personnage</strong> de base peut avoir des attributs comme des <code>points_de_vie</code> et une <code>position</code>.</li>
                <li>Un <strong>Joueur</strong> peut hériter de la classe <code>Personnage</code> et avoir des méthodes supplémentaires, comme <code>attaquer</code> ou <code>utiliser_objet</code>.</li>
                <li>Un <strong>Ennemi</strong> peut également hériter de <code>Personnage</code> et avoir une méthode <code>poursuivre_joueur</code>.</li>
            </ul>
            
            <h4>Exemple de Structure de Classe :</h4>
            <pre><code>Personnage (classe de base)
        ├── Joueur (hérite de Personnage)
        └── Ennemi (hérite de Personnage)
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Définition des Classes de Base (30 min)</h3>
        
            <h4>1. Création de la Classe de Base : Personnage</h4>
            <p>La classe <code>Personnage</code> représente tous les personnages du jeu, qu’ils soient joueurs, ennemis ou PNJ. Elle contient des attributs et méthodes de base que tous les personnages partagent.</p>
        
            <pre><code>class Personnage:
            def __init__(self, nom, points_de_vie, position):
                self.nom = nom
                self.points_de_vie = points_de_vie
                self.position = position
        
            def se_deplacer(self, x, y):
                self.position = (x, y)
                print(f"{self.nom} se déplace à la position {self.position}")
        
            def afficher_statut(self):
                print(f"{self.nom} - PV : {self.points_de_vie}")
            </code></pre>
        
            <ul>
                <li><strong>Attributs :</strong> <code>nom</code>, <code>points_de_vie</code>, et <code>position</code>.</li>
                <li><strong>Méthodes :</strong> <code>se_deplacer</code> pour déplacer le personnage, et <code>afficher_statut</code> pour afficher ses points de vie.</li>
            </ul>
        
            <h4>2. Création de la Classe Joueur</h4>
            <p>La classe <code>Joueur</code> hérite de <code>Personnage</code>. Elle représente le personnage contrôlé par le joueur et ajoute des méthodes spécifiques, comme l'attaque.</p>
        
            <pre><code>class Joueur(Personnage):
            def __init__(self, nom, points_de_vie, position, niveau):
                super().__init__(nom, points_de_vie, position)
                self.niveau = niveau
        
            def attaquer(self, cible):
                print(f"{self.nom} attaque {cible.nom}!")
                cible.points_de_vie -= 10
                if cible.points_de_vie <= 0:
                    print(f"{cible.nom} est vaincu!")
            </code></pre>
        
            <ul>
                <li><strong>Attribut spécifique :</strong> <code>niveau</code> du joueur.</li>
                <li><strong>Méthode spécifique :</strong> <code>attaquer</code>, qui réduit les points de vie d'une cible.</li>
            </ul>
        
            <h4>3. Création de la Classe Ennemi</h4>
            <p>La classe <code>Ennemi</code> hérite également de <code>Personnage</code>. Elle représente un ennemi qui peut poursuivre le joueur.</p>
        
            <pre><code>class Ennemi(Personnage):
            def __init__(self, nom, points_de_vie, position, force):
                super().__init__(nom, points_de_vie, position)
                self.force = force
        
            def poursuivre_joueur(self, joueur):
                print(f"{self.nom} poursuit {joueur.nom}!")
                # Logique simplifiée pour déplacer l'ennemi vers la position du joueur
                self.position = joueur.position
                print(f"{self.nom} se déplace vers la position {self.position}")
            </code></pre>
        
            <ul>
                <li><strong>Attribut spécifique :</strong> <code>force</code> de l’ennemi.</li>
                <li><strong>Méthode spécifique :</strong> <code>poursuivre_joueur</code>, qui permet à l'ennemi de se déplacer vers la position du joueur.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Mise en Pratique : Interaction entre Personnages (45 min)</h3>
            
            <h4>1. Initialisation des Personnages</h4>
            <p>Nous allons créer une instance de chaque classe pour tester leur interaction dans le jeu.</p>
        
            <pre><code># Création des personnages
        joueur = Joueur("Héros", 100, (0, 0), niveau=5)
        ennemi = Ennemi("Gobelin", 50, (5, 5), force=3)
        
        # Afficher le statut initial
        joueur.afficher_statut()
        ennemi.afficher_statut()
            </code></pre>
        
            <h4>2. Déplacement et Interaction</h4>
            <p>Déplaçons le joueur et l'ennemi, et faisons en sorte que le joueur attaque l'ennemi.</p>
        
            <pre><code># Déplacement du joueur et de l'ennemi
        joueur.se_deplacer(2, 2)
        ennemi.poursuivre_joueur(joueur)
        
        # Interaction : le joueur attaque l'ennemi
        joueur.attaquer(ennemi)
        
        # Afficher le statut après l'attaque
        ennemi.afficher_statut()
            </code></pre>
        
            <h4>3. Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Ajouter une nouvelle classe <code>PNJ</code> (personnage non jouable) qui hérite de <code>Personnage</code> et qui possède une méthode <code>parler</code>.</li>
                <li><strong>Étape 2 :</strong> Créer plusieurs instances de chaque type de personnage et tester leurs interactions.</li>
                <li><strong>Étape 3 :</strong> Ajouter une méthode <code>soigner</code> au <code>Joueur</code> pour restaurer des points de vie.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion (5 min)</h3>
            <p>À la fin de cette séance, les élèves auront appris à implémenter un système d'héritage pour organiser différents types de personnages dans un jeu vidéo. Ils auront vu comment l'héritage permet de partager des attributs communs tout en ajoutant des fonctionnalités spécifiques à chaque type de personnage.</p>
        
            <h4>Points de Discussion :</h4>
            <ul>
                <li>Comment l'héritage permet-il de simplifier et de structurer le code ?</li>
                <li>Quels avantages apporte l'héritage lorsqu'on ajoute de nouveaux types de personnages ?</li>
            </ul>
        </section>

        <section id="session41" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 41 : Introduction aux Design Patterns - Singleton et Factory</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Cette séance introduit deux design patterns essentiels en programmation orientée objet : le <strong>Singleton</strong> et le <strong>Factory</strong>. Les élèves apprendront comment utiliser ces patterns dans le développement d’un jeu vidéo pour simplifier la gestion des objets et optimiser le code.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Qu'est-ce qu'un Design Pattern ?</h3>
            <p>Un <strong>design pattern</strong> (ou patron de conception) est une solution standardisée pour résoudre des problèmes récurrents en développement logiciel. Les design patterns facilitent la maintenance, la compréhension et l'extensibilité du code en structurant les solutions de manière efficace.</p>
            <p>Les deux design patterns abordés aujourd'hui sont :</p>
            <ul>
                <li><strong>Singleton :</strong> Assure qu'une classe n'ait qu'une seule instance et fournit un point d'accès global à cette instance.</li>
                <li><strong>Factory :</strong> Simplifie la création d'objets en centralisant leur instanciation, permettant de choisir dynamiquement le type d'objet à créer.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Design Pattern Singleton (40 min)</h3>
        
            <h4>1. Principe du Singleton :</h4>
            <p>Le Singleton est un design pattern qui permet de restreindre l'instanciation d'une classe à une seule instance. Ce pattern est utile lorsque vous avez besoin d'un seul point de contrôle dans votre application.</p>
        
            <h4>Exemple d’Utilisation en Jeu Vidéo :</h4>
            <p>Dans un jeu vidéo, on peut utiliser le Singleton pour la <strong>gestion des paramètres de jeu</strong> ou la <strong>musique de fond</strong>. Par exemple, le jeu n’a besoin que d’une seule instance de musique en arrière-plan, et cette instance doit être accessible partout dans le code.</p>
        
            <h4>Implémentation du Singleton en Python :</h4>
            <p>Voici un exemple d’implémentation de Singleton pour la gestion de la musique de fond dans un jeu vidéo :</p>
        
            <pre><code>class MusiqueDeFond:
            _instance = None  # Stocke l'unique instance de la classe
        
            def __new__(cls):
                if cls._instance is None:
                    cls._instance = super(MusiqueDeFond, cls).__new__(cls)
                    cls._instance.volume = 50  # Par exemple, un volume par défaut
                    print("Nouvelle instance de MusiqueDeFond créée.")
                return cls._instance
            
            def jouer(self):
                print("La musique de fond joue.")
        
            def regler_volume(self, niveau):
                self.volume = niveau
                print(f"Volume réglé à : {self.volume}")
            </code></pre>
        
            <h4>Explication du Code :</h4>
            <ul>
                <li><strong>La méthode <code>__new__</code></strong> vérifie si une instance de <code>MusiqueDeFond</code> existe déjà. Si ce n'est pas le cas, elle en crée une. Sinon, elle retourne l'instance existante.</li>
                <li>En instanciant la classe plusieurs fois, on s'apercevra que la même instance est utilisée à chaque appel.</li>
            </ul>
        
            <h4>Exemple Pratique :</h4>
            <p>Testons le Singleton :</p>
        
            <pre><code>musique1 = MusiqueDeFond()
        musique2 = MusiqueDeFond()
        
        musique1.jouer()
        musique2.regler_volume(75)
        
        print(musique1.volume)  # Affichera 75, car musique1 et musique2 pointent vers la même instance
            </code></pre>
        
            <h4>Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Créez une classe Singleton pour la gestion des paramètres de jeu (volume global, difficulté).</li>
                <li><strong>Étape 2 :</strong> Utilisez le Singleton pour modifier et afficher les paramètres dans différentes parties du code.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Design Pattern Factory (40 min)</h3>
        
            <h4>1. Principe du Factory :</h4>
            <p>Le pattern Factory centralise la création d’objets dans une méthode ou une classe dédiée, ce qui permet de créer dynamiquement des instances de différents types selon les besoins. Cela rend le code plus flexible et plus facilement modifiable.</p>
        
            <h4>Exemple d’Utilisation en Jeu Vidéo :</h4>
            <p>Dans un jeu vidéo, le pattern Factory est utile pour créer des objets dynamiquement, comme des ennemis, des objets à ramasser, ou des obstacles. Par exemple, le jeu peut décider de créer différents types d’ennemis en fonction du niveau.</p>
        
            <h4>Implémentation d’un Factory en Python :</h4>
            <p>Imaginons une Factory qui génère différents types d’ennemis dans un jeu.</p>
        
            <pre><code>class Ennemi:
            def __init__(self, type_ennemi):
                self.type = type_ennemi
        
            def attaquer(self):
                print(f"L'ennemi de type {self.type} attaque !")
        
        class EnnemiFactory:
            @staticmethod
            def creer_ennemi(type_ennemi):
                return Ennemi(type_ennemi)
            </code></pre>
        
            <h4>Explication du Code :</h4>
            <ul>
                <li><strong>La classe <code>Ennemi</code></strong> représente un ennemi avec un type défini lors de sa création.</li>
                <li><strong>La classe <code>EnnemiFactory</code></strong> possède une méthode statique <code>creer_ennemi</code> qui prend le type d'ennemi en paramètre et retourne une instance d’<code>Ennemi</code>.</li>
            </ul>
        
            <h4>Exemple Pratique :</h4>
            <p>Utilisons la Factory pour créer différents types d'ennemis :</p>
        
            <pre><code># Utilisation de la Factory pour créer des ennemis
        gobelin = EnnemiFactory.creer_ennemi("gobelin")
        troll = EnnemiFactory.creer_ennemi("troll")
        
        gobelin.attaquer()  # Affiche : L'ennemi de type gobelin attaque !
        troll.attaquer()    # Affiche : L'ennemi de type troll attaque !
            </code></pre>
        
            <h4>Défi Pratique pour les Élèves :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Ajoutez d’autres types d’ennemis (ex. : dragon, sorcier) en utilisant la Factory.</li>
                <li><strong>Étape 2 :</strong> Créez une liste d'ennemis en utilisant un tableau et utilisez la Factory pour instancier chaque ennemi de manière dynamique.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Comparaison des Patterns Singleton et Factory (20 min)</h3>
        
            <h4>Comparaison :</h4>
            <p>Bien que Singleton et Factory soient tous deux des patterns de création, ils répondent à des besoins différents :</p>
            <ul>
                <li><strong>Singleton :</strong> Assure qu’une seule instance d’une classe existe à tout moment. Cela est utile pour des objets globaux qui nécessitent un contrôle centralisé (comme les paramètres de jeu ou la musique).</li>
                <li><strong>Factory :</strong> Simplifie la création d'objets diversifiés en centralisant leur instanciation. Cela est pratique pour créer plusieurs objets de types différents selon le contexte (comme des ennemis de types différents dans un jeu).</li>
            </ul>
        
            <h4>Avantages et Inconvénients :</h4>
            <table>
                <tr>
                    <th>Pattern</th>
                    <th>Avantages</th>
                    <th>Inconvénients</th>
                </tr>
                <tr>
                    <td>Singleton</td>
                    <td>
                        <ul>
                            <li>Contrôle centralisé de l’accès à l’instance unique.</li>
                            <li>Réduction de la consommation de mémoire pour les objets globaux.</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Peut entraîner une dépendance excessive au Singleton.</li>
                            <li>Peut devenir difficile à tester si mal utilisé.</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Factory</td>
                    <td>
                        <ul>
                            <li>Modularité et flexibilité dans la création d'objets.</li>
                            <li>Facilité de modification et d'extension du code.</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Peut compliquer la structure du code si utilisé pour des objets simples.</li>
                        </ul>
                    </td>
                </tr>
            </table>
        
            <h4>Conclusion :</h4>
            <p>Les design patterns Singleton et Factory sont des outils puissants pour améliorer la structure et la lisibilité du code. Le Singleton est idéal pour la gestion des ressources uniques, tandis que le Factory permet de créer des objets variés selon le contexte.</p>
        </section>

        <section id="session42" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 42 : Pratique - Utilisation de Design Patterns pour Optimiser la Gestion des Niveaux d’un Jeu Vidéo</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif Global :</h3>
            <p>Cette séance vise à introduire certains <strong>design patterns</strong> courants en programmation orientée objet et à les appliquer pour optimiser la gestion des niveaux dans un jeu vidéo. Les élèves apprendront à structurer leur code en utilisant des patterns comme le <strong>Singleton</strong> et le <strong>Factory</strong> pour améliorer l'organisation, la réutilisabilité et l'évolutivité de leur code.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Introduction aux Design Patterns</h3>
            <h4>Qu’est-ce qu’un Design Pattern ?</h4>
            <p>Un design pattern est une solution générale et réutilisable à un problème récurrent dans un contexte spécifique. En programmation orientée objet, les design patterns permettent de structurer le code pour qu'il soit plus facile à comprendre, à maintenir et à faire évoluer.</p>
        
            <h4>Design Patterns Utiles pour la Gestion des Niveaux :</h4>
            <ul>
                <li><strong>Singleton :</strong> Utilisé pour s'assurer qu'une classe n'a qu'une seule instance à tout moment, ce qui est utile pour la gestion des niveaux du jeu.</li>
                <li><strong>Factory :</strong> Utilisé pour créer des objets sans exposer la logique de création. Il est idéal pour créer différents types de niveaux (ex. : niveau facile, moyen, difficile) sans modifier le code existant.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Pattern Singleton pour la Gestion du Niveau Actuel (30 min)</h3>
        
            <h4>Principe du Singleton :</h4>
            <p>Le Singleton est un design pattern qui garantit qu’une classe n’a qu’une seule instance dans l’application. Pour un jeu vidéo, cela permet de s’assurer qu’il n’y a qu’un seul niveau actif à un moment donné.</p>
        
            <h4>Application dans le Jeu Vidéo :</h4>
            <p>Nous allons utiliser le Singleton pour gérer le niveau actuel du jeu. En utilisant ce pattern, nous pouvons facilement accéder au niveau en cours sans créer d’instances supplémentaires par erreur.</p>
        
            <h4>Implémentation du Singleton en Python :</h4>
            <p>Voici un exemple d'implémentation du pattern Singleton pour un objet <code>Niveau</code> :</p>
        
            <pre><code>class Niveau:
            _instance = None  # Variable de classe pour stocker l'unique instance
        
            def __new__(cls):
                if cls._instance is None:
                    cls._instance = super(Niveau, cls).__new__(cls)
                    cls._instance.nom = None
                    cls._instance.difficulte = None
                return cls._instance
        
            def configurer_niveau(self, nom, difficulte):
                self.nom = nom
                self.difficulte = difficulte
        
            def afficher_details(self):
                print(f"Niveau: {self.nom}, Difficulté: {self.difficulte}")
            
        # Utilisation du Singleton
        niveau_actuel = Niveau()
        niveau_actuel.configurer_niveau("Forêt Mystique", "Facile")
        niveau_actuel.afficher_details()
        
        # Tentative de création d'un autre niveau
        autre_niveau = Niveau()
        autre_niveau.afficher_details()
            </code></pre>
        
            <h4>Explication du Code :</h4>
            <ul>
                <li><code>_instance</code> est une variable de classe utilisée pour stocker l’unique instance de la classe.</li>
                <li>La méthode <code>__new__</code> vérifie si une instance existe déjà ; si ce n’est pas le cas, elle en crée une, sinon elle retourne l'instance existante.</li>
                <li><code>configurer_niveau</code> permet de définir le nom et la difficulté du niveau actuel.</li>
            </ul>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Ajoutez une méthode pour changer la difficulté du niveau sans créer de nouvelle instance.</li>
                <li><strong>Étape 2 :</strong> Utilisez le Singleton pour garantir qu'un seul niveau est actif à la fois dans votre jeu.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Pattern Factory pour la Création Dynamique de Niveaux (30 min)</h3>
        
            <h4>Principe du Factory :</h4>
            <p>Le pattern Factory fournit une méthode pour créer des objets de manière dynamique, sans exposer la logique de création. Ce pattern est utile lorsque le jeu doit créer des niveaux de difficulté variable (par exemple, facile, moyen, difficile) en fonction des choix du joueur.</p>
        
            <h4>Application dans le Jeu Vidéo :</h4>
            <p>Nous allons implémenter une <strong>classe Factory</strong> qui génère des niveaux en fonction de leur difficulté. Cela permettra de créer de nouveaux types de niveaux sans modifier le code existant, ce qui rend le jeu plus flexible.</p>
        
            <h4>Implémentation du Pattern Factory en Python :</h4>
            <p>Voici un exemple d'implémentation du pattern Factory pour créer des niveaux de difficulté différente :</p>
        
            <pre><code>class Niveau:
            def __init__(self, nom, difficulte):
                self.nom = nom
                self.difficulte = difficulte
        
            def afficher_details(self):
                print(f"Niveau: {self.nom}, Difficulté: {self.difficulte}")
        
        class NiveauFactory:
            @staticmethod
            def creer_niveau(difficulte):
                if difficulte == "facile":
                    return Niveau("Plaine Verte", "Facile")
                elif difficulte == "moyen":
                    return Niveau("Désert Brûlant", "Moyen")
                elif difficulte == "difficile":
                    return Niveau("Montagne des Ombres", "Difficile")
                else:
                    print("Difficulté inconnue. Création d'un niveau par défaut.")
                    return Niveau("Plaine Inconnue", "Facile")
        
        # Utilisation de la Factory
        niveau_facile = NiveauFactory.creer_niveau("facile")
        niveau_facile.afficher_details()
        
        niveau_difficile = NiveauFactory.creer_niveau("difficile")
        niveau_difficile.afficher_details()
            </code></pre>
        
            <h4>Explication du Code :</h4>
            <ul>
                <li>La classe <code>Niveau</code> représente un niveau du jeu avec un nom et une difficulté.</li>
                <li>La <code>NiveauFactory</code> est une classe Factory qui crée des objets <code>Niveau</code> en fonction de la difficulté demandée.</li>
                <li>La méthode <code>creer_niveau</code> génère un niveau spécifique pour chaque difficulté, rendant la création d'objets flexible et modulaire.</li>
            </ul>
        
            <h4>Défi Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Ajoutez un niveau de difficulté supplémentaire (par exemple, "expert") dans la Factory.</li>
                <li><strong>Étape 2 :</strong> Intégrez la Factory dans le jeu pour permettre au joueur de choisir la difficulté de chaque niveau.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Application Pratique : Gestion Optimisée des Niveaux dans un Jeu (30 min)</h3>
        
            <h4>Conception du Projet :</h4>
            <p>Combinez le Singleton et le Factory pour gérer les niveaux dans un jeu vidéo. Utilisez le Singleton pour contrôler le niveau actif et le Factory pour créer des niveaux en fonction de la difficulté choisie par le joueur.</p>
        
            <h4>Exercice Pratique :</h4>
            <ul>
                <li><strong>Étape 1 :</strong> Créez une classe <code>GestionNiveaux</code> qui utilise le Singleton pour garder le niveau actif.</li>
                <li><strong>Étape 2 :</strong> Utilisez la Factory pour créer de nouveaux niveaux et les assigner au niveau actif à chaque nouvelle étape.</li>
                <li><strong>Étape 3 :</strong> Testez le système en créant plusieurs niveaux et en changeant dynamiquement la difficulté.</li>
            </ul>
        
            <h4>Code Exemple pour la Gestion des Niveaux :</h4>
            <pre><code>class GestionNiveaux:
            _instance = None
        
            def __new__(cls):
                if cls._instance is None:
                    cls._instance = super(GestionNiveaux, cls).__new__(cls)
                    cls._instance.niveau_actuel = None
                return cls._instance
        
            def definir_niveau(self, niveau):
                self.niveau_actuel = niveau
                print("Niveau défini :")
                self.niveau_actuel.afficher_details()
        
        # Création de niveaux via la Factory et gestion par Singleton
        gestionnaire = GestionNiveaux()
        niveau_facile = NiveauFactory.creer_niveau("facile")
        gestionnaire.definir_niveau(niveau_facile)
        
        niveau_difficile = NiveauFactory.creer_niveau("difficile")
        gestionnaire.definir_niveau(niveau_difficile)
            </code></pre>
        
            <h4>Conclusion :</h4>
            <p>À la fin de cette séance, les élèves auront appris à utiliser les patterns Singleton et Factory pour gérer la création et la gestion des niveaux dans un jeu vidéo. Ils auront appliqué ces design patterns pour structurer et optimiser le code, le rendant plus facile à maintenir et à faire évoluer.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion et Discussion (10 min)</h3>
            <p>Les élèves sont encouragés à discuter de la manière dont les design patterns peuvent améliorer la qualité du code dans des projets de grande envergure, comme les jeux vidéo. Nous discuterons également de l'intérêt d'utiliser ces patterns dans d'autres contextes, tels que la gestion des personnages ou des objets dans un jeu.</p>
        </section>
    </main>

    <!-- <footer>
        <p>&copy; 2024 Programme NSI Tle</p>
    </footer> -->

    <script>
        const holidays = {
            '2024-11-11': 'Armistice 1918',
            '2024-12-25': 'Noël',
            '2025-01-01': 'Jour de l\'An',
            '2025-04-21': 'Lundi de Pâques',
            '2025-05-01': 'Fête du Travail',
            '2025-05-08': 'Victoire 1945',
            '2025-05-29': 'Ascension',
            '2025-06-09': 'Lundi de Pentecôte'
        };
    
        const vacations = [
            { start: '2024-10-19', end: '2024-11-03', name: 'Vacances de la Toussaint' },
            { start: '2024-12-21', end: '2025-01-05', name: 'Vacances de Noël' },
            { start: '2025-02-22', end: '2025-03-09', name: 'Vacances d\'hiver' },
            { start: '2025-04-19', end: '2025-05-04', name: 'Vacances de printemps' },
            { start: '2025-07-05', end: '2025-09-02', name: 'Vacances d\'été' }
        ];
    
        const sessions = [
            'Séance 1 : Introduction à la récursivité (concepts de base)',
            'Séance 2 : Pratique - Implémentation d’une fonction récursive pour calculer une suite mathématique',
            'Séance 3 : Applications pratiques de la récursivité (problèmes simples)',
            'Séance 4 : Introduction aux Algorithmes de Recherche Récursive – Recherche Binaire',
            'Séance 5 : Pratique – Recherche d’un Personnage de Manga avec un Algorithme de Recherche Binaire',
            'Séance 6 : Analyse de la Complexité d’un Algorithme de Recherche Récursive',
            'Séance 7 : Introduction au Backtracking (Concepts de Base)',
            'Séance 8 : Pratique - Résolution d\'un Labyrinthe avec Backtracking (Jeu Vidéo)',
            'Séance 9 : Étude des Cas Où le Backtracking Est Utile et de Ses Limitations',
            'Séance 10 : Introduction à la Complexité Algorithmique – Notation Big-O',
            'Séance 11 : Pratique - Comparaison des Algorithmes de Tri Simples (Insertion, Sélection)',
            'Séance 12 : Exercices d’Analyse de la Complexité des Algorithmes dans des Jeux Vidéo et la Vie Réelle',
            'Séance 13 : Introduction aux Graphes et à leurs Applications',
            'Séance 14 : Pratique - Représentation d\'un Réseau de Routes dans un Jeu Vidéo avec des Graphes',
            'Séance 15 : Algorithmes de Parcours de Graphes – DFS et BFS',
            'Séance 16 : Approfondissement sur l’algorithme DFS (Depth-First Search)',
            'Séance 17 : Pratique - Exploration d’un Monde Ouvert (Jeu Vidéo) avec DFS',
            'Séance 18 : Applications Réelles des Graphes (Réseaux Sociaux, Chemins dans les Transports)',
            'Séance 19 : Introduction aux Arbres Binaires et leurs Applications',
            'Séance 20 : Pratique - Utilisation d’arbres pour organiser une base de données de personnages de manga',
            'Séance 21 : Algorithmes de Parcours d’Arbres (Pré-ordre, En-ordre, Post-ordre)',
            'Séance 22 : Approfondissement sur les Algorithmes de Parcours d’Arbres',
            'Séance 23 : Pratique - Création d’un Arbre de Décision pour un Jeu de Rôle (Jeu Vidéo)',
            'Séance 24 : Analyse des performances et avantages des arbres dans la recherche et le tri',
            'Séance 25 : Introduction au Tri Rapide (Quicksort)',
            'Séance 26 : Pratique - Implémentation du Quicksort pour trier des scores de jeu vidéo',
            'Séance 27 : Comparaison de la complexité des différents algorithmes de tri',
            'Séance 28 : Introduction au tri par tas (Heapsort)',
            'Séance 29 : Pratique - Utilisation du Heapsort pour organiser un inventaire dans un jeu vidéo',
            'Séance 30 : Analyse de la Complexité du Heapsort et de ses Applications',
            'Séance 31 : Introduction au Tri Fusion (Merge Sort)',
            'Séance 32 : Pratique - Implémentation du Tri Fusion pour Classer des Mangas par Popularité',
            'Séance 33 : Étude comparative des algorithmes de tri avancés (Quicksort, Heapsort, Merge Sort)',
            'Séance 34 : Optimisation des Algorithmes de Tri dans des Contextes Réels',
            'Séance 35 : Pratique - Choisir et implémenter l’algorithme de tri le plus efficace pour différentes situations',
            'Séance 36 : Révision et consolidation des concepts d\'algorithmes de tri',
            'Séance 37 : Introduction à la Programmation Orientée Objet (POO) – Classes, Objets, Méthodes',
            'Séance 38 : Pratique - Modélisation d’un personnage de jeu vidéo en POO',
            'Séance 39 : Héritage et Polymorphisme (Théorie)',
            'Séance 40 : Pratique - Implémentation d’un Système d’Héritage dans une Application de Gestion de Personnages (Jeu Vidéo)',
            'Séance 41 : Introduction aux Design Patterns - Singleton et Factory',
            'Séance 42 : Pratique - Utilisation de Design Patterns pour Optimiser la Gestion des Niveaux d’un Jeu Vidéo',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            ''
        ];
    
        function isHoliday(date) {
            return holidays[date] !== undefined;
        }
    
        function isInVacation(date) {
            const parsedDate = new Date(date);
            return vacations.some(vacation => {
                const startDate = new Date(vacation.start);
                const endDate = new Date(vacation.end);
                return parsedDate >= startDate && parsedDate <= endDate;
            });
        }
    
        function getVacationName(date) {
            const parsedDate = new Date(date);
            const vacation = vacations.find(vacation => {
                const startDate = new Date(vacation.start);
                const endDate = new Date(vacation.end);
                return parsedDate >= startDate && parsedDate <= endDate;
            });
            return vacation ? vacation.name : '';
        }
    
        function formatFrenchDate(date) {
            const options = { year: 'numeric', month: '2-digit', day: '2-digit' };
            return new Date(date).toLocaleDateString('fr-FR', options);
        }
    
        function isCurrentWeek(date) {
            const currentDate = new Date();
            const firstDayOfWeek = new Date(date);
            const lastDayOfWeek = new Date(firstDayOfWeek);
            lastDayOfWeek.setDate(firstDayOfWeek.getDate() + 6);
            return currentDate >= firstDayOfWeek && currentDate <= lastDayOfWeek;
        }

        function isToday(date) {
            const today = new Date().toISOString().split('T')[0];
            return today === date;
        }
    
        function generateCalendar() {
            const calendarBody = document.getElementById('calendar-body');
            const startDate = new Date('2024-09-04');  // Premier mercredi de septembre 2024
            const endDate = new Date('2025-07-12');
            
            let currentDate = startDate;
            let sessionIndex = 0;
    
            while (currentDate <= endDate) {
                const row = document.createElement('tr');
    
                // Mercredi
                const wednesdayDateString = currentDate.toISOString().split('T')[0];
                const wednesdayCell = document.createElement('td');
                wednesdayCell.textContent = formatFrenchDate(wednesdayDateString);
    
                const wednesdayDescCell = document.createElement('td');
                if (isHoliday(wednesdayDateString)) {
                    wednesdayDescCell.textContent = holidays[wednesdayDateString];
                    wednesdayCell.classList.add('holiday');
                    wednesdayDescCell.classList.add('holiday');
                } else if (isInVacation(wednesdayDateString)) {
                    wednesdayDescCell.textContent = getVacationName(wednesdayDateString);
                    row.classList.add('vacation');
                } else {
                    wednesdayDescCell.textContent = sessions[sessionIndex] || 'Séance à définir';
                    sessionIndex++;
                }

                // Mise en évidence du jour actuel
                if (isToday(wednesdayDateString)) {
                    wednesdayCell.classList.add('today');
                    wednesdayDescCell.classList.add('today');
                }
    
                // Jeudi
                currentDate.setDate(currentDate.getDate() + 1);  // Jeudi
                const thursdayDateString = currentDate.toISOString().split('T')[0];
                const thursdayCell = document.createElement('td');
                thursdayCell.textContent = formatFrenchDate(thursdayDateString);
    
                const thursdayDescCell = document.createElement('td');
                if (isHoliday(thursdayDateString)) {
                    thursdayDescCell.textContent = holidays[thursdayDateString];
                    thursdayCell.classList.add('holiday');
                    thursdayDescCell.classList.add('holiday');
                } else if (isInVacation(thursdayDateString)) {
                    thursdayDescCell.textContent = getVacationName(thursdayDateString);
                    row.classList.add('vacation');
                } else {
                    thursdayDescCell.textContent = sessions[sessionIndex] || 'Séance à définir';
                    sessionIndex++;
                }

                // Mise en évidence du jour actuel
                if (isToday(thursdayDateString)) {
                    thursdayCell.classList.add('today');
                    thursdayDescCell.classList.add('today');
                }
    
                // Vendredi
                currentDate.setDate(currentDate.getDate() + 1);  // Vendredi
                const fridayDateString = currentDate.toISOString().split('T')[0];
                const fridayCell = document.createElement('td');
                fridayCell.textContent = formatFrenchDate(fridayDateString);
    
                const fridayDescCell = document.createElement('td');
                if (isHoliday(fridayDateString)) {
                    fridayDescCell.textContent = holidays[fridayDateString];
                    fridayCell.classList.add('holiday');
                    fridayDescCell.classList.add('holiday');
                } else if (isInVacation(fridayDateString)) {
                    fridayDescCell.textContent = getVacationName(fridayDateString);
                    row.classList.add('vacation');
                } else {
                    fridayDescCell.textContent = sessions[sessionIndex] || 'Séance à définir';
                    sessionIndex++;
                }

                // Mise en évidence du jour actuel
                if (isToday(fridayDateString)) {
                    fridayCell.classList.add('today');
                    fridayDescCell.classList.add('today');
                }
    
                // // Mettre en évidence la semaine en cours
                // if (isCurrentWeek(currentDate)) {
                //     row.classList.add('current-week');
                // }
    
                // Ajout des cellules à la ligne
                row.appendChild(wednesdayCell);
                row.appendChild(wednesdayDescCell);
                row.appendChild(thursdayCell);
                row.appendChild(thursdayDescCell);
                row.appendChild(fridayCell);
                row.appendChild(fridayDescCell);
                calendarBody.appendChild(row);
    
                // Passer au mercredi suivant
                currentDate.setDate(currentDate.getDate() + 5);
            }
        }
    
        // Générer le calendrier au chargement de la page
        generateCalendar();    

        // Toggle menu visibility
        function toggleMenu() {
            const menu = document.getElementById("session-nav");
            menu.style.display = menu.style.display === "block" ? "none" : "block";
        }

        // Show selected session content
        function showSession(sessionId) {
            const sessions = document.querySelectorAll('.content-section');
            sessions.forEach(session => {
                session.classList.remove('active');
                if (session.id === sessionId) {
                    session.classList.add('active');
                }
            });

            // Mettre en évidence la séance active dans le menu
            const menuLinks = document.querySelectorAll('#session-nav a');
            menuLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('onclick').includes(sessionId)) {
                    link.classList.add('active');
                }
            });
        }

        // Display the first session by default when page loads
        document.addEventListener('DOMContentLoaded', () => {
            showSession('session0');
        });
    </script>

</body>
</html>
