<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programme NSI Tle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            background-color: #f4f4f4;
        }

        header {
            background-color: #4CAF50;
            color: white;
            text-align: center;
            padding: 1rem;
        }

        main {
            margin-left: 200px;
            padding: 20px;
            min-height: 80vh;
        }

        .content-section {
            display: none;
        }

        .content-section.active {
            display: block;
        }

        aside {
            position: fixed;
            left: 0;
            top: 0;
            height: 100%;
            width: 200px;
            background-color: #333;
            color: white;
            padding-top: 20px;
            transition: width 0.3s ease;
            overflow-y: auto;
            scrollbar-width: none; /* Masque la barre de défilement pour Firefox */
        }

        aside::-webkit-scrollbar {
            display: none; /* Masque la barre de défilement pour Chrome, Safari, et Opera */
        }

        aside ul {
            list-style: none;
            padding: 0;
        }

        aside ul li {
            padding: 10px;
        }

        aside ul li a {
            color: white;
            text-decoration: none;
            display: block;
            padding: 10px;
        }

        /* Style pour l'élément de menu actif (séance en cours) */
        aside ul li a.active {
            background-color: #4CAF50; /* Couleur pour l'élément actif */
            color: white;
            font-weight: bold;
        }

        aside ul li a:hover {
            background-color: #555;
        }

        .hamburger {
            background-color: #4CAF50;
            color: white;
            border: none;
            width: 100%;
            padding: 15px;
            text-align: left;
            cursor: pointer;
        }

        footer {
            background-color: #4CAF50;
            color: white;
            text-align: center;
            padding: 10px 0;
            position: fixed;
            bottom: 0;
            width: 100%;
        }

        h2 {
            color: #333;
            margin-bottom: 15px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }

        table, th, td {
            border: 1px solid black;
        }

        th, td {
            padding: 10px;
            text-align: center;
        }

        img {
            max-width: 100%;
            height: auto;
        }

        /* Styles spécifiques pour le calendrier */
        table.calendar {
            margin: 20px auto;
            border-collapse: collapse;
            width: 80%;
        }

        th, td {
            padding: 10px;
            text-align: center;
            border: 1px solid #ccc;
        }

        .current-week {
            background-color: #add8e6; /* Couleur bleue clair pour la semaine en cours */
        }

        pre{
            background-color: black;
            color: white;
        }

        .today {
            background-color: #007BFF; /* Bleu vif pour le jour actuel */
            color: white; /* Texte blanc pour le contraste */
        }

        .vacation {
            background-color: #B2E4A6; /* Vert pastel pour les vacances */
            color: black; /* Texte noir ou foncé pour la lisibilité */
        }

        .holiday {
            background-color: #FF6B6B; /* Rouge clair pour les jours fériés */
            color: white; /* Texte blanc ou clair */
        }
    </style>
</head>
<body>

    <header>
        <h1>Programme NSI Tle</h1>
    </header>

    <!-- Menu hamburger sur la gauche -->
    <aside id="menu">
        <button class="hamburger" onclick="toggleMenu()">☰ Séances</button>
        <nav id="session-nav">
            <ul>
                <!-- PROGRAMME -->
                <li><a href="#" onclick="showSession('programme-nsi')">Programme de l'année</a></li>

                <!-- CALENDRIER -->
                <li><a href="#" onclick="showSession('calendar')">Calendrier de cours</a></li>

                <!-- COURS -->
                <li><a href="#" onclick="showSession('session1')">Séance 1 : Introduction à la récursivité (concepts de base)</a></li>
                <li><a href="#" onclick="showSession('session2')">Séance 2 : Pratique - Implémentation d’une fonction récursive pour calculer une suite mathématique</a></li>
                <li><a href="#" onclick="showSession('session3')">Séance 3 : Applications pratiques de la récursivité (problèmes simples)</a></li>
                <li><a href="#" onclick="showSession('session4')">Séance 4 : </a></li>
                <li><a href="#" onclick="showSession('session5')">Séance 5 : </a></li>
                <li><a href="#" onclick="showSession('session6')">Séance 6 : </a></li>
                <li><a href="#" onclick="showSession('session7')">Séance 7 : </a></li>
                <li><a href="#" onclick="showSession('session8')">Séance 8 : </a></li>
                <li><a href="#" onclick="showSession('session9')">Séance 9 : Introduction aux Fonctions</a></li>
                <li><a href="#" onclick="showSession('session10')">Séance 10 : </a></li>
                <li><a href="#" onclick="showSession('session11')">Séance 11 : </a></li>
                <li><a href="#" onclick="showSession('session12')">Séance 12 : </a></li>
                <li><a href="#" onclick="showSession('session13')">Séance 13 : </a></li>
                <li><a href="#" onclick="showSession('session14')">Séance 14 : </a></li>
                <li><a href="#" onclick="showSession('session15')">Séance 15 : </a></li>
                <li><a href="#" onclick="showSession('session16')">Séance 16 : </a></li>
                <li><a href="#" onclick="showSession('session17')">Séance 17 : </a></li>
                <li><a href="#" onclick="showSession('session18')">Séance 18 : </a></li>
                <li><a href="#" onclick="showSession('session19')">Séance 19 : </a></li>
                <li><a href="#" onclick="showSession('session20')">Séance 20 : </a></li>
                <li><a href="#" onclick="showSession('session21')">Séance 21 : </a></li>
                <li><a href="#" onclick="showSession('session22')">Séance 22 : </a></li>
                <li><a href="#" onclick="showSession('session23')">Séance 23 : </a></li>
                <li><a href="#" onclick="showSession('session24')">Séance 24 : </a></li>
                <li><a href="#" onclick="showSession('session25')">Séance 25 : </a></li>
                <li><a href="#" onclick="showSession('session26')">Séance 26 : </a></li>
                <li><a href="#" onclick="showSession('session27')">Séance 27 : </a></li>
                <li><a href="#" onclick="showSession('session28')">Séance 28 : </a></li>
                <li><a href="#" onclick="showSession('session29')">Séance 29 : </a></li>
                <li><a href="#" onclick="showSession('session30')">Séance 30 : </a></li>
            </ul>
        </nav>
    </aside>

    <main id="content">
        <!-- Programme -->
        <section id="programme-nsi" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Programme Terminale NSI</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 1 : Récursivité</h3>
            <ul>
                <li><strong>Séance 1 :</strong> Introduction à la récursivité (concepts de base).</li>
                <li><strong>Séance 2 :</strong> Pratique - Implémentation d’une fonction récursive pour calculer une suite mathématique.</li>
                <li><strong>Séance 3 :</strong> Applications pratiques de la récursivité (problèmes simples).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 2 : Recherche Récursive</h3>
            <ul>
                <li><strong>Séance 4 :</strong> Introduction aux algorithmes de recherche récursive (recherche binaire).</li>
                <li><strong>Séance 5 :</strong> Pratique - Recherche d’un élément dans une liste de personnages de manga avec un algorithme de recherche binaire.</li>
                <li><strong>Séance 6 :</strong> Analyse de la complexité d'un algorithme de recherche récursive.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 3 : Backtracking</h3>
            <ul>
                <li><strong>Séance 7 :</strong> Introduction au backtracking (concepts de base).</li>
                <li><strong>Séance 8 :</strong> Pratique - Résolution d’un labyrinthe avec backtracking (jeu vidéo).</li>
                <li><strong>Séance 9 :</strong> Étude des cas où le backtracking est utile et de ses limitations.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 4 : Complexité Algorithmique</h3>
            <ul>
                <li><strong>Séance 10 :</strong> Introduction à la complexité algorithmique (notation Big-O).</li>
                <li><strong>Séance 11 :</strong> Pratique - Comparaison des algorithmes de tri simples (insertion, sélection).</li>
                <li><strong>Séance 12 :</strong> Exercices d’analyse de la complexité d’algorithmes dans des jeux vidéos et la vie réelle.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 5 : Structures de Données - Graphes</h3>
            <ul>
                <li><strong>Séance 13 :</strong> Introduction aux graphes et à leurs applications (théorie des graphes).</li>
                <li><strong>Séance 14 :</strong> Pratique - Représentation d'un réseau de routes dans un jeu vidéo avec des graphes.</li>
                <li><strong>Séance 15 :</strong> Algorithmes de parcours de graphes (DFS et BFS).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 6 : Algorithmes de Parcours de Graphes</h3>
            <ul>
                <li><strong>Séance 16 :</strong> Approfondissement sur l’algorithme DFS (Depth-First Search).</li>
                <li><strong>Séance 17 :</strong> Pratique - Exploration d'un monde ouvert (jeu vidéo) avec DFS.</li>
                <li><strong>Séance 18 :</strong> Applications réelles des graphes (réseaux sociaux, chemins dans les transports).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 7 : Arbres Binaires</h3>
            <ul>
                <li><strong>Séance 19 :</strong> Introduction aux arbres binaires et leurs applications.</li>
                <li><strong>Séance 20 :</strong> Pratique - Utilisation d’arbres pour organiser une base de données de personnages de manga.</li>
                <li><strong>Séance 21 :</strong> Algorithmes de parcours d’arbres (pré-ordre, en-ordre, post-ordre).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 8 : Algorithmes sur les Arbres</h3>
            <ul>
                <li><strong>Séance 22 :</strong> Approfondissement sur les algorithmes de parcours d’arbres.</li>
                <li><strong>Séance 23 :</strong> Pratique - Création d’un arbre de décision pour un jeu de rôle (jeu vidéo).</li>
                <li><strong>Séance 24 :</strong> Analyse des performances et avantages des arbres dans la recherche et le tri.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 9 : Algorithmes de Tri Avancés</h3>
            <ul>
                <li><strong>Séance 25 :</strong> Introduction au tri rapide (Quicksort).</li>
                <li><strong>Séance 26 :</strong> Pratique - Implémentation du Quicksort pour trier des scores de jeu vidéo.</li>
                <li><strong>Séance 27 :</strong> Comparaison de la complexité des différents algorithmes de tri.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 10 : Heapsort</h3>
            <ul>
                <li><strong>Séance 28 :</strong> Introduction au tri par tas (Heapsort).</li>
                <li><strong>Séance 29 :</strong> Pratique - Utilisation du Heapsort pour organiser un inventaire dans un jeu vidéo.</li>
                <li><strong>Séance 30 :</strong> Analyse de la complexité du Heapsort et de ses applications.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 11 : Tri Fusion</h3>
            <ul>
                <li><strong>Séance 31 :</strong> Introduction au tri fusion (Merge Sort).</li>
                <li><strong>Séance 32 :</strong> Pratique - Implémentation du tri fusion pour classer des mangas par popularité.</li>
                <li><strong>Séance 33 :</strong> Étude comparative des algorithmes de tri avancés (Quicksort, Heapsort, Merge Sort).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 12 : Optimisation des Algorithmes de Tri</h3>
            <ul>
                <li><strong>Séance 34 :</strong> Optimisation des algorithmes de tri dans des contextes réels.</li>
                <li><strong>Séance 35 :</strong> Pratique - Choisir et implémenter l’algorithme de tri le plus efficace pour différentes situations (jeu vidéo, actualité).</li>
                <li><strong>Séance 36 :</strong> Révision et consolidation des concepts d'algorithmes de tri.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 13 : Programmation Orientée Objet (POO)</h3>
            <ul>
                <li><strong>Séance 37 :</strong> Introduction à la POO (classes, objets, méthodes).</li>
                <li><strong>Séance 38 :</strong> Pratique - Modélisation d’un personnage de jeu vidéo en POO.</li>
                <li><strong>Séance 39 :</strong> Héritage et polymorphisme (théorie).</li>
            </ul>
        
            <!-- Continuez d'ajouter les semaines suivantes en suivant cette structure -->
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 14 : Héritage et Polymorphisme</h3>
            <ul>
                <li><strong>Séance 40 :</strong> Pratique - Implémentation d’un système d’héritage dans une application de gestion de personnages (jeu vidéo).</li>
                <li><strong>Séance 41 :</strong> Design patterns (Singleton, Factory).</li>
                <li><strong>Séance 42 :</strong> Pratique - Utilisation de design patterns pour optimiser la gestion des niveaux d’un jeu vidéo.</li>
            </ul>
        
            <!-- Ajoutez plus de semaines ici -->
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Semaine 36 : Bilan et Clôture</h3>
            <ul>
                <li><strong>Séance 106 :</strong> Bilan de l’année et retour sur les projets.</li>
                <li><strong>Séance 107 :</strong> Clôture et perspectives pour le futur.</li>
                <li><strong>Séance 108 :</strong> Journée de détente (activité créative, jeux de programmation).</li>
            </ul>
        </section>

        <!-- Calendrier -->
        <section id="calendar" class="content-section">
            <h2>Calendrier de cours des Tle NSI - 2024/2025</h2>
            <table class="calendar">
                <thead>
                    <tr>
                        <th>Date Mercredi</th>
                        <th>Cours Mercredi</th>
                        <th>Date Jeudi</th>
                        <th>Cours Jeudi</th>
                        <th>Date Vendredi</th>
                        <th>Cours Vendredi</th>
                    </tr>
                </thead>
                <tbody id="calendar-body">
                    <!-- Les lignes du calendrier seront générées ici par JavaScript -->
                </tbody>
            </table>
        </section>

        <section id="session1" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 1 : Introduction à la Récursivité (Concepts de Base)</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectifs de la séance :</h3>
            <ul>
                <li>Comprendre le concept de récursivité (cas de base et cas récursif).</li>
                <li>Savoir identifier et écrire des fonctions récursives.</li>
                <li>Appliquer la récursivité dans un problème lié aux jeux vidéo.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte : Sauver le héros d’un labyrinthe</h3>
            <p>L’objectif est d'aider un héros à sortir d’un labyrinthe en utilisant la récursivité. Chaque étape dans le labyrinthe représente une décision à prendre pour avancer ou reculer. Le labyrinthe est un tableau 2D où chaque cellule peut être un mur, un chemin ou la sortie.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Introduction au concept de récursivité</h3>
            <p>Qu’est-ce que la récursivité ?</p>
            <p>Une fonction récursive est une fonction qui s'appelle elle-même pour résoudre une version plus simple d’un problème.</p>
        
            <p>Une fonction récursive suit deux règles :</p>
            <ul>
                <li><strong>Cas de base :</strong> Condition d’arrêt pour éviter que la fonction ne s'appelle indéfiniment.</li>
                <li><strong>Cas récursif :</strong> Un appel à la fonction elle-même avec une version réduite du problème.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple simple : La Factorielle</h4>
            <pre><code>
                def factorielle(n):
                    if n == 0:  # Cas de base
                        return 1
                    else:
                        return n * factorielle(n - 1)  # Cas récursif
            </code></pre>
        
            <p>Explication du fonctionnement :</p>
            <p>Si <code>n = 3</code>, la fonction va appeler <code>factorielle(2)</code>, puis <code>factorielle(1)</code>, puis <code>factorielle(0)</code> qui est le cas de base, et renverra le résultat en remontant.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Application : Sauver un Héros Coincé dans un Labyrinthe</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Problème</h4>
            <p>Le héros est piégé dans un labyrinthe modélisé par une grille 2D. Il peut se déplacer à gauche, à droite, en haut ou en bas. L'objectif est de trouver la sortie (marquée par un "E") en utilisant une approche récursive.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Modélisation du labyrinthe</h4>
            <p>Nous représentons le labyrinthe comme une liste de listes en Python :</p>
        
            <pre><code>
                labyrinthe = [
                    ['S', 1, 0, 0, 1],
                    [0, 1, 0, 1, 0],
                    [0, 0, 0, 1, 'E'],
                    [1, 1, 0, 0, 1],
                    [0, 0, 0, 1, 0]
                ]
            </code></pre>
        
            <ul>
                <li><strong>'S' :</strong> Point de départ (start).</li>
                <li><strong>'E' :</strong> Sortie.</li>
                <li><strong>0 :</strong> Chemin libre.</li>
                <li><strong>1 :</strong> Mur.</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exploration récursive du labyrinthe</h4>
            <p>Le héros doit explorer toutes les directions possibles. Pour cela, nous allons créer une fonction récursive qui essaie toutes les directions (haut, bas, gauche, droite).</p>
        
            <pre><code>
                def explorer_labyrinthe(labyrinthe, x, y, visitees):
                    # Vérifier les limites du labyrinthe
                    if x < 0 or x >= len(labyrinthe) or y < 0 or y >= len(labyrinthe[0]):
                        return False
                    
                    # Vérifier si la case est un mur ou déjà visitée
                    if labyrinthe[x][y] == 1 or (x, y) in visitees:
                        return False
                    
                    # Si on a trouvé la sortie
                    if labyrinthe[x][y] == 'E':
                        print(f"Sortie trouvée à la position ({x}, {y})")
                        return True
                    
                    # Marquer la case comme visitée
                    visitees.add((x, y))
                    
                    # Appeler la fonction récursive dans les 4 directions
                    if (explorer_labyrinthe(labyrinthe, x+1, y, visitees) or  # Bas
                        explorer_labyrinthe(labyrinthe, x-1, y, visitees) or  # Haut
                        explorer_labyrinthe(labyrinthe, x, y+1, visitees) or  # Droite
                        explorer_labyrinthe(labyrinthe, x, y-1, visitees)):   # Gauche
                        return True
                    
                    # Si aucune direction ne fonctionne, on retourne False
                    return False
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Explication du Code</h4>
            <ul>
                <li><strong>Cas de base :</strong> Si le héros sort du labyrinthe ou rencontre un mur (<code>1</code>), la fonction retourne <code>False</code>. Si le héros atteint la sortie (<code>'E'</code>), la fonction retourne <code>True</code>.</li>
                <li><strong>Cas récursif :</strong> Le héros essaie chaque direction (bas, haut, gauche, droite) en appelant la fonction récursive pour continuer à explorer le labyrinthe.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Mise en Pratique</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Tester l’exploration du labyrinthe</h4>
            <p>Les élèves doivent modifier et exécuter la fonction pour que le héros puisse trouver la sortie.</p>
        
            <pre><code>
                # Position de départ (0, 0)
                position_depart = (0, 0)
                
                # Ensemble des cases visitées
                cases_visitees = set()
                
                # Lancer la recherche de la sortie
                explorer_labyrinthe(labyrinthe, position_depart[0], position_depart[1], cases_visitees)
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Améliorations</h4>
            <ul>
                <li><strong>Marquer le chemin parcouru :</strong> Ajouter une fonctionnalité pour afficher le chemin que le héros a pris jusqu'à la sortie.</li>
                <li><strong>Compter les mouvements :</strong> Ajouter un compteur pour afficher combien de mouvements le héros a effectués avant de trouver la sortie.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Conclusion et Récapitulatif</h3>
        
            <p><strong>Ce qu’ils ont appris :</strong></p>
            <ul>
                <li>Comprendre les concepts de récursivité avec un cas de base et un cas récursif.</li>
                <li>Appliquer la récursivité pour résoudre des problèmes complexes, comme un labyrinthe.</li>
            </ul>
        
            <p><strong>Défis à venir :</strong></p>
            <ul>
                <li>D'autres applications de la récursivité dans les jeux vidéo et les structures de données (arbres, tri récursif).</li>
                <li>Combiner récursivité et optimisations (mémoïsation) pour rendre les algorithmes plus efficaces.</li>
            </ul>
        
        </section>

        <section id="session2" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 2 : Pratique - Implémentation d’une Fonction Récursive pour Calculer une Suite Mathématique</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectif :</h3>
            <ul>
                <li>Comprendre et implémenter une fonction récursive.</li>
                <li>Appliquer la récursivité pour résoudre un problème pratique, inspiré des mécanismes de jeux vidéo.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Contexte :</h3>
            <p>Dans un jeu vidéo, un personnage accumule des points d'attaque supplémentaires au fil du temps à chaque coup porté à l'ennemi, mais les points bonus diminuent à chaque itération jusqu'à atteindre un seuil minimum. Cela peut être représenté par une suite mathématique où le bonus d'attaque à chaque coup est calculé récursivement.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple Concret :</h4>
            <p>Le personnage gagne 10 points d'attaque lors du premier coup, puis le bonus diminue de 1 point à chaque coup suivant. Cela forme une série mathématique décrite par :</p>
            <pre><code>Attaque(n) = Attaque(n−1) + (bonus initial − n)</code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 1 : Introduction à la Récursivité</h3>
            <p><strong>Concept de la récursivité :</strong></p>
            <p>Une fonction récursive s'appelle elle-même pour résoudre un problème plus simple à chaque étape, jusqu'à atteindre une condition de fin (ou cas de base).</p>
            
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple théorique :</h4>
            <p>Calcul de la suite de Fibonacci ou de la factorielle pour illustrer la récursivité.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 2 : Implémentation d'une Fonction Récursive</h3>
            <p><strong>Problème :</strong> Dans le jeu, à chaque attaque, le personnage accumule des points bonus. Le premier coup ajoute 10 points, puis chaque coup suivant ajoute 1 point de moins que le précédent jusqu'à atteindre 0. L'objectif est de calculer combien de points d'attaque sont accumulés après un certain nombre de coups.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Fonction récursive pour calculer le bonus d'attaque :</h4>
            <pre><code>
                def attaque_bonus(n):
                    # Cas de base : quand le bonus atteint 0
                    if n == 0:
                        return 0
                    else:
                        # Récursion : bonus initial (10) - n + bonus précédent
                        return (10 - n) + attaque_bonus(n - 1)
                
                # Exemple d'utilisation :
                coups = 5  # Le personnage donne 5 coups
                total_bonus = attaque_bonus(coups)
                print(f"Le total des points d'attaque après {coups} coups est de : {total_bonus}")
            </code></pre>
        
            <p><strong>Explication :</strong></p>
            <ul>
                <li>La fonction se base sur un cas de base où aucun coup n'est porté (0 bonus).</li>
                <li>À chaque appel récursif, le nombre de coups diminue de 1, et le bonus est calculé en fonction du coup précédent.</li>
                <li>Le bonus d’attaque diminue jusqu'à ce que la fonction atteigne le cas de base (0).</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 3 : Étendre la Fonctionnalité</h3>
            <p>Amélioration du jeu : Proposer aux élèves d’ajouter des conditions supplémentaires :</p>
            <ul>
                <li>Le bonus ne peut pas descendre en dessous de 0.</li>
                <li>Ajouter un effet multiplicateur pour chaque coup critique (par exemple, multiplier par 2 si c’est un coup critique).</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple d’amélioration :</h4>
            <pre><code>
                def attaque_bonus(n, critique=False):
                    if n == 0:
                        return 0
                    else:
                        bonus = (10 - n)  # Le bonus diminue avec chaque coup
                        if critique and n % 3 == 0:
                            bonus *= 2  # Coup critique tous les 3 coups
                        return bonus + attaque_bonus(n - 1, critique)
                
                # Exemple d'utilisation :
                coups = 5
                total_bonus = attaque_bonus(coups, critique=True)
                print(f"Le total des points d'attaque avec coups critiques est de : {total_bonus}")
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Étape 4 : Exercices Pratiques</h3>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">1. Calcul d'attaque simple :</h4>
            <p>Modifier le nombre de coups portés et afficher le total des points d'attaque.</p>
            <p><strong>Exercice :</strong> Demander aux élèves de tester avec 3, 5 et 10 coups pour voir comment la récursivité calcule le total.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">2. Scénario avancé : Combats de boss :</h4>
            <p>Simuler un combat contre un boss où chaque coup critique donne des points bonus supplémentaires.</p>
            <p><strong>Exercice :</strong> Les élèves doivent implémenter une version du programme où tous les 5 coups, le personnage inflige un coup critique (multiplication du bonus par 3).</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion</h3>
            <p><strong>Retour sur la notion de récursivité :</strong></p>
            <ul>
                <li><strong>Avantage :</strong> La récursivité permet de simplifier des calculs répétitifs en divisant le problème en sous-problèmes.</li>
                <li><strong>Inconvénient :</strong> Elle peut entraîner des problèmes de performance si elle est mal utilisée (pile d'appels récursifs trop grande).</li>
            </ul>
        
            <p><strong>Lien avec le jeu vidéo :</strong> La récursivité est un outil puissant pour modéliser des mécanismes de jeu où des actions répétitives évoluent à chaque itération, comme la gestion des dégâts dans les combats.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice final :</h4>
            <p>Les élèves devront créer une version améliorée de la fonction récursive qui inclut plusieurs types de coups (coup normal, coup critique, coup spécial) avec des bonus différents et implémenter une stratégie pour battre un boss avec un nombre limité de coups.</p>
        </section>

        <section id="session3" class="content-section">
            <h2 style="margin-top: 30px; margin-bottom: 20px;">Séance 3 : Applications Pratiques de la Récursivité - Problèmes Simples</h2>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Objectifs de la séance :</h3>
            <ul>
                <li>Comprendre la récursivité à travers des exemples simples.</li>
                <li>Appliquer la récursivité pour résoudre des problèmes inspirés des jeux vidéo.</li>
                <li>Créer des programmes interactifs et ludiques en utilisant la récursivité.</li>
            </ul>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">1. Rappel des concepts de base de la récursivité</h3>
            <p><strong>Cas de base :</strong> Condition qui permet d'arrêter la récursivité.</p>
            <p><strong>Cas récursif :</strong> La fonction qui s'appelle elle-même avec une version simplifiée du problème.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exemple théorique :</h4>
            <p>Calcul de la factorielle d’un nombre.</p>
            <pre><code>
                def factorielle(n):
                    if n == 0:
                        return 1  # Cas de base
                    else:
                        return n * factorielle(n - 1)  # Cas récursif
            </code></pre>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">2. Application : Exploration d'un Donjon Récursif</h3>
            <p>Dans ce projet, nous allons simuler un héros explorant un donjon. Le donjon est représenté par un labyrinthe (sous forme de matrice 2D), où le héros doit trouver la sortie. La récursivité sera utilisée pour explorer toutes les directions possibles à chaque intersection du labyrinthe.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Modélisation du donjon</h4>
            <p>Le donjon est représenté par une matrice où :</p>
            <ul>
                <li>1 représente un mur,</li>
                <li>0 représente un chemin libre,</li>
                <li><strong>S</strong> la position de départ,</li>
                <li><strong>E</strong> la sortie à atteindre.</li>
            </ul>
            <pre><code>
                donjon = [
                    ['S', 1, 0, 0, 1],
                    [0, 1, 0, 1, 0],
                    [0, 0, 0, 1, 'E'],
                    [1, 1, 0, 0, 1],
                    [0, 0, 0, 1, 0]
                ]
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Création de la fonction récursive d’exploration</h4>
            <p>On écrit une fonction récursive pour explorer le donjon. À chaque étape, le héros explore les cases adjacentes (haut, bas, gauche, droite) jusqu'à trouver la sortie.</p>
            <pre><code>
                def explorer_donjon(donjon, x, y, visitees):
                    # Vérifier les limites du donjon
                    if x < 0 or x >= len(donjon) or y < 0 or y >= len(donjon[0]):
                        return False
                    
                    # Vérifier si c'est un mur ou une case déjà visitée
                    if donjon[x][y] == 1 or (x, y) in visitees:
                        return False
                    
                    # Si on a trouvé la sortie
                    if donjon[x][y] == 'E':
                        print(f"Sortie trouvée à la position ({x}, {y})")
                        return True
                    
                    # Marquer la case comme visitée
                    visitees.add((x, y))
                    
                    # Exploration récursive des 4 directions
                    if (explorer_donjon(donjon, x+1, y, visitees) or  # Bas
                        explorer_donjon(donjon, x-1, y, visitees) or  # Haut
                        explorer_donjon(donjon, x, y+1, visitees) or  # Droite
                        explorer_donjon(donjon, x, y-1, visitees)):   # Gauche
                        return True
                    
                    # Si aucune direction ne permet d’avancer, retour en arrière
                    return False
            </code></pre>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 3 : Lancement de l'exploration</h4>
            <p>L’appel de la fonction d'exploration depuis la position de départ :</p>
            <pre><code>
                visitees = set()
                explorer_donjon(donjon, 0, 0, visitees)
            </code></pre>
            <p>Les élèves peuvent visualiser comment la récursivité permet au héros de tester différentes directions jusqu'à trouver la sortie du donjon.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">3. Application : Génération de Terrains Fractals avec la Récursivité</h3>
            <p>Un autre exemple ludique pour explorer la récursivité est la génération de terrains fractals. C’est un algorithme utilisé dans certains jeux vidéo pour générer des paysages ou des environnements de manière procédurale.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 1 : Introduction au concept des fractals</h4>
            <p>Explication de la notion de fractal : une figure qui se divise en parties similaires à l'ensemble.</p>
            <p>On montre un exemple simple, tel que le triangle de Sierpinski ou un arbre fractal, qui est un arbre où chaque branche se divise en deux sous-branches plus petites.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Étape 2 : Génération d’un arbre fractal</h4>
            <p>Nous allons utiliser la récursivité pour dessiner un arbre où chaque branche se divise en deux sous-branches plus petites. Pour simplifier, on peut utiliser la bibliothèque turtle de Python, qui permet de dessiner facilement.</p>
            <pre><code>
                import turtle
        
                def dessiner_arbre(longueur, angle):
                    if longueur > 5:
                        turtle.forward(longueur)
                        turtle.right(angle)
                        dessiner_arbre(longueur - 15, angle)
                        turtle.left(angle * 2)
                        dessiner_arbre(longueur - 15, angle)
                        turtle.right(angle)
                        turtle.backward(longueur)
                
                # Initialisation de Turtle
                turtle.speed("fastest")
                turtle.left(90)  # Faire pointer la tortue vers le haut
                dessiner_arbre(100, 30)  # Commence avec une longueur de 100
                turtle.done()
            </code></pre>
            <p>Les élèves pourront voir comment la récursivité permet de générer une figure qui se répète de manière auto-similaire.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">4. Conclusion et Améliorations</h3>
            <p><strong>Extension de l’exploration du donjon :</strong> Les élèves peuvent être encouragés à ajouter des obstacles, des trésors ou d'autres éléments interactifs dans le donjon pour rendre l'exploration plus intéressante.</p>
            <p><strong>Améliorations sur l’arbre fractal :</strong> Les élèves peuvent modifier l’angle de l’arbre fractal ou ajouter des couleurs pour rendre le dessin plus complexe et esthétique.</p>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Discussion :</h4>
            <ul>
                <li>Quand utiliser la récursivité vs les boucles ?</li>
                <li>Les limites de la récursivité (profondeur maximale de récursion, efficacité).</li>
            </ul>
        
            <h4 style="margin-top: 20px; margin-bottom: 20px;">Exercice :</h4>
            <p>Modifier le code de l’exploration du donjon pour ajouter des monstres ou des pièges à éviter pendant l'exploration.</p>
        
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Conclusion de la Séance</h3>
            <p>À la fin de cette séance, les élèves auront appris à utiliser la récursivité pour résoudre des problèmes d’exploration et de génération d’environnements, avec des exemples concrets tirés des jeux vidéo. Cela les prépare à appliquer la récursivité dans des projets plus complexes à l'avenir.</p>
        </section>

              
        
    </main>

    <!-- <footer>
        <p>&copy; 2024 Programme NSI Tle</p>
    </footer> -->

    <script>
        const holidays = {
            '2024-11-11': 'Armistice 1918',
            '2024-12-25': 'Noël',
            '2025-01-01': 'Jour de l\'An',
            '2025-04-21': 'Lundi de Pâques',
            '2025-05-01': 'Fête du Travail',
            '2025-05-08': 'Victoire 1945',
            '2025-05-29': 'Ascension',
            '2025-06-09': 'Lundi de Pentecôte'
        };
    
        const vacations = [
            { start: '2024-10-19', end: '2024-11-03', name: 'Vacances de la Toussaint' },
            { start: '2024-12-21', end: '2025-01-05', name: 'Vacances de Noël' },
            { start: '2025-02-22', end: '2025-03-09', name: 'Vacances d\'hiver' },
            { start: '2025-04-19', end: '2025-05-04', name: 'Vacances de printemps' },
            { start: '2025-07-05', end: '2025-09-02', name: 'Vacances d\'été' }
        ];
    
        const sessions = [
            'Séance 1 : Introduction à la récursivité (concepts de base)',
            'Séance 2 : Pratique - Implémentation d’une fonction récursive pour calculer une suite mathématique',
            'Séance 3 : Applications pratiques de la récursivité (problèmes simples)',
            ''
        ];
    
        function isHoliday(date) {
            return holidays[date] !== undefined;
        }
    
        function isInVacation(date) {
            const parsedDate = new Date(date);
            return vacations.some(vacation => {
                const startDate = new Date(vacation.start);
                const endDate = new Date(vacation.end);
                return parsedDate >= startDate && parsedDate <= endDate;
            });
        }
    
        function getVacationName(date) {
            const parsedDate = new Date(date);
            const vacation = vacations.find(vacation => {
                const startDate = new Date(vacation.start);
                const endDate = new Date(vacation.end);
                return parsedDate >= startDate && parsedDate <= endDate;
            });
            return vacation ? vacation.name : '';
        }
    
        function formatFrenchDate(date) {
            const options = { year: 'numeric', month: '2-digit', day: '2-digit' };
            return new Date(date).toLocaleDateString('fr-FR', options);
        }
    
        function isCurrentWeek(date) {
            const currentDate = new Date();
            const firstDayOfWeek = new Date(date);
            const lastDayOfWeek = new Date(firstDayOfWeek);
            lastDayOfWeek.setDate(firstDayOfWeek.getDate() + 6);
            return currentDate >= firstDayOfWeek && currentDate <= lastDayOfWeek;
        }

        function isToday(date) {
            const today = new Date().toISOString().split('T')[0];
            return today === date;
        }
    
        function generateCalendar() {
            const calendarBody = document.getElementById('calendar-body');
            const startDate = new Date('2024-09-04');  // Premier mercredi de septembre 2024
            const endDate = new Date('2025-07-12');
            
            let currentDate = startDate;
            let sessionIndex = 0;
    
            while (currentDate <= endDate) {
                const row = document.createElement('tr');
    
                // Mercredi
                const wednesdayDateString = currentDate.toISOString().split('T')[0];
                const wednesdayCell = document.createElement('td');
                wednesdayCell.textContent = formatFrenchDate(wednesdayDateString);
    
                const wednesdayDescCell = document.createElement('td');
                if (isHoliday(wednesdayDateString)) {
                    wednesdayDescCell.textContent = holidays[wednesdayDateString];
                    wednesdayCell.classList.add('holiday');
                    wednesdayDescCell.classList.add('holiday');
                } else if (isInVacation(wednesdayDateString)) {
                    wednesdayDescCell.textContent = getVacationName(wednesdayDateString);
                    row.classList.add('vacation');
                } else {
                    wednesdayDescCell.textContent = sessions[sessionIndex] || 'Séance à définir';
                    sessionIndex++;
                }

                // Mise en évidence du jour actuel
                if (isToday(wednesdayDateString)) {
                    wednesdayCell.classList.add('today');
                    wednesdayDescCell.classList.add('today');
                }
    
                // Jeudi
                currentDate.setDate(currentDate.getDate() + 1);  // Jeudi
                const thursdayDateString = currentDate.toISOString().split('T')[0];
                const thursdayCell = document.createElement('td');
                thursdayCell.textContent = formatFrenchDate(thursdayDateString);
    
                const thursdayDescCell = document.createElement('td');
                if (isHoliday(thursdayDateString)) {
                    thursdayDescCell.textContent = holidays[thursdayDateString];
                    thursdayCell.classList.add('holiday');
                    thursdayDescCell.classList.add('holiday');
                } else if (isInVacation(thursdayDateString)) {
                    thursdayDescCell.textContent = getVacationName(thursdayDateString);
                    row.classList.add('vacation');
                } else {
                    thursdayDescCell.textContent = sessions[sessionIndex] || 'Séance à définir';
                    sessionIndex++;
                }

                // Mise en évidence du jour actuel
                if (isToday(thursdayDateString)) {
                    thursdayCell.classList.add('today');
                    thursdayDescCell.classList.add('today');
                }
    
                // Vendredi
                currentDate.setDate(currentDate.getDate() + 1);  // Vendredi
                const fridayDateString = currentDate.toISOString().split('T')[0];
                const fridayCell = document.createElement('td');
                fridayCell.textContent = formatFrenchDate(fridayDateString);
    
                const fridayDescCell = document.createElement('td');
                if (isHoliday(fridayDateString)) {
                    fridayDescCell.textContent = holidays[fridayDateString];
                    fridayCell.classList.add('holiday');
                    fridayDescCell.classList.add('holiday');
                } else if (isInVacation(fridayDateString)) {
                    fridayDescCell.textContent = getVacationName(fridayDateString);
                    row.classList.add('vacation');
                } else {
                    fridayDescCell.textContent = sessions[sessionIndex] || 'Séance à définir';
                    sessionIndex++;
                }

                // Mise en évidence du jour actuel
                if (isToday(fridayDateString)) {
                    fridayCell.classList.add('today');
                    fridayDescCell.classList.add('today');
                }
    
                // Mettre en évidence la semaine en cours
                if (isCurrentWeek(currentDate)) {
                    row.classList.add('current-week');
                }
    
                // Ajout des cellules à la ligne
                row.appendChild(wednesdayCell);
                row.appendChild(wednesdayDescCell);
                row.appendChild(thursdayCell);
                row.appendChild(thursdayDescCell);
                row.appendChild(fridayCell);
                row.appendChild(fridayDescCell);
                calendarBody.appendChild(row);
    
                // Passer au mercredi suivant
                currentDate.setDate(currentDate.getDate() + 5);
            }
        }
    
        // Générer le calendrier au chargement de la page
        generateCalendar();    

        // Toggle menu visibility
        function toggleMenu() {
            const menu = document.getElementById("session-nav");
            menu.style.display = menu.style.display === "block" ? "none" : "block";
        }

        // Show selected session content
        function showSession(sessionId) {
            const sessions = document.querySelectorAll('.content-section');
            sessions.forEach(session => {
                session.classList.remove('active');
                if (session.id === sessionId) {
                    session.classList.add('active');
                }
            });

            // Mettre en évidence la séance active dans le menu
            const menuLinks = document.querySelectorAll('#session-nav a');
            menuLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('onclick').includes(sessionId)) {
                    link.classList.add('active');
                }
            });
        }

        // Display the first session by default when page loads
        document.addEventListener('DOMContentLoaded', () => {
            showSession('session1');
        });
    </script>

</body>
</html>
